<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js lfe-pdp">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Structure and Interpretation of Computer Programs</title>
    
    <meta name="robots" content="noindex" />
    
    


    <!-- Custom HTML head -->
    


    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="The LFE Edition of the Classic Scheme Book">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    
    <link rel="stylesheet" href="fonts/fonts.css">
    

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    

    
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "lfe-pdp" : "lfe-pdp";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('lfe-pdp')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">SICP</a></li><li class="chapter-item expanded affix "><a href="fm/title.html">Title Page</a></li><li class="chapter-item expanded affix "><a href="fm/copyright-page.html">Copyright Page</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fm/dedication.html"><strong aria-hidden="true">1.1.</strong> Dedication</a></li><li class="chapter-item expanded "><a href="fm/foreword.html"><strong aria-hidden="true">1.2.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="fm/lfe-foreword.html"><strong aria-hidden="true">1.3.</strong> Foreword to the LFE Edition</a></li><li class="chapter-item expanded "><a href="fm/preface-3/index.html"><strong aria-hidden="true">1.4.</strong> Preface to the LFE Edition</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fm/preface-3/origins.html"><strong aria-hidden="true">1.4.1.</strong> The Hidden Origins of Lisp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fm/preface-3/peano.html"><strong aria-hidden="true">1.4.1.1.</strong> Giuseppe Peano</a></li><li class="chapter-item expanded "><a href="fm/preface-3/russell.html"><strong aria-hidden="true">1.4.1.2.</strong> Bertrand Russell</a></li><li class="chapter-item expanded "><a href="fm/preface-3/church.html"><strong aria-hidden="true">1.4.1.3.</strong> Alonzo Church</a></li><li class="chapter-item expanded "><a href="fm/preface-3/mccarthy.html"><strong aria-hidden="true">1.4.1.4.</strong> John McCarthy</a></li></ol></li><li class="chapter-item expanded "><a href="fm/preface-3/erlang.html"><strong aria-hidden="true">1.4.2.</strong> A Recap of Erlang's Genesis</a></li><li class="chapter-item expanded "><a href="fm/preface-3/lfe.html"><strong aria-hidden="true">1.4.3.</strong> The Inspiration for LFE</a></li><li class="chapter-item expanded "><a href="fm/preface-3/21stcent.html"><strong aria-hidden="true">1.4.4.</strong> The Place of Lisp in the 21st Century</a></li><li class="chapter-item expanded "><a href="fm/preface-3/changes.html"><strong aria-hidden="true">1.4.5.</strong> Notes on Changes from the Original</a></li><li class="chapter-item expanded "><a href="fm/preface-3/sources.html"><strong aria-hidden="true">1.4.6.</strong> Obtaining the Book and Related Code</a></li></ol></li><li class="chapter-item expanded "><a href="fm/preface-2.html"><strong aria-hidden="true">1.5.</strong> Preface to the Second Edition</a></li><li class="chapter-item expanded "><a href="fm/preface-1.html"><strong aria-hidden="true">1.6.</strong> Preface to the First Edition</a></li><li class="chapter-item expanded "><a href="fm/acknowledgments.html"><strong aria-hidden="true">1.7.</strong> Acknowledgments</a></li></ol></li><li class="chapter-item expanded "><a href="ch1/building-abstractions-with-functions.html"><strong aria-hidden="true">2.</strong> Building Abstractions with Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1/programming-in-lisp.html"><strong aria-hidden="true">2.1.</strong> Programming in Lisp</a></li><li class="chapter-item expanded "><a href="ch1/the-elements-of-programming.html"><strong aria-hidden="true">2.2.</strong> The Elements of Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1/expressions.html"><strong aria-hidden="true">2.2.1.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="ch1/naming-and-the-environment.html"><strong aria-hidden="true">2.2.2.</strong> Naming and the Environment</a></li><li class="chapter-item expanded "><a href="ch1/evaluating-combinations.html"><strong aria-hidden="true">2.2.3.</strong> Evaluating Combinations</a></li><li class="chapter-item expanded "><a href="ch1/compound-functions.html"><strong aria-hidden="true">2.2.4.</strong> Compound Functions</a></li><li class="chapter-item expanded "><a href="ch1/the-substitution-model-for-function-application.html"><strong aria-hidden="true">2.2.5.</strong> The Substitution Model for Function Application</a></li><li class="chapter-item expanded "><a href="ch1/conditional-expressions-and-predicates.html"><strong aria-hidden="true">2.2.6.</strong> Conditional Expressions and Predicates</a></li><li class="chapter-item expanded "><a href="ch1/exercises-1.html"><strong aria-hidden="true">2.2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/example-square-roots-by-newtons-method.html"><strong aria-hidden="true">2.2.8.</strong> Example: Square Roots by Newton's Method</a></li><li class="chapter-item expanded "><a href="ch1/exercises-2.html"><strong aria-hidden="true">2.2.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/functions-as-black-box-abstractions.html"><strong aria-hidden="true">2.2.10.</strong> Functions as Black-Box Abstractions</a></li></ol></li><li class="chapter-item expanded "><a href="ch1/functions-and-the-processes-they-generate.html"><strong aria-hidden="true">2.3.</strong> Functions and the Processes They Generate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1/linear-recursion-and-iteration.html"><strong aria-hidden="true">2.3.1.</strong> Linear Recursion and Iteration</a></li><li class="chapter-item expanded "><a href="ch1/exercises-3.html"><strong aria-hidden="true">2.3.2.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/tree-recursion.html"><strong aria-hidden="true">2.3.3.</strong> Tree Recursion</a></li><li class="chapter-item expanded "><a href="ch1/exercises-4.html"><strong aria-hidden="true">2.3.4.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/orders-of-growth.html"><strong aria-hidden="true">2.3.5.</strong> Orders of Growth</a></li><li class="chapter-item expanded "><a href="ch1/exercises-5.html"><strong aria-hidden="true">2.3.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/exponentiation.html"><strong aria-hidden="true">2.3.7.</strong> Exponentiation</a></li><li class="chapter-item expanded "><a href="ch1/exercises-6.html"><strong aria-hidden="true">2.3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/greatest-common-divisors.html"><strong aria-hidden="true">2.3.9.</strong> Greatest Common Divisors</a></li><li class="chapter-item expanded "><a href="ch1/exercises-7.html"><strong aria-hidden="true">2.3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/example-testing-for-primality.html"><strong aria-hidden="true">2.3.11.</strong> Example: Testing for Primality</a></li><li class="chapter-item expanded "><a href="ch1/exercises-8.html"><strong aria-hidden="true">2.3.12.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="ch1/formulating-abstractions-with-higher-order-functions.html"><strong aria-hidden="true">2.4.</strong> Formulating Abstractions with Higher-Order Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1/functions-as-arguments.html"><strong aria-hidden="true">2.4.1.</strong> Functions as Arguments</a></li><li class="chapter-item expanded "><a href="ch1/exercises-9.html"><strong aria-hidden="true">2.4.2.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/constructing-functions-using-lambda.html"><strong aria-hidden="true">2.4.3.</strong> Constructing Functions Using Lambda</a></li><li class="chapter-item expanded "><a href="ch1/exercises-10.html"><strong aria-hidden="true">2.4.4.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/functions-as-general-methods.html"><strong aria-hidden="true">2.4.5.</strong> Functions as General Methods</a></li><li class="chapter-item expanded "><a href="ch1/exercises-11.html"><strong aria-hidden="true">2.4.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch1/functions-as-returned-values.html"><strong aria-hidden="true">2.4.7.</strong> Functions as Returned Values</a></li><li class="chapter-item expanded "><a href="ch1/exercises-12.html"><strong aria-hidden="true">2.4.8.</strong> Exercises</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch2/building-abstractions-with-data.html"><strong aria-hidden="true">3.</strong> Building Abstractions with Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2/introduction-to-data-abstraction.html"><strong aria-hidden="true">3.1.</strong> Introduction to Data Abstraction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2/example-arithmetic-operationsfor-rational-numbers.html"><strong aria-hidden="true">3.1.1.</strong> Example: Arithmetic Operations for Rational Numbers</a></li><li class="chapter-item expanded "><a href="ch2/exercises-1.html"><strong aria-hidden="true">3.1.2.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/abstraction-barriers.html"><strong aria-hidden="true">3.1.3.</strong> Abstraction Barriers</a></li><li class="chapter-item expanded "><a href="ch2/exercises-2.html"><strong aria-hidden="true">3.1.4.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/what-is-meant-by-data.html"><strong aria-hidden="true">3.1.5.</strong> What Is Meant by Data?</a></li><li class="chapter-item expanded "><a href="ch2/exercises-3.html"><strong aria-hidden="true">3.1.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/extended-exercise-interval-arithmetic.html"><strong aria-hidden="true">3.1.7.</strong> Extended Exercise: Interval Arithmetic</a></li><li class="chapter-item expanded "><a href="ch2/exercises-4.html"><strong aria-hidden="true">3.1.8.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="ch2/hierarchical-data-and-the-closure-property.html"><strong aria-hidden="true">3.2.</strong> Hierarchical Data and the Closure Property</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2/representing-sequences.html"><strong aria-hidden="true">3.2.1.</strong> Representing Sequences</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2/representing-sequences-list-operations.html"><strong aria-hidden="true">3.2.1.1.</strong> List operations</a></li><li class="chapter-item expanded "><a href="ch2/exercises-5.html"><strong aria-hidden="true">3.2.1.2.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/representing-sequences-mapping-over-lists.html"><strong aria-hidden="true">3.2.1.3.</strong> Mapping over lists</a></li><li class="chapter-item expanded "><a href="ch2/exercises-6.html"><strong aria-hidden="true">3.2.1.4.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="ch2/hierarchical-structures.html"><strong aria-hidden="true">3.2.2.</strong> Hierarchical Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2/exercises-7.html"><strong aria-hidden="true">3.2.2.1.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/hierarchical-structures-mapping-over-trees.html"><strong aria-hidden="true">3.2.2.2.</strong> Mapping over trees</a></li><li class="chapter-item expanded "><a href="ch2/exercises-8.html"><strong aria-hidden="true">3.2.2.3.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="ch2/sequences-as-conventional-interfaces.html"><strong aria-hidden="true">3.2.3.</strong> Sequences as Conventional Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2/sequence-operations.html"><strong aria-hidden="true">3.2.3.1.</strong> Sequence operations</a></li><li class="chapter-item expanded "><a href="ch2/exercises-9.html"><strong aria-hidden="true">3.2.3.2.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/nested-mappings.html"><strong aria-hidden="true">3.2.3.3.</strong> Nested mappings</a></li><li class="chapter-item expanded "><a href="ch2/exercises-10.html"><strong aria-hidden="true">3.2.3.4.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="ch2/example-picture-language.html"><strong aria-hidden="true">3.2.4.</strong> Example: A Picture Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2/the-picture-language.html"><strong aria-hidden="true">3.2.4.1.</strong> The picture language</a></li><li class="chapter-item expanded "><a href="ch2/exercises-11.html"><strong aria-hidden="true">3.2.4.2.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/higher-order-operations.html"><strong aria-hidden="true">3.2.4.3.</strong> Higher order operations</a></li><li class="chapter-item expanded "><a href="ch2/frames.html"><strong aria-hidden="true">3.2.4.4.</strong> Frames</a></li><li class="chapter-item expanded "><a href="ch2/exercises-12.html"><strong aria-hidden="true">3.2.4.5.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/painters.html"><strong aria-hidden="true">3.2.4.6.</strong> Painters</a></li><li class="chapter-item expanded "><a href="ch2/exercises-13.html"><strong aria-hidden="true">3.2.4.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/transforming-and-combining-painters.html"><strong aria-hidden="true">3.2.4.8.</strong> Transforming and combining painters</a></li><li class="chapter-item expanded "><a href="ch2/exercises-14.html"><strong aria-hidden="true">3.2.4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch2/levels-of-language-for-robust-design.html"><strong aria-hidden="true">3.2.4.10.</strong> Levels of language for robust design</a></li><li class="chapter-item expanded "><a href="ch2/exercises-15.html"><strong aria-hidden="true">3.2.4.11.</strong> Exercises</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.3.</strong> Symbolic Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.3.1.</strong> Quotation</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.3.2.</strong> Example: Symbolic Differentiation</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.3.3.</strong> Example: Representing Sets</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.3.4.</strong> Example: Huffman Encoding Trees</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.4.</strong> Multiple Representations for Abstract Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.4.1.</strong> Representations for Complex Numbers</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.4.2.</strong> Tagged data</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.4.3.</strong> Data-Directed Programming and Additivity</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.5.</strong> Systems with Generic Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.5.1.</strong> Generic Arithmetic Operations</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.5.2.</strong> Combining Data of Different Types</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.5.3.</strong> Example: Symbolic Algebra</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.</strong> Modularity, Objects, and State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.1.</strong> Assignment and Local State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.1.1.</strong> Local State Variables</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.1.2.</strong> The Benefits of Introducing Assignment</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.1.3.</strong> The Costs of Introducing Assignment</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.2.</strong> The Environment Model of Evaluation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.2.1.</strong> The Rules for Evaluation</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.2.2.</strong> Applying Simple Functions</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.2.3.</strong> Frames as the Repository of Local State</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.2.4.</strong> Internal Definitions</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.3.</strong> Modeling with Mutable Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.3.1.</strong> Mutable List Structure</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.3.2.</strong> Representing Queues</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.3.3.</strong> Representing Tables</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.3.4.</strong> A Simulator for Digital Circuits</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.3.5.</strong> Propagation of Constraints</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.4.</strong> Concurrency: Time Is of the Essence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.4.1.</strong> The Nature of Time in Concurrent Systems</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.4.2.</strong> Mechanisms for Controlling Concurrency</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.5.</strong> Streams</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.5.1.</strong> Streams Are Delayed Lists</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.5.2.</strong> Infinite Streams</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.5.3.</strong> Exploiting the Stream Paradigm</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.5.4.</strong> Streams and Delayed Evaluation</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.5.5.</strong> Modularity of Functional Programs and Modularity of Objects</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.</strong> Metalinguistic Abstraction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.1.</strong> The Metacircular Evaluator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.1.1.</strong> The Core of the Evaluator</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.1.2.</strong> Representing Expressions</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.1.3.</strong> Evaluator Data Structures</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.1.4.</strong> Running the Evaluator as a Program</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.1.5.</strong> Data as Programs</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.1.6.</strong> Internal Definitions</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.1.7.</strong> Separating Syntactic Analysis from Execution</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.2.</strong> Variations on a Scheme -- Lazy Evaluation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.2.1.</strong> Normal Order and Applicative Order</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.2.2.</strong> An Interpreter with Lazy Evaluation</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.2.3.</strong> Streams as Lazy Lists</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.3.</strong> Variations on a Scheme -- Nondeterministic Computing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.3.1.</strong> Amb and Search</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.3.2.</strong> Examples of Nondeterministic Programs</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.3.3.</strong> Implementing the Amb Evaluator</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.4.</strong> Logic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.4.1.</strong> Deductive Information Retrieval</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.4.2.</strong> How the Query System Works</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.4.3.</strong> Is Logic Programming Mathematical Logic?</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">5.4.4.</strong> Implementing the Query System</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.</strong> Computing with Register Machines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.1.</strong> Designing Register Machines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.1.1.</strong> A Language for Describing Register Machines</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.1.2.</strong> Abstraction in Machine Design</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.1.3.</strong> Subroutines</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.1.4.</strong> Using a Stack to Implement Recursion</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.1.5.</strong> Instruction Summary</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.2.</strong> A Register-Machine Simulator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.2.1.</strong> The Machine Model</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.2.2.</strong> The Assembler</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.2.3.</strong> Generating Execution Functions for Instructions</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.2.4.</strong> Monitoring Machine Performance</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.3.</strong> Storage Allocation and Garbage Collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.3.1.</strong> Memory as Vectors</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.3.2.</strong> Maintaining the Illusion of Infinite Memory</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.4.</strong> The Explicit-Control Evaluator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.4.1.</strong> The Core of the Explicit-Control Evaluator</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.4.2.</strong> Sequence Evaluation and Tail Recursion</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.4.3.</strong> Conditionals, Assignments, and Definitions</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.4.4.</strong> Running the Evaluator</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.5.</strong> Compilation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.5.1.</strong> Structure of the Compiler</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.5.2.</strong> Compiling Expressions</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.5.3.</strong> Compiling Combinations</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.5.4.</strong> Combining Instruction Sequences</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.5.5.</strong> An Example of Compiled Code</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.5.6.</strong> Lexical Addressing</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">6.5.7.</strong> Interfacing Compiled Code to the Evaluator</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="bm/references.html"><strong aria-hidden="true">7.</strong> References</a></li><li class="chapter-item expanded "><a href="bm/list-of-exercises.html"><strong aria-hidden="true">8.</strong> List of Exercises</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="versions.html">Versions</a></li><li class="chapter-item expanded affix "><a href="feedback.html">Feedback</a></li><li class="chapter-item expanded affix "><a href="redirects/docs.html">LFE Documentation</a></li><li class="chapter-item expanded affix "><a href="redirects/mdbook.html">Built with mdBook</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme"
                                id="lfe-pdp">LFE PDP</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="light">Light</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                    
                </div>

                <h1 class="menu-title">Structure and Interpretation of Computer Programs</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    
                    <a href="https://github.com/cnbbooks/lfe-sicp/" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    
                </div>
            </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                        placeholder="Search this book ..." aria-controls="searchresults-outer"
                        aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <p><a href="images/cover-large.jpg"><img src="images/cover.jpg" alt="" /></a></p>
<!-- Named page links below: /-->
<h1><a class="header" href="#structure-and-interpretation-of-computer-programs" id="structure-and-interpretation-of-computer-programs">Structure and Interpretation of Computer Programs</a></h1>
<p><em>The LFE Edition</em></p>
<br/>
<br/>
<br/>
<br/>
<br/>
<p>Harold Abelson and Gerald Jay Sussman
with Julie Sussman</p>
<br/>
<p>foreword by Alan J. Perlis</p>
<br/>
<p>LFE translation by Duncan McGreggor</p>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<p><a href="http://cnbb.pub/"><img src="fm/../images/cnbb-pub-logo-1.6.png" alt="publisher logo" /></a></p>
<!-- Named page links below: /-->
<h1><a class="header" href="#first-edition" id="first-edition">First Edition</a></h1>
<p>The first edition of this book was comprised of a series of texts
written by faculty of the Electrical Engineering and Computer Science
Department at the Massachusetts Institute of Technology. It was edited and
produced by The MIT Press under a joint production-distribution arrangement
with the McGraw-Hill Book Company.</p>
<p><strong>Ordering Information</strong></p>
<p><em>North America</em></p>
<p>Text orders should be addressed to the McGraw-Hill Book Company.</p>
<p>All other orders should be addressed to The MIT Press.</p>
<p><em>Outside North America</em></p>
<p>All orders should be addressed to The MIT Press or its local distributor.</p>
<p>© 1996 by The Massachusetts Institute of Technology</p>
<h1><a class="header" href="#second-edition" id="second-edition">Second Edition</a></h1>
<p>All rights reserved. No part of this book may be reproduced in any form or
by any electronic or mechanical means (including photocopying, recording,
or information storage and retrieval) without permission in writing from
the publisher.</p>
<p><img src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" alt="Creative Commons Logo" /></p>
<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-Noncommercial 3.0 Unported License</a>.</p>
<p>This book was set by the authors using the LATEX typesetting system
and was printed and bound in the United States of America.</p>
<p><strong>Library of Congress Cataloging-in-Publication Data</strong></p>
<pre><code>Abelson, Harold
    Structure and interpretation of computer programs /
    Harold Abelson and Gerald Jay Sussman, with Julie Sussman. --
    2nd ed.
    p. cm. -- (Electrical engineering and computer science series)
    Includes bibliographical references and index.
    ISBN 0-262-01153-0 (MIT Press hardcover)
    ISBN 0-262-51087-1 (MIT Press paperback)
    ISBN 0-07-000484-6 (McGraw-Hill hardcover)
    1. Electronic digital computers -- Programming.
    2. LISP (Computer program language)
      I. Sussman, Gerald Jay.
      II. Sussman, Julie.
      III. Title.
      IV. Series: MIT electrical engineering and
                  computer science series.
QA76.6.A255         1996
005.13'3 -- dc20    96-17756
</code></pre>
<p>Fourth printing, 1999</p>
<h1><a class="header" href="#lfe-edition" id="lfe-edition">LFE Edition</a></h1>
<p>© 2015-2020 by Duncan McGreggor</p>
<p><img src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" alt="Creative Commons Logo" /></p>
<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-Noncommercial 3.0 Unported License</a>.</p>
<h2><a class="header" href="#about" id="about">About</a></h2>
<p>This Gitbook (available <a href="http://lfe.gitbooks.io/sicp/">here</a>)
is a work in progress, converting the MIT classic
<a href="http://mitpress.mit.edu/sicp/">Structure and Interpretation of Computer Programs</a>
to Lisp Flavored Erlang. We are forever indebted to Harold Abelson, Gerald
Jay Sussman, and Julie Sussman for their labor of love and intelligence.
Needless to say, our gratitude also extends to the MIT press for their
generosity in licensing this work as Creative Commons.</p>
<h2><a class="header" href="#contributing" id="contributing">Contributing</a></h2>
<p>This is a huge project, and we can use your help! Got an idea? Found a bug?
<a href="https://github.com/lfe/sicp/issues/new">Let us know!</a>.</p>
<h3><a class="header" href="#building-the-book" id="building-the-book">Building the Book</a></h3>
<p>To build a local copy of the book, install the dependencies:</p>
<pre><code class="language-bash">$ make deps
</code></pre>
<p>On Linux, you'll need to run that with <code>sudo</code>.</p>
<p>Then install the gitbook modules:</p>
<pre><code class="language-bash">$ make setup
</code></pre>
<p>Finally, build the book:</p>
<pre><code class="language-bash">$ make book
</code></pre>
<h1><a class="header" href="#dedication" id="dedication">Dedication</a></h1>
<p>This book is dedicated, in respect and admiration, to the spirit that lives in the computer.</p>
<blockquote>
I think that it's extraordinarily important that we in computer science keep fun in computing. When it started out, it was an awful lot of fun. Of course, the paying customers got shafted every now and then, and after a while we began to take their complaints seriously. We began to feel as if we really were responsible for the successful, error-free perfect use of these machines. I don't think we are. I think we're responsible for stretching them, setting them off in new directions, and keeping fun in the house. I hope the field of computer science never loses its sense of fun. Above all, I hope we don't become missionaries. Don't feel as if you're Bible salesmen. The world has too many of those already. What you know about computing other people will learn. Don't feel as if the key to successful computing is only in your hands. What's in your hands, I think and hope, is intelligence: the ability to see the machine as more than when you were first led up to it, that you can make it more.
</blockquote>
<p><em>-- Alan J. Perlis (April 1, 1922 - February 7, 1990)</em></p>
<h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<p>Educators, generals, dieticians, psychologists, and parents program. Armies, students, and some societies are programmed. An assault on large problems employs a succession of programs, most of which spring into existence en route. These programs are rife with issues that appear to be particular to the problem at hand. To appreciate programming as an intellectual activity in its own right you must turn to computer programming; you must read and write computer programs -- many of them. It doesn't matter much what the programs are about or what applications they serve. What does matter is how well they perform and how smoothly they fit with other programs in the creation of still greater programs. The programmer must seek both perfection of part and adequacy of collection. In this book the use of &quot;program&quot; is focused on the creation, execution, and study of programs written in a dialect of Lisp for execution on a digital computer. Using Lisp we restrict or limit not what we may program, but only the notation for our program descriptions.</p>
<p>Our traffic with the subject matter of this book involves us with three foci of phenomena: the human mind, collections of computer programs, and the computer. Every computer program is a model, hatched in the mind, of a real or mental process. These processes, arising from human experience and thought, are huge in number, intricate in detail, and at any time only partially understood. They are modeled to our permanent satisfaction rarely by our computer programs. Thus even though our programs are carefully handcrafted discrete collections of symbols, mosaics of interlocking functions, they continually evolve: we change them as our perception of the model deepens, enlarges, generalizes until the model ultimately attains a metastable place within still another model with which we struggle. The source of the exhilaration associated with computer programming is the continual unfolding within the mind and on the computer of mechanisms expressed as programs and the explosion of perception they generate. If art interprets our dreams, the computer executes them in the guise of programs!</p>
<p>For all its power, the computer is a harsh taskmaster. Its programs must be correct, and what we wish to say must be said accurately in every detail. As in every other symbolic activity, we become convinced of program truth through argument. Lisp itself can be assigned a semantics (another model, by the way), and if a program's function can be specified, say, in the predicate calculus, the proof methods of logic can be used to make an acceptable correctness argument. Unfortunately, as programs get large and complicated, as they almost always do, the adequacy, consistency, and correctness of the specifications themselves become open to doubt, so that complete formal arguments of correctness seldom accompany large programs. Since large programs grow from small ones, it is crucial that we develop an arsenal of standard program structures of whose correctness we have become sure -- we call them idioms -- and learn to combine them into larger structures using organizational techniques of proven value. These techniques are treated at length in this book, and understanding them is essential to participation in the Promethean enterprise called programming. More than anything else, the uncovering and mastery of powerful organizational techniques accelerates our ability to create large, significant programs. Conversely, since writing large programs is very taxing, we are stimulated to invent new methods of reducing the mass of function and detail to be fitted into large programs.</p>
<p>Unlike programs, computers must obey the laws of physics. If they wish to perform rapidly -- a few nanoseconds per state change -- they must transmit electrons only small distances (at most 1 1/2 feet). The heat generated by the huge number of devices so concentrated in space has to be removed. An exquisite engineering art has been developed balancing between multiplicity of function and density of devices. In any event, hardware always operates at a level more primitive than that at which we care to program. The processes that transform our Lisp programs to &quot;machine&quot; programs are themselves abstract models which we program. Their study and creation give a great deal of insight into the organizational programs associated with programming arbitrary models. Of course the computer itself can be so modeled. Think of it: the behavior of the smallest physical switching element is modeled by quantum mechanics described by differential equations whose detailed behavior is captured by numerical approximations represented in computer programs executing on computers composed of ...!</p>
<p>It is not merely a matter of tactical convenience to separately identify the three foci. Even though, as they say, it's all in the head, this logical separation induces an acceleration of symbolic traffic between these foci whose richness, vitality, and potential is exceeded in human experience only by the evolution of life itself. At best, relationships between the foci are metastable. The computers are never large enough or fast enough. Each breakthrough in hardware technology leads to more massive programming enterprises, new organizational principles, and an enrichment of abstract models. Every reader should ask himself periodically &quot;Toward what end, toward what end?&quot; -- but do not ask it too often lest you pass up the fun of programming for the constipation of bittersweet philosophy.</p>
<p>Among the programs we write, some (but never enough) perform a precise mathematical function such as sorting or finding the maximum of a sequence of numbers, determining primality, or finding the square root. We call such programs algorithms, and a great deal is known of their optimal behavior, particularly with respect to the two important parameters of execution time and data storage requirements. A programmer should acquire good algorithms and idioms. Even though some programs resist precise specifications, it is the responsibility of the programmer to estimate, and always to attempt to improve, their performance.</p>
<p>Lisp is a survivor, having been in use for about a quarter of a century. Among the active programming languages only Fortran has had a longer life. Both languages have supported the programming needs of important areas of application, Fortran for scientific and engineering computation and Lisp for artificial intelligence. These two areas continue to be important, and their programmers are so devoted to these two languages that Lisp and Fortran may well continue in active use for at least another quarter-century.</p>
<p>Lisp changes. The Scheme dialect used in this text has evolved from the original Lisp and differs from the latter in several important ways, including static scoping for variable binding and permitting functions to yield functions as values. In its semantic structure Scheme is as closely akin to Algol 60 as to early Lisps. Algol 60, never to be an active language again, lives on in the genes of Scheme and Pascal. It would be difficult to find two languages that are the communicating coin of two more different cultures than those gathered around these two languages. Pascal is for building pyramids -- imposing, breathtaking, static structures built by armies pushing heavy blocks into place. Lisp is for building organisms -- imposing, breathtaking, dynamic structures built by squads fitting fluctuating myriads of simpler organisms into place. The organizing principles used are the same in both cases, except for one extraordinarily important difference: The discretionary exportable functionality entrusted to the individual Lisp programmer is more than an order of magnitude greater than that to be found within Pascal enterprises. Lisp programs inflate libraries with functions whose utility transcends the application that produced them. The list, Lisp's native data structure, is largely responsible for such growth of utility. The simple structure and natural applicability of lists are reflected in functions that are amazingly nonidiosyncratic. In Pascal the plethora of declarable data structures induces a specialization within functions that inhibits and penalizes casual cooperation. It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures. As a result the pyramid must stand unchanged for a millennium; the organism must evolve or perish.</p>
<p>To illustrate this difference, compare the treatment of material and exercises within this book with that in any first-course text using Pascal. Do not labor under the illusion that this is a text digestible at MIT only, peculiar to the breed found there. It is precisely what a serious book on programming Lisp must be, no matter who the student is or where it is used.</p>
<p>Note that this is a text about programming, unlike most Lisp books, which are used as a preparation for work in artificial intelligence. After all, the critical programming concerns of software engineering and artificial intelligence tend to coalesce as the systems under investigation become larger. This explains why there is such growing interest in Lisp outside of artificial intelligence.</p>
<p>As one would expect from its goals, artificial intelligence research generates many significant programming problems. In other programming cultures this spate of problems spawns new languages. Indeed, in any very large programming task a useful organizing principle is to control and isolate traffic within the task modules via the invention of language. These languages tend to become less primitive as one approaches the boundaries of the system where we humans interact most often. As a result, such systems contain complex language-processing functions replicated many times. Lisp has such a simple syntax and semantics that parsing can be treated as an elementary task. Thus parsing technology plays almost no role in Lisp programs, and the construction of language processors is rarely an impediment to the rate of growth and change of large Lisp systems. Finally, it is this very simplicity of syntax and semantics that is responsible for the burden and freedom borne by all Lisp programmers. No Lisp program of any size beyond a few lines can be written without being saturated with discretionary functions. Invent and fit; have fits and reinvent! We toast the Lisp programmer who pens his thoughts within nests of parentheses.</p>
<p>Alan J. Perlis</p>
<p>New Haven, Connecticut</p>
<h1><a class="header" href="#foreword-to-the-lfe-edition" id="foreword-to-the-lfe-edition">Foreword to the LFE Edition</a></h1>
<p>[Forthcoming]</p>
<h1><a class="header" href="#preface-to-the-lfe-edition" id="preface-to-the-lfe-edition">Preface to the LFE Edition</a></h1>
<blockquote>
Unbound creativity is the power and the weakness of the Force. The Art of Programming Well lies in forging a balance between endless possibilities and strict discipline.
</blockquote>
<p><em>--Cristina Videira Lopes, &quot;Jedi Masters&quot;, on the history of Lisp and programming</em></p>
<p>In the spirit of Alan Perlis' &quot;keeping fun in computing&quot; and Cristina Lopes' entreaty for creativity bounded by the practical, the preface to the LFE edition of this book will cover the following topics:</p>
<ul>
<li>A Tale of Lisp Not Often Told</li>
<li>The Origins of Erlang and LFE</li>
<li>The Place of Lisp in the 21st Century</li>
<li>Changes from the Second Edition</li>
<li>Source Code for This Book</li>
</ul>
<h2><a class="header" href="#the-hidden-origins-of-lisp" id="the-hidden-origins-of-lisp">The Hidden Origins of Lisp</a></h2>
<p>Beginnings are important. They may not fully dictate the trajectory of their antecedents, yet it does seem they do have a profound impact on the character of their effects. For the human observer, beginnings are also a source of inspiration: good beginnings lend a strength of purpose, the possibility of greater good. The story of Lisp has a good beginning -- several of them, in fact -- closely tied to the theories of numbers, mathematical logic, functions and types as well as that of computing itself.</p>
<p>At their root, the histories of programming languages spring from, on one hand, the practical considerations of engineering and developer experience, and on the other hand, the principle of computability. This, in turn, ultimately traces its beginnings to the fundamental concepts of arithmetic and mathematical logic: what are numbers and how to we define them rigorously? These questions were asked and considered -- sometimes from a fairly vague philosophical perspective --  by great minds such as Leibniz (later 1600s; drafts published posthumously), Boole (1847), Grassmann (1861), Peirce (1881), Frege (1884), and Dedekind (1888). It was the Italian mathematician Giuseppe Peano, though, who in 1889 finally identified and distilled the essence of these explorations in terms that were more precisely formulated than those of his peers or intellectual forebearers. These were subsequently elaborated by successive generations of mathematicians prior to the advent of &quot;high-level&quot; programming languages in the 1950s.</p>
<p>Histories are complicated; complete ones are impossible and readable ones are necessarily limited and lacking in details. In our particular case, there is a complex lineage of mathematics leading to Lisp. However, for the sake of clarity and due to this being a preface and not a book in its own right, the mathematical and computational history leading to Lisp has been greatly simplified below. The four dominant historical figures discussed provide distinct insights and represent corresponding themes as mathematics evolved unwittingly toward a support for computing. Due to the limitation of scope, however, it might be better to view these as archetypes of mathematical discovery rather than historical figures one might come to know when reading a full history. Of the many themes one could discern and extract from these great minds, we focus on the following:</p>
<ul>
<li>Understanding and defining the underpinnings of arithmetic and logic (&quot;What are numbers? What is counting?&quot;)</li>
<li>Attempting to formally unify all of mathematics in a consistent framework of logic (&quot;Can I express all of math in discrete logical assertions and statements?&quot;)</li>
<li>Formally defining algorithms and computability (&quot;Is there a procedure that can take any precise mathematical statement and decide whether the statement is true or false?&quot;)</li>
<li>Creating the means by which symbolic computation and artificial reasoning could be made manifest (&quot;Can we make machines solve problems that are usually considered to require intelligence?&quot;)<sup class="footnote-reference"><a href="#1">1</a></sup></li>
</ul>
<p>Each major topic above depended -- in one form or another -- upon the preceding topic, and the four famous mathematicans listed below embodied each of these themes. Small excerpts from their lives and work are shared as believed to have impacted the course of events that lead to Lisp's inception.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>An almost word-for-word quote from John McCarthy's January 1962 submission in the quarterly progress report for MIT's RLE, titled <a href="http://dspace.mit.edu/bitstream/handle/1721.1/53661/RLE_QPR_064_XXI.pdf">XXI. ARTIFICIAL INTELLIGENCE</a>, page 189 on the original hard copy. The table of contents for the original is available <a href="http://dspace.mit.edu/bitstream/handle/1721.1/53645/RLE_QPR_064_TOC.pdf">here</a>.</p>
</div>
<h3><a class="header" href="#giuseppe-peano" id="giuseppe-peano">Giuseppe Peano</a></h3>
<p><img src="fm/preface-3/../images/Giuseppe-Peano.jpg" alt="Giuseppe Peano, circa 1910" /></p>
<p><strong>Figure P.1</strong>: Giuseppe Peano, circa 1910.</p>
<p>Giuseppe Peano was born 100 years before Lisp, in August of 1858 at his family's farmhouse in the north of Italy. At a young age he was recognized as having an exceptionally quick mind and, through the favor of an uncle, obtained a good early education in Turin where he not only stayed for university, but for the entirety of his career.</p>
<p>After graduating from the University of Turin with high honors, Peano was asked to stay on, providing assistance with the teaching responsibilities of the mathematics department. Within a few years, he began tackling problems in logic and exploring the foundations of the formal philosophy of mathematics. During this time, Peano introduced the world to his now-famous axioms.<sup class="footnote-reference"><a href="#1">1</a></sup><sup>,</sup> <sup class="footnote-reference"><a href="#2">2</a></sup> In particular, the fifth axiom is considered the first definition of primitive recursive functions.<sup class="footnote-reference"><a href="#3">3</a></sup> In this same work Peano described the function of a variable with explicit recursive substituion.<sup class="footnote-reference"><a href="#4">4</a></sup> Both of these served as a great source of inspiration and insight to later generations.</p>
<p>From this point into the beginning of the 20th century, Peano was considered one of the leading figures in mathematical logic, alongside Frege and Russell. This was due to Peano's work on and advocacy for a unified formulation of mathematics cast in logic. Entitled <em>Formulario Mathematico</em>, it was first published in 1895, with multiple editions released between then and the last edition in 1908. Each subsequent edition was essentially a new work in its own right, with more finely honed formulas, presentation, and explanation wherein he shared his symbols for logic, a new mathematical syntax.</p>
<p>In 1897 at the First International Congress of Mathematicians in Zurich, Peano co-chaired the track on &quot;Arithmetic and Algebra&quot; and was invited to deliver a keynote on logic. Between that event and its successor in 1900, he published more of his work on the <em>Formulario</em>. By these and other activities, when Peano arrived in Paris for the international congresses of both mathematics and philosophy, he was at the peak of his career in general, and the height of his development of mathematical logic in particular. At this event Peano along with Burali-Forti, Padoa, Pieri, Vailati, and Vacca were said to have been &quot;supreme&quot; and to have &quot;absolutely dominated&quot; the discussions in the field of the philosophy of sciences.<sup class="footnote-reference"><a href="#5">5</a></sup></p>
<p>Bertrand Russell was present at the first of these congresses and was so completely taken with the efficacy of Peano's approach to logic that upon receiving from Peano his collected works, he returned home to study them instead of remaining in Paris for the Mathematical Congress. A few months later he wrote to Peano, attaching a manuscript detailing the assessments he had been able to make, thanks to his recent and thorough study of Peano's works. Peano responded to him the following March congratulating Russell on &quot;the facility and precision&quot; with which he managed Peano's logical symbols; Peano published Russell's paper that July. However, this was only the beginning for Russell: the baton had been firmly passed to him and the advance towards a theory of computation had taken its next step.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This was in Peano's book of 1889 &quot;Arithmetices principia, nova methodo exposita&quot; (in English, <em>The principles of arithmetic, presented by a new method</em>).</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>In addition it was in this same period of time that Peano started creating various logic and set notations that are still in use today.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>See Robert I. Soare's 1995 paper entitled &quot;Computability and Recursion&quot;, page 5.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>See the 2006 paper &quot;History of Lambda-calculus and Combinatory Logic&quot; by Felice Cardone and J. Roger Hindley, page 2.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>See page 91 of Hubert C. Kennedy's 1980 hardcover edition of &quot;Peano: Life and Works of Giuseppe Peano&quot;, Volume 4 of the &quot;Studies in the History of Modern Science.&quot;</p>
</div>
<h3><a class="header" href="#bertrand-russell" id="bertrand-russell">Bertrand Russell</a></h3>
<p><img src="fm/preface-3/../images/Bertrand-Russell.jpg" alt="Bertrand Russell, 1958" /></p>
<p><strong>Figure P.2</strong>: Bertrand Russell, 1958.</p>
<p>Bertrand Russell was born in 1872 into a family of the British aristocracy. His early life was colored with tragedy: by the time he was six years old, he had lost his mother, sister, father, and grandfather. He was a deeply pensive child naturally inclined towards philosophical topics, and by 1883 -- at the age of 11 -- he was set upon the path for the first half of his life. It was at this time that his brother was tutoring him on Euclid's geometry:</p>
<p>&quot;This was one of the great events of my life, as dazzling as first love. I had not imagined that there was anything so delicious in the world. After I had learned the fifth proposition, my brother told me that it was generally considered difficult, but I had found no difficulty whatever. This was the first time it had dawned upon me that I might have some intelligence. From that moment until Whitehead and I finished <em>Principia</em> ... mathematics was my chief interest, and my chief source of happiness.&quot;<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>Russell continues in his biography, sharing how this time also provided the initial impetus toward the <em>Principia Mathematica</em>:</p>
<p>&quot;I had been told that Euclid proved things, and was much disappointed that he started with axioms. At first I refused to accept them unless my brother could offer me some reason for doing so, but he said: 'If you don't accept them we cannot go on', and as I wished to go on, I reluctantly admitted them <em>pro tem</em>. The doubt as to the premisses of mathematics which I felt at that moment remained with me, and determined the course of my subsequent work.&quot;</p>
<p>In 1900, Russell attended the First International Conference of Philosophy where he had been invited to read a paper. In his autobiography, he describes this fateful event:</p>
<p>&quot;The Congress was a turning point in my intellectual life, because I there met Peano. I already knew him by name and had seen some of his work, but had not taken the trouble to master his notation. In discussions at the Congress I observed that he was more precise than anyone else, and that he invariably got the better of any argument upon which he embarked. As the days went by, I decided that this must be owing to his mathematical logic. I therefore got him to give me all his works, and as soon as the Congress was over I retired to Fernhurst to study quietly every word written by him and his disciples. It became clear to me that his notation afforded an instrument of logical analysis such as I had been seeking for years, and that by studying him I was acquiring a new powerful technique for the work that I had long wanted to do. By the end of August I had become completely familiar with all the work of his school. I spent September in extending his methods to the logic of relations. It seemed to me in retrospect that, through that month, every day was warm and sunny. The Whiteheads stayed with us at Fernhurst, and I explained my new ideas to him. Every evening the discussion ended with some difficulty, and every morning I found that the difficulty of the previous evening had solved itself while I slept. The time was one of intellectual intoxication. My sensations resembled those one has after climbing a mountain in a mist when, on reaching the summit, the mist suddenly clears, and the country becomes visible for forty miles in every direction. For years I had been endeavoring to analyse the fundamental notions of mathematics, such as order and cardinal numbers. Suddenly, in the space of a few weeks, I discovered what appeared to be definitive answers to the problems which had baffled me for years. And in the course of discovering these answers, I was introducing a new mathematical technique, by which regions formerly abandoned to the vaguenesses of philosophers were conquered for the precision of exact formulae. Intellectually, the month of September 1900 was the highest point of my life.&quot;<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p>Russell sent an early edition of the <em>Principia</em> to Peano after working on it for three years. A biographer of Peano noted that he &quot;immediately recognized it's value ... and wrote that the book 'marks an epoch in the field of philosophy of mathematics.'&quot; <sup class="footnote-reference"><a href="#3">3</a></sup> Over the course of remaining decade, Russell and Whitehead continued to collaborate on the <em>Principia</em>, a work that ultimately inspired Gödel's incompleteness theorems and Church's $$\lambda$$-calculus.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The 1998 reissued hardback &quot;Autobiography&quot; of Bertrand Russell, pages 30 and 31.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Ibid., page 147.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Kennedy, page 105-106.</p>
</div>
<h3><a class="header" href="#alonzo-church" id="alonzo-church">Alonzo Church</a></h3>
<p><img src="fm/preface-3/../images/Alonzo-Church.jpg" alt="Alonzo Church, 1943" /></p>
<p><strong>Figure P.3</strong>: Alonzo Church, 1943.</p>
<p>Alonzo Church was born in Washington, D.C. in 1903.<sup class="footnote-reference"><a href="#1">1</a></sup> His great-grandfather (originally from Vermont) was not only a professor of mathematics and astronomy at the University of Georgia, but later became its president.<sup class="footnote-reference"><a href="#2">2</a></sup> Church graduated from a Connecticut prep-school in 1920 and then enrolled in Princeton to study mathematics. He published his first paper as an undergraduate and then continued at Princeton, earning his Ph.D. in just three years.</p>
<p>While a graduate student, Church was hit by a trolley car and spent time in a hospital where he met Julia Kuczinski<sup class="footnote-reference"><a href="#3">3</a></sup> -- they were married a year later and remained inseparable until her death, 51 years later. Church had a reputation for being a bit quirky: he never drove a car or typed; he was extremely neat and fastidious; he walked everywhere and often hummed to himself while he did so; he loved reading science fiction magazines;<sup class="footnote-reference"><a href="#4">4</a></sup> a nightowl, he often did his best work late at night. Though he had solitary work habits, his list of Ph.D. students is impressive, including the likes of Turing, Kleene, and Rosser.</p>
<p>Perhaps one of Church's more defining characteristics was his drive: he deliberately focused on prominent problems in mathematics and attacked them with great force of will. A few of the problems he had focused on in the early 1930s were:</p>
<ol>
<li>Known paradoxes entailed by Bertrand Russell's theory of types <sup class="footnote-reference"><a href="#5">5</a></sup></li>
<li>David Hilbert's <em>Entscheidungsproblem</em>, and</li>
<li>The implications of Gödel's completeness theorem.</li>
</ol>
<p>These were some of the most compelling challenges in mathematics at that time. All of them ended up meeting at the cross-roads of the λ‑calculus.</p>
<p>Church had started working on the λ‑calculus when attempting to address the Russell Paradox <sup class="footnote-reference"><a href="#6">6</a></sup>. However, it was not that goal toward which the λ‑calculus was ultimately applied. Instead, it became useful -- essential, even -- in his efforts to define what he called &quot;calculability&quot; and what is now more commonly referred to as <em>computability</em>.<sup class="footnote-reference"><a href="#7">7</a></sup> In this the λ‑calculus was an unparalleled success, allowing Church to solve the <em>Entscheidungsproblem</em> using the concept of recursive functions.</p>
<p>Syntactically, Church's λ‑notation made a significant improvement upon that found in the <em>Principia Mathematica</em> <sup class="footnote-reference"><a href="#8">8</a></sup>. Given the <em>Principia</em> phrase $$\phi x̂$$ and the λ‑calculus equivalent, $$\lambda x \phi x$$, one benefits from the use of the latter by virtue of the fact that it unambiguously states that the variable $$x$$ is bound by the term-forming operator $$\lambda$$. This innovation was necessary for Church's work and a powerful tool that was put to use by John McCarthy when he built the first programming language which used the λ‑calculus: Lisp.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The majority of the material for this section has been adapted from the <a href="http://www.math.ucla.edu/%7Ehbe/church.pdf">Introduction</a> to the Collected Works of Alonzo Church, MIT Press (not yet published).</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This was when the University of Georgia was still called Franklin College.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>She was there in training to become a nurse.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>He would also write letters to the editors when the science fiction writers got their science wrong.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>These complications were known and discussed by Russell himself at the time of <em>Principia</em>'s publication.</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p>See <a href="http://en.wikipedia.org/wiki/Russell%27s_paradox">Russell's paradox</a>.</p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p>&quot;Computability&quot; was the term which Turing used.</p>
</div>
<div class="footnote-definition" id="8"><sup class="footnote-definition-label">8</sup>
<p>See the discussion of &quot;Propositional Functions&quot; in the section &quot;The Notation in Principia Mathematica&quot;:  http://plato.stanford.edu/entries/pm-notation/#4. Note that the section of the <em>Principia Mathematica</em> which they reference in that linked discussion on the Stanford site is at the beginning of &quot;Section B: Theory of Apparent Variables&quot; in the <em>Principia</em>.</p>
</div>
<h3><a class="header" href="#john-mccarthy" id="john-mccarthy">John McCarthy</a></h3>
<p><img src="fm/preface-3/../images/John-McCarthy.jpg" alt="John McCarthy, 1965" /></p>
<p><strong>Figure P.4</strong>: John McCarthy, 1965.</p>
<p>John McCarthy was born in 1927, in the city of Boston. Due to difficulties finding work during the Great Depression, the family moved to New York, then finally settled in Los Angeles. Having established an early aptitude and proficiency in mathematics, McCarthy skipped two years of math upon his enrollment at Caltech. The year he received his undergraduate degree, he attended the 1948 Hixon Symposium on Cerebral Mechanisms in Behavior. The speakers at the symposium represented an intersection of mathematics, computation, and psychology. They were as follows:</p>
<ul>
<li>Professor Ward C. Halstead, University of Chicago</li>
<li>Professor Heinrich Kluver, University of Chicago</li>
<li>Professor Wolfgang Kohler , Swarthmore College</li>
<li>Professor K. S. Lashley, Harvard University</li>
<li>Dr. R. Lorente de No, Rockefeller Institute for Medical Research</li>
<li>Professor Warren S. Mc Culloch, University of Illinois</li>
<li>Dr. John von Neumann, Institute for Advanced Study</li>
</ul>
<p>At the symposium John von Neumann presented his paper &quot;The General and Logical Theory of Automata&quot;,<sup class="footnote-reference"><a href="#1">1</a></sup> after which McCarthy became intrigued with the idea of developing machines that could think as people do. McCarthy remained at Caltech for one year of grad school, but then pursed the remainder of his Ph.D. at Princeton, considered by him to be the greater institution for the study of mathematics. In discussions with an enthusiastic von Neumann at Princeton, McCarthy shared his ideas about interacting finite automata -- ideas inspired by von Neumann's talk at the Hixon Symposium.</p>
<p>After completing his Ph.D. dissertation, Claude Shannon invited McCarthy and his friend Marvin Minksy to work at Bell Labs in New Jersey for the summer. McCarthy and Shannon collaborated on assembling a volume of papers entitled &quot;Automata Studies,&quot; thought ultimately a bit of a disappointment to McCarthy since so few submissions concerned the topic of his primary interest: machine intelligence. A few years later, he had the opportunity to address this by proposing a summer research project which he and the head of IBM's Information Research pitched to Shannon and Minksy. They agreed, and a year later held the first Artificial Intelligence workshop at the Dartmouth campus in New Hampshire.</p>
<p>It was here, thanks to Allen Newell and Herb Simon, that McCarthy was exposed to the idea of list processing for a &quot;logical language&quot; Newell and Simon were working on (later named IPL). McCarthy initially had high hopes for this effort but upon seeing that its implementation borrowed heavily from assembly, he gave up on it. That, in conjunction with his inability to gain any traction with the maintainers of FORTRAN for the support of recursion or conditionals, inspired him to create a language that suited his goals of exploring machine intelligence. With the seeds of Lisp sown in 1956, it was two more years before development of Lisp began. Two years later a special project was established to carry out this work under the auspices of the MIT Research Laboratory of Electronics which granted McCarthy and his team one room, one secretary, two programmers, a key punch and six grad students.<sup class="footnote-reference"><a href="#2">2</a></sup> The MIT AI project was founded and the work of creating Lisp was begun.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>A transcript of the talk is available in Volume V of John von Neumann &quot;Collected Works&quot;. The topics covered were as follows: <strong>1.</strong> Preliminary Considerations; <strong>2.</strong> Discussion of Certain Relevant Traits of Computing Machines; <strong>3.</strong> Comparisons Between Computing Machines And Living Organisms; <strong>4.</strong> The Future Logical Theory of Automata; <strong>5.</strong> Principles of Digitalization; <strong>6.</strong> Formal Neural Networks; and <strong>7.</strong> The Concept of Complication and Self-Reproduction. The talk concluded with an intensive period of question and answer, also recorded in the above-mentioned volume.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Marvin Minsky and John McCarthy founded the MIT AI Lab together when McCarthy caught the acting head of the department, Jerome Wiesner, in the hallway and asked him permission to do it. Wiesner responded with &quot;Well, what do you need?”. When McCarthy gave him the list, Wiesner added &quot;How about 6 graduate students?&quot; as the department had agreed to support six mathematics students, but had yet to find work for them. See <a href="http://www-formal.stanford.edu/leora/hayes_morgenstern_birthday_mccarthy.pdf">On John McCarthy’s 80th Birthday, in Honor of his Contributions</a>, page 3.</p>
</div>
<h3><a class="header" href="#a-recap-of-erlangs-genesis" id="a-recap-of-erlangs-genesis">A Recap of Erlang's Genesis</a></h3>
<p>Though the LFE edition of <em>Structure and Interpretation of Computer Programs</em> is a reworking of the Scheme original to LFE and while both version focus entirely upon Lisp, we would be remiss if a brief history of Erlang -- upon which LFE firmly rests -- was not covered as well. One of the most concise and informative sources of Erlang history is the paper that Joe Armstrong wrote<sup class="footnote-reference"><a href="#1">1</a></sup> for the third History of Programming Languages<sup class="footnote-reference"><a href="#2">2</a></sup> conference.</p>
<p>What evolved into Erlang started out as the simple task of &quot;solving Ericsson's software problem.&quot; <sup class="footnote-reference"><a href="#3">3</a></sup> Practically, this involved a series of initial experiments in programming simple telephony systems in a variety of languages. The results of this, namely as follows, fueled the next round of experiments:</p>
<ul>
<li>Small languages seemed better at succinctly addressing the problem space.</li>
<li>The functional programming paradigm was appreciated, if sometimes viewed as awkward.</li>
<li>Logic programming provided the most elegant solutions in the given problem space.</li>
<li>Support for concurrency was viewed as essential.</li>
</ul>
<p>Joe Armstrong's first attempts at Erlang were done in 1985 using the  Smalltalk programming language. He switched away from this after Roger Skagervall observed that the logic Joe had developed was really just thinly veiled Prolog. The development of a robust systems programming language for telephony was further refined with advice from Mike Williams, already a veteran in programming concurrent systems. He said that for a concurrent programming language to be efficient it had to keep in mind three key things that dominated its problem space: <sup class="footnote-reference"><a href="#4">4</a></sup></p>
<ul>
<li>The time needed to create a process</li>
<li>The time required to perform a context switch between two processes</li>
<li>The amount of time taken to copy a message from one process to another</li>
</ul>
<p>Furthermore, Bjarne Däcker defined the following capabilities for a language to be useful when programming telecommunications switches:</p>
<ul>
<li>To handle high-concurrency</li>
<li>To handle soft real-time</li>
<li>To support non-local, distributed computing</li>
<li>To enable hardware interaction</li>
<li>To support very large scale software systems</li>
<li>To support complex interactions</li>
<li>To provide non-stop operation (on the order of years)</li>
<li>To allow for system updates without downtime</li>
<li>To provide high-nines reliability</li>
<li>To provide fault-tolerance for both hardware and software</li>
</ul>
<p>With these guiding principles, Erlang in its Prolog form emerged over the course of 1986 and 1987. Robert Virding joined Armstrong in this effort during this time period, <sup class="footnote-reference"><a href="#5">5</a></sup> helping with such tasks as rewriting the initial prototype and improving overall concurrency performance.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>See Armstrong's paper <a href="http://webcem01.cem.itesm.mx:8005/erlang/cd/downloads/hopl_erlang.pdf">here</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="http://research.ihost.com/hopl/HOPL-III.html">HOPL III</a> was held in San Diego, early June of 2007. From the perspective of LFE, it is interesting to note that each language comprising its essence have been covered at HOPL conferences: <strong>1.</strong> HOPL I, 1978 John McCarthy presented &quot;History of Lisp&quot;; <strong>2.</strong> HOPL II, 1993 Guy L. Steele, Jr. and Richard P. Gabriel presented &quot;The Evolution of Lisp,&quot; a continuation of McCarthy's 1978 talk; <strong>3.</strong> HOPL III, 2007 Joe Armstrong presented &quot;A History of Erlang.&quot;</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Armstrong 2007, page 3.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Ibid., page 2.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>&quot;Robert Virding and Joe Armstrong - The History of the Erlang Virtual Machine&quot;, Erlang Factory 2010, London.</p>
</div>
<h3><a class="header" href="#the-inspiration-for-lfe" id="the-inspiration-for-lfe">The Inspiration for LFE</a></h3>
<p>It wasn't until 2007 that, after 20 years of contributions to Erlang, that Robert Virding decided to start experimenting with a Lisp running on the Erlang VM. <sup class="footnote-reference"><a href="#1">1</a></sup> Initially explored as a Lisp 1, Virding switched to separating the name spaces for functions and variables more like the Lisp 2 of Common Lisp, having determined that this was a better overall fit with the internals of the Erlang virtual machine. <sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p>After over 7 years of development, LFE now supports such features as:</p>
<ul>
<li>Non-hygienic macros</li>
<li>Various forms borrowed from Scheme, Maclisp, and Common Lisp</li>
<li>A REPL which allows for the definition of functions, records, and macros <sup class="footnote-reference"><a href="#3">3</a></sup></li>
<li>Immutable data</li>
<li>Pattern matching</li>
<li>Modules</li>
<li>Functional programming paradigm</li>
<li>Erlang data types</li>
<li>Light-weight language processes</li>
<li>Hot-loading of code on running systems</li>
<li>100% compatibility with Core Erlang and OTP</li>
</ul>
<p>As to its own origins, Virding shared the following as the primary motivating factors: <sup class="footnote-reference"><a href="#4">4</a></sup></p>
<ul>
<li>He was an &quot;old Lisper&quot; and was therefore quite interested in implementing a Lisp.</li>
<li>He was curious as to what a Lisp on the Erlang VM would look like and how it would run. (It had always been a goal of his to make a Lisp which was specially designed for running on the Erlang VM and able to fully interact with Erlang/OTP.)</li>
<li>He wanted to experiment with compiling a language from Core Erlang. <sup class="footnote-reference"><a href="#5">5</a></sup></li>
<li>He was looking for some interesting programming projects that were not too large to do in his spare time.</li>
<li>He likes implementing languages.</li>
<li>He also thought it would be a fun problem to solve: it was an open-ended problem with lots of interesting parts.</li>
</ul>
<p>Once again, the spirit of exploration conspired with good, clean fun to bring something new and interesting into the world while at the same time reflecting a rich and varied history. On the one hand, LFE has a Lisp heritage stretching back through the $$\lambda$$-Calculus to Peano. On the other, it is a systems programming language benefiting from Prolog vestiges such as pattern-matching and list comprehensions. Hardened through industrial use, it rests upon a VM which powers 40% of the worlds telecommunications traffic. <sup class="footnote-reference"><a href="#6">6</a></sup> This is a potentially powerful combination offering unique capabilities the distributed systems metaprogrammer.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Thread on the LFE mail list entitled <a href="https://groups.google.com/d/msg/lisp-flavoured-erlang/XA5HeLbQQDk/TUHabZCHXB0J">LFE History</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>LFE also distinguishes between functions based on arity, thus it is regularly jokingly referred to as a Lisp 2+.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>This is in stark contrast to the Erlang shell which does not allow the developer to define functions (except as anonymous ones assigned to a variable); Erlang also does not have Lisp-style macros.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>He shared this information on the LFE mail list in response to a query regarding the inspiration for LFE. See the <a href="https://groups.google.com/d/msg/lisp-flavoured-erlang/XA5HeLbQQDk/TUHabZCHXB0J">original thread</a>.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>Core Erlang had been adopted by the Erlang compiler in 2001. See Carlsson's paper from that year, &quot;An introduction to Core Erlang&quot;, page 2.</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p>This is something often quoted in Erlang marketing materials; the number is based upon the market share Ericsson has in deployed systems world-wide.</p>
</div>
<h2><a class="header" href="#the-place-of-lisp-in-the-21st-century" id="the-place-of-lisp-in-the-21st-century">The Place of Lisp in the 21st Century</a></h2>
<p>The ups-and-downs of Lisp since its inception in 1958 have been covered in various media since the late 1970s. While Lisp continues to have its supporters and detractors, one thing is abundantly clear: many of the characteristics initially touted as making Lisp unique and powerful are now shared by a vast majority of modern programming languages. By some, this is considered the greatest triumph of Lisp, a source of inspiration for much of modern computing. The inevitable question is then asked: what use is Lisp, more than 50 years after its creation, when the world of computing -- both research and industry -- are so vastly different from what they were in Lisp's early days?</p>
<p>The first answer usually given is one that requires very little thought: macros. There are numerous books written on this topic and we will not cover it further in this preface, but accept as a given that the support of Lisp-style macros in any programming language is a powerful tool. Once we get past the obvious answer, subtler ones come to the fore. For instance, the simplicity of the syntax and similarity to parenthetically grouped algebra expressions make for an easy programming introduction to students of a middle school age. This simplicity is also something offering great insights to experienced programmers. Alan Kay's famous quote of Lisp being the software equivalent of Maxwell's famous partial differential equations for classical electrodynamics<sup class="footnote-reference"><a href="#1">1</a></sup> derives its inspiration from this simplicity: one can fit the essence of the language in one's head or on a single sheet of paper.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p>The education point is important: if we cannot teach the basics of a science or a branch of mathematics -- regardless of how profound it may be -- it has ceased to become a science and should at that point be considered a superstition or cargo cult, with its practitioners engaged in a great deal of activity (or even lucrative commerce) but having no understanding of the principles which form the basis of their work. However, to be a compelling focus of study, the value of Lisp in the 21st century most hold more than simply the promise of clarity and the means by which one might create domain-specific languages. To be genuinely pertinent, it must reach beyond the past and the present to provide keys to undiscovered doors for each new generation of intrepid programmers.</p>
<p>And here the answer arrives, not as some astounding epiphany, but again in humble simplicity: Lisp's fun and its beauty rest not only in its syntactic elegance but in its power of expression. This is specifically important for the adventurer: if you want to create something new, explore some new programmatical territory, you need tools at your fingertips which will allow you to do so flexibly and quickly, with as little overhead as possible. Otherwise the moment of inspiration can be to quickly lost, the creative process swallowed in a mire too heavy with infrastructure and process. By putting the power of Lisps into the hands of each generation's aspiring programmers, we are ensuring that they have what is necessary to accomplish feats which might seem miraculous to us should we see them now -- as genuinely new ideas often appear (when appreciated). A world that sees the rise of quantum computing or the molecular programming of nano-scale machines or as yet undreamt technological capabilities, will need programmers who have the ability to iterate quickly and try out new ideas, easily able to see that which should be abandoned and that which should be taken up. This is <em>especially</em> important for the survival of free software: as long as our societies are able to produce languages, software, and systems which individuals or small groups may attain understanding and mastery over, software freedom will prevail. Systems that are so complex as to require an industry to manage them are no longer within the domain of motivated and curious individuals, but rather that of organizations with sufficient capital to maintain the necessary infrastructure.</p>
<p>Thus, as we point our technological society towards its future with each action we take, as individuals and as a group, we have a responsibility to maintain the tools which will ensure the freedom of future generations, the basic freedom of the tool-maker, the hacker, the artist, and the poet. Lisp is not the only answer to this particular need, but it has shown its strengths in this regard over the past 50 years, and if the last 10 years of re-discovery and innovation in the world of programming is any indication, Lisp is alive and well and will likely be with us for a long time to come.</p>
<p>And there will be even more fun to be had by all.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>See the ACM-hosted <a href="http://queue.acm.org/detail.cfm?id=1039523">interview with Alan Kay</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Or, as the case may be, the lower $$\frac{2}{3}$$rds of a single page.</p>
</div>
<h2><a class="header" href="#notes-on-changes-from-the-original" id="notes-on-changes-from-the-original">Notes on Changes from the Original</a></h2>
<p>The original text of <em>Structure and Interpretation of Computer Programs</em> was
published in the 80s, but has material in it preceding even that time, dating back to courses taught at MIT in the 60s. Though the <em>essence</em> of what was taught in those lecture halls -- and with the original SICP text -- remains just as relevant today, much context has changed in the field of computing since then. As such, some changes in a new edition are to be expected.</p>
<p>Furthermore, this edition of SICP is an adaptation for a different programming
language -- though still a Lisp -- whose syntax differs in varying degrees. More than syntax, though, LFE is built upon a very different VM, one whose focus is on such concerns as fault-tolerance, massive scale, and reliability.</p>
<p>As such, we have taken liberties in our edition of SICP, hopefully with little
to no impact on its essence. These liberties include the following:</p>
<ul>
<li>The Lisp-2 syntax of LFE is used instead of the Lisp-1 syntax of a Scheme.</li>
<li>As an extension of that first point, features such as pattern matching in function heads, guards, multi-arity functions, etc., are used extensively, often leading to more concise functions that their original, Scheme counterparts.</li>
<li>When pertinent, features from LFE and Erlang are introduced in conjunction
with the subject matter of the original text.</li>
<li>Very rarely some of the original text or footnotes might be omitted when not at all applicable
to LFE.</li>
<li>LFE doesn't support nested <code>defun</code>s like Scheme supports nested <code>define</code>s; <code>flet</code> and <code>flectrec</code> are used instead. However, as a result, these are introduced before <code>let</code>. This is awkward, but not disastrous.</li>
<li>The LFE Edition uses LaTeX, and as such, equations are much easier to read.</li>
<li>Updating examples to modern, accepted forms (e.g., the Ackermann function).</li>
<li>Exercises are broken out into their own sections (while preserving their original order and placement in the chapters).</li>
</ul>
<p>Some of the terminology in the text has also been changed to maintain
consistency with that used by the Erlang and LFE community. Most prominently,
readers of the original text will notice that we do not use the term
&quot;procedure&quot; but have instead opted for the more common term &quot;function.&quot;</p>
<h2><a class="header" href="#obtaining-the-book-and-related-code" id="obtaining-the-book-and-related-code">Obtaining the Book and Related Code</a></h2>
<p>The source code for the LFE edition of this book uses the same license as the original: <a href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-Noncommercial 3.0 Unported License</a>.</p>
<h3><a class="header" href="#book-source" id="book-source">Book Source</a></h3>
<p>There are two related sources available for this book:</p>
<ul>
<li>The original text for the second edition is available on the <a href="http://mitpress.mit.edu/sicp/">MIT Press site</a>.</li>
<li>The source code for the LFE edition (mostly Markdown) is available on <a href="https://github.com/lfe/sicp">Github</a>.</li>
</ul>
<p>You may obtain a copy of the source code via <code>git</code>:</p>
<pre><code class="language-bash">$ git clone https://github.com/lfe/sicp.git
</code></pre>
<p>or direct download: <a href="https://github.com/lfe/sicp/archive/master.zip">https://github.com/lfe/sicp/archive/master.zip</a>.</p>
<h3><a class="header" href="#code-used-in-the-book" id="code-used-in-the-book">Code Used in the Book</a></h3>
<p>Each chapter of this book defines functions and uses code from the previous chapters. The interactive LFE REPL sessions are saved as files in the book repository. They are available in each chapter directory as <code>code.lfe</code>.</p>
<h3><a class="header" href="#running-the-code-in-the-book" id="running-the-code-in-the-book">Running the Code in the Book</a></h3>
<p>To follow along in each chapter or to run the code that has been provided, you will need the following:</p>
<ul>
<li>A recent version of Erlang (the code in this book was tested with Erlang 17.4)</li>
<li>LFE</li>
</ul>
<p>The download and installation of Erlang is not covered in this book; information for that is available from many other sources with the kind help of your favourite Internet search engine.</p>
<h4><a class="header" href="#getting-and-compiling-lfe" id="getting-and-compiling-lfe">Getting and Compiling LFE</a></h4>
<p>You may obtain LFE via <code>git</code>, creating a subdirectory in the <code>sicp</code> directory:</p>
<pre><code class="language-bash">cd sicp
git clone https://github.com/rvirding/lfe.git
</code></pre>
<p>or direct download: <a href="https://github.com/rvirding/lfe/archive/develop.zip">https://github.com/rvirding/lfe/archive/develop.zip</a>. If you use the direct download method, move and rename the unzipped directory to match the <code>git clone</code> method:</p>
<pre><code class="language-bash">cd sicp
unzip ~/Downloads/lfe-develop.zip
mv lfe-develop ./lfe
</code></pre>
<p>Now you can compile LFE, start the REPL, and load some code (you can safely ignore compiler warnings):</p>
<pre><code class="language-bash">cd lfe
make
cd ../
./lfe/bin/lfe
</code></pre>
<h4><a class="header" href="#loading-the-chapter-code" id="loading-the-chapter-code">Loading the Chapter Code</a></h4>
<pre><code class="language-lisp">Erlang/OTP 17 [erts-6.3] [source] [64-bit] [smp:4:4] ...

LFE Shell V6.3 (abort with ^G)
&gt; (run &quot;ch1/code.lfe&quot;)
Loading Chapter 1 code ...
Chapter 1 loaded.
ok
</code></pre>
<p>Quick check to make sure that everything loaded as expected:</p>
<pre><code class="language-lisp">&gt; (square 2)
4
</code></pre>
<h1><a class="header" href="#preface-to-the-second-edition" id="preface-to-the-second-edition">Preface to the Second Edition</a></h1>
<blockquote>
Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to always see it as a soap bubble?
</blockquote>
<p><em>-- Alan J. Perlis</em></p>
<p>The material in this book has been the basis of MIT's entry-level computer science subject since 1980. We had been teaching this material for four years when the first edition was published, and twelve more years have elapsed until the appearance of this second edition. We are pleased that our work has been widely adopted and incorporated into other texts. We have seen our students take the ideas and programs in this book and build them in as the core of new computer systems and languages. In literal realization of an ancient Talmudic pun, our students have become our builders. We are lucky to have such capable students and such accomplished builders.</p>
<p>In preparing this edition, we have incorporated hundreds of clarifications suggested by our own teaching experience and the comments of colleagues at MIT and elsewhere. We have redesigned most of the major programming systems in the book, including the generic-arithmetic system, the interpreters, the register-machine simulator, and the compiler; and we have rewritten all the program examples to ensure that any Scheme implementation conforming to the IEEE Scheme standard (IEEE 1990) will be able to run the code.</p>
<p>This edition emphasizes several new themes. The most important of these is the central role played by different approaches to dealing with time in computational models: objects with state, concurrent programming, functional programming, lazy evaluation, and nondeterministic programming. We have included new sections on concurrency and nondeterminism, and we have tried to integrate this theme throughout the book.</p>
<p>The first edition of the book closely followed the syllabus of our MIT one-semester subject. With all the new material in the second edition, it will not be possible to cover everything in a single semester, so the instructor will have to pick and choose. In our own teaching, we sometimes skip the section on logic programming (section <a href="fm/">13.4, Logic Programming</a>), we have students use the register-machine simulator but we do not cover its implementation (section <a href="fm/">14.2, A Register-Machine Simulator</a>), and we give only a cursory overview of the compiler (section <a href="fm/">14.5, Compilation</a>). Even so, this is still an intense course. Some instructors may wish to cover only the first three or four chapters, leaving the other material for subsequent courses.</p>
<p>The World-Wide-Web site <a href="fm/www-mitpress.mit.edu/sicp">http://www-mitpress.mit.edu/sicp</a> provides support for users of this book. This includes programs from the book, sample programming assignments, supplementary materials, and downloadable implementations of the Scheme dialect of Lisp.</p>
<h1><a class="header" href="#preface-to-the-first-edition" id="preface-to-the-first-edition">Preface to the First Edition</a></h1>
<blockquote>
"A computer is like a violin. You can imagine a novice trying first a phonograph and then a violin. The latter, he says, sounds terrible. That is the argument we have heard from our humanists and most of our computer scientists. Computer programs are good, they say, for particular purposes, but they aren't flexible. Neither is a violin, or a typewriter, until you learn how to use it."
</blockquote>
<p><em>-- Marvin Minsky, &quot;Why Programming Is a Good Medium for Expressing Poorly-Understood and Sloppily-Formulated Ideas&quot;</em></p>
<p>&quot;The Structure and Interpretation of Computer Programs&quot; is the entry-level subject in computer science at the Massachusetts Institute of Technology. It is required of all students at MIT who major in electrical engineering or in computer science, as one-fourth of the &quot;common core curriculum,&quot; which also includes two subjects on circuits and linear systems and a subject on the design of digital systems. We have been involved in the development of this subject since 1978, and we have taught this material in its present form since the fall of 1980 to between 600 and 700 students each year. Most of these students have had little or no prior formal training in computation, although many have played with computers a bit and a few have had extensive programming or hardware-design experience.</p>
<p>Our design of this introductory computer-science subject reflects two major concerns. First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute. Second, we believe that the essential material to be addressed by a subject at this level is not the syntax of particular programming-language constructs, nor clever algorithms for computing particular functions efficiently, nor even the mathematical analysis of algorithms and the foundations of computing, but rather the techniques used to control the intellectual complexity of large software systems.</p>
<p>Our goal is that students who complete this subject should have a good feel for the elements of style and the aesthetics of programming. They should have command of the major techniques for controlling complexity in a large system. They should be capable of reading a 50-page-long program, if it is written in an exemplary style. They should know what not to read, and what they need not understand at any moment. They should feel secure about modifying a program, retaining the spirit and style of the original author.</p>
<p>These skills are by no means unique to computer programming. The techniques we teach and draw upon are common to all of engineering design. We control complexity by building abstractions that hide details when appropriate. We control complexity by establishing conventional interfaces that enable us to construct systems by combining standard, well-understood pieces in a ``mix and match'' way. We control complexity by establishing new languages for describing a design, each of which emphasizes particular aspects of the design and deemphasizes others.</p>
<p>Underlying our approach to this subject is our conviction that &quot;computer science&quot; is not a science and that its significance has little to do with computers. The computer revolution is a revolution in the way we think and in the way we express what we think. The essence of this change is the emergence of what might best be called procedural epistemology -- the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects. Mathematics provides a framework for dealing precisely with notions of &quot;what is.&quot; Computation provides a framework for dealing precisely with notions of &quot;how to.&quot;</p>
<p>In teaching our material we use a dialect of the programming language Lisp. We never formally teach the language, because we don't have to. We just use it, and students pick it up in a few days. This is one great advantage of Lisp-like languages: They have very few ways of forming compound expressions, and almost no syntactic structure. All of the formal properties can be covered in an hour, like the rules of chess. After a short time we forget about syntactic details of the language (because there are none) and get on with the real issues -- figuring out what we want to compute, how we will decompose problems into manageable parts, and how we will work on the parts. Another advantage of Lisp is that it supports (but does not enforce) more of the large-scale strategies for modular decomposition of programs than any other language we know. We can make procedural and data abstractions, we can use higher-order functions to capture common patterns of usage, we can model local state using assignment and data mutation, we can link parts of a program with streams and delayed evaluation, and we can easily implement embedded languages. All of this is embedded in an interactive environment with excellent support for incremental program design, construction, testing, and debugging. We thank all the generations of Lisp wizards, starting with John McCarthy, who have fashioned a fine tool of unprecedented power and elegance.</p>
<p>Scheme, the dialect of Lisp that we use, is an attempt to bring together the power and elegance of Lisp and Algol. From Lisp we take the metalinguistic power that derives from the simple syntax, the uniform representation of programs as data objects, and the garbage-collected heap-allocated data. From Algol we take lexical scoping and block structure, which are gifts from the pioneers of programming-language design who were on the Algol committee. We wish to cite John Reynolds and Peter Landin for their insights into the relationship of Church's lambda calculus to the structure of programming languages. We also recognize our debt to the mathematicians who scouted out this territory decades before computers appeared on the scene. These pioneers include Alonzo Church, Barkley Rosser, Stephen Kleene, and Haskell Curry.</p>
<h1><a class="header" href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p>We would like to thank the many people who have helped us develop this book and this curriculum.</p>
<p>Our subject is a clear intellectual descendant of &quot;6.231,&quot; a wonderful subject on programming linguistics and the lambda calculus taught at MIT in the late 1960s by Jack Wozencraft and Arthur Evans, Jr.</p>
<p>We owe a great debt to Robert Fano, who reorganized MIT's introductory curriculum in electrical engineering and computer science to emphasize the principles of engineering design. He led us in starting out on this enterprise and wrote the first set of subject notes from which this book evolved.</p>
<p>Much of the style and aesthetics of programming that we try to teach were developed in conjunction with Guy Lewis Steele Jr., who collaborated with Gerald Jay Sussman in the initial development of the Scheme language. In addition, David Turner, Peter Henderson, Dan Friedman, David Wise, and Will Clinger have taught us many of the techniques of the functional programming community that appear in this book.</p>
<p>Joel Moses taught us about structuring large systems. His experience with the Macsyma system for symbolic computation provided the insight that one should avoid complexities of control and concentrate on organizing the data to reflect the real structure of the world being modeled.</p>
<p>Marvin Minsky and Seymour Papert formed many of our attitudes about programming and its place in our intellectual lives. To them we owe the understanding that computation provides a means of expression for exploring ideas that would otherwise be too complex to deal with precisely. They emphasize that a student's ability to write and modify programs provides a powerful medium in which exploring becomes a natural activity.</p>
<p>We also strongly agree with Alan Perlis that programming is lots of fun and we had better be careful to support the joy of programming. Part of this joy derives from observing great masters at work. We are fortunate to have been apprentice programmers at the feet of Bill Gosper and Richard Greenblatt.</p>
<p>It is difficult to identify all the people who have contributed to the development of our curriculum. We thank all the lecturers, recitation instructors, and tutors who have worked with us over the past fifteen years and put in many extra hours on our subject, especially Bill Siebert, Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn Stein, and Peter Szolovits. We would like to specially acknowledge the outstanding teaching contributions of Franklyn Turbak, now at Wellesley; his work in undergraduate instruction set a standard that we can all aspire to. We are grateful to Jerry Saltzer and Jim Miller for helping us grapple with the mysteries of concurrency, and to Peter Szolovits and David McAllester for their contributions to the exposition of nondeterministic evaluation in chapter 4.</p>
<p>Many people have put in significant effort presenting this material at other universities. Some of the people we have worked closely with are Jacob Katzenelson at the Technion, Hardy Mayer at the University of California at Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue, and Jan Komorowski at the Norwegian University of Science and Technology. We are exceptionally proud of our colleagues who have received major teaching awards for their adaptations of this subject at other universities, including Kenneth Yip at Yale, Brian Harvey at the University of California at Berkeley, and Dan Huttenlocher at Cornell.</p>
<p>Al Moyé arranged for us to teach this material to engineers at Hewlett-Packard, and for the production of videotapes of these lectures. We would like to thank the talented instructors -- in particular Jim Miller, Bill Siebert, and Mike Eisenberg -- who have designed continuing education courses incorporating these tapes and taught them at universities and industry all over the world.</p>
<p>Many educators in other countries have put in significant work translating the first edition. Michel Briand, Pierre Chamard, and André Pic produced a French edition; Susanne Daniels-Herold produced a German edition; and Fumio Motoyoshi produced a Japanese edition. We do not know who produced the Chinese edition, but we consider it an honor to have been selected as the subject of an ``unauthorized'' translation.</p>
<p>It is hard to enumerate all the people who have made technical contributions to the development of the Scheme systems we use for instructional purposes. In addition to Guy Steele, principal wizards have included Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas, and Stephen Adams. Others who have put in significant time are Richard Stallman, Alan Bawden, Kent Pitman, Jon Taft, Neil Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd Cass, Patrick O'Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair, Anthony Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth Shyu.</p>
<p>Beyond the MIT implementation, we would like to thank the many people who worked on the IEEE Scheme standard, including William Clinger and Jonathan Rees, who edited the R4RS, and Chris Haynes, David Bartley, Chris Hanson, and Jim Miller, who prepared the IEEE standard.</p>
<p>Dan Friedman has been a long-time leader of the Scheme community. The community's broader work goes beyond issues of language design to encompass significant educational innovations, such as the high-school curriculum based on EdScheme by Schemer's Inc., and the wonderful books by Mike Eisenberg and by Brian Harvey and Matthew Wright.</p>
<p>We appreciate the work of those who contributed to making this a real book, especially Terry Ehling, Larry Cohen, and Paul Bethge at the MIT Press. Ella Mazel found the wonderful cover image. For the second edition we are particularly grateful to Bernard and Ella Mazel for help with the book design, and to David Jones, TEX wizard extraordinaire. We also are indebted to those readers who made penetrating comments on the new draft: Jacob Katzenelson, Hardy Mayer, Jim Miller, and especially Brian Harvey, who did unto this book as Julie did unto his book Simply Scheme.</p>
<p>Finally, we would like to acknowledge the support of the organizations that have encouraged this work over the years, including support from Hewlett-Packard, made possible by Ira Goldstein and Joel Birnbaum, and support from DARPA, made possible by Bob Kahn. </p>
<p><strong>Chapter 1</strong></p>
<h1><a class="header" href="#building-abstractions-with-functions" id="building-abstractions-with-functions">Building Abstractions with Functions</a></h1>
<blockquote>
The acts of the mind, wherein it exerts its power over simple ideas, are chiefly these three: 1. Combining several simple ideas into one compound one, and thus all complex ideas are made. 2. The second is bringing two ideas, whether simple or complex, together, and setting them by one another so as to take a view of them at once, without uniting them into one, by which it gets all its ideas of relations. 3. The third is separating them from all other ideas that accompany them in their real existence: this is called abstraction, and thus all its general ideas are made.
</blockquote>
<p><em>-- John Locke, An Essay Concerning Human Understanding (1690)</em></p>
<p>We are about to study the idea of a computational process. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program. People create programs to direct processes. In effect, we conjure the spirits of the computer with our spells.</p>
<p>A computational process is indeed much like a sorcerer's idea of a spirit. It cannot be seen or touched. It is not composed of matter at all. However, it is very real. It can perform intellectual work. It can answer questions. It can affect the world by disbursing money at a bank or by controlling a robot arm in a factory. The programs we use to conjure processes are like a sorcerer's spells. They are carefully composed from symbolic expressions in arcane and esoteric programming languages that prescribe the tasks we want our processes to perform.</p>
<p>A computational process, in a correctly working computer, executes programs precisely and accurately. Thus, like the sorcerer's apprentice, novice programmers must learn to understand and to anticipate the consequences of their conjuring. Even small errors (usually called bugs or glitches) in programs can have complex and unanticipated consequences.</p>
<p>Fortunately, learning to program is considerably less dangerous than learning sorcery, because the spirits we deal with are conveniently contained in a secure way. Real-world programming, however, requires care, expertise, and wisdom. A small bug in a computer-aided design program, for example, can lead to the catastrophic collapse of an airplane or a dam or the self-destruction of an industrial robot.</p>
<p>Master software engineers have the ability to organize programs so that they can be reasonably sure that the resulting processes will perform the tasks intended. They can visualize the behavior of their systems in advance. They know how to structure programs so that unanticipated problems do not lead to catastrophic consequences, and when problems do arise, they can debug their programs. Well-designed computational systems, like well-designed automobiles or nuclear reactors, are designed in a modular manner, so that the parts can be constructed, replaced, and debugged separately.</p>
<h2><a class="header" href="#programming-in-lisp" id="programming-in-lisp">Programming in Lisp</a></h2>
<p>We need an appropriate language for describing processes, and we will use for this purpose the programming language Lisp. Just as our everyday thoughts are usually expressed in our natural language (such as English, French, or Japanese), and descriptions of quantitative phenomena are expressed with mathematical notations, our procedural thoughts will be expressed in Lisp. Lisp was invented in the late 1950s as a formalism for reasoning about the use of certain kinds of logical expressions, called recursion equations, as a model for computation. The language was conceived by John McCarthy and is based on his paper &quot;<a href="http://www-formal.stanford.edu/jmc/recursive.pdf">Recursive Functions of Symbolic Expressions and Their Computation by Machine</a>&quot; (McCarthy 1960).</p>
<p>Despite its inception as a mathematical formalism, Lisp is a practical programming language. A Lisp interpreter is a machine that carries out processes described in the Lisp language. The first Lisp interpreter was implemented by McCarthy with the help of colleagues and students in the Artificial Intelligence Group of the MIT Research Laboratory of Electronics and in the MIT Computation Center.<sup class="footnote-reference"><a href="#1">1</a></sup> Lisp, whose name is an acronym for LISt Processing, was designed to provide symbol-manipulating capabilities for attacking programming problems such as the symbolic differentiation and integration of algebraic expressions. It included for this purpose new data objects known as atoms and lists, which most strikingly set it apart from all other languages of the period.</p>
<p>Lisp was not the product of a concerted design effort. Instead, it evolved informally in an experimental manner in response to users' needs and to pragmatic implementation considerations. Lisp's informal evolution has continued through the years, and the community of Lisp users has traditionally resisted attempts to promulgate any &quot;official&quot; definition of the language. This evolution, together with the flexibility and elegance of the initial conception, has enabled Lisp, which is the second oldest language in widespread use today (only Fortran is older), to continually adapt to encompass the most modern ideas about program design. Thus, Lisp is by now a family of dialects, which, while sharing most of the original features, may differ from one another in significant ways. The dialect of Lisp used in the first two editions of this book was Scheme.<sup class="footnote-reference"><a href="#2">2</a></sup> The dialect used in this edition of the book is Lisp Flavored Erlang.<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<p>Because of its experimental character and its emphasis on symbol manipulation, Lisp was at first very inefficient for numerical computations, at least in comparison with Fortran. Over the years, however, Lisp compilers have been developed that translate programs into machine code that can perform numerical computations reasonably efficiently. And for special applications, Lisp has been used with great effectiveness.<sup class="footnote-reference"><a href="#4">4</a></sup> Although Lisp has not yet overcome its old reputation as hopelessly inefficient, Lisp is now used in many applications where efficiency is not the central concern. For example, Lisp has become a language of choice for operating-system shell languages and for extension languages for editors and computer-aided design systems.</p>
<p>If Lisp is not a mainstream language, why are we using it as the framework for our discussion of programming? Because the language possesses unique features that make it an excellent medium for studying important programming constructs and data structures and for relating them to the linguistic features that support them. The most significant of these features is the fact that Lisp descriptions of processes, called functions, can themselves be represented and manipulated as Lisp data. The importance of this is that there are powerful program-design techniques that rely on the ability to blur the traditional distinction between &quot;passive&quot; data and &quot;active&quot; processes. As we shall discover, Lisp's flexibility in handling functions as data makes it one of the most convenient languages in existence for exploring these techniques. The ability to represent functions as data also makes Lisp an excellent language for writing programs that must manipulate other programs as data, such as the interpreters and compilers that support computer languages. Above and beyond these considerations, programming in Lisp is great fun.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The <a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%20I%20Programmers%20Manual.pdf">Lisp 1 Programmer's Manual</a> appeared in 1960, and the <a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">Lisp 1.5 Programmer's Manual</a> (McCarthy 1965) was published in 1962. The <a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">early history of Lisp</a> is described in McCarthy 1978. </p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>The two dialects in which most major Lisp programs of the 1970s were written are <a href="https://en.wikipedia.org/wiki/Maclisp">MacLisp</a> (Moon 1978; Pitman 1983), developed at the <a href="https://en.wikipedia.org/wiki/MIT_Computer_Science_and_Artificial_Intelligence_Laboratory#Project_MAC">MIT Project MAC</a>, and <a href="https://en.wikipedia.org/wiki/Interlisp">Interlisp</a> (Teitelman 1974), developed at Bolt Beranek and Newman Inc. and the Xerox Palo Alto Research Center. <a href="https://en.wikipedia.org/wiki/Portable_Standard_Lisp">Portable Standard Lisp</a> (Hearn 1969; Griss 1981) was a Lisp dialect designed to be easily portable between different machines. MacLisp spawned a number of subdialects, such as <a href="https://en.wikipedia.org/wiki/Franz_Lisp">Franz Lisp</a>, which was developed at the University of California at Berkeley, and <a href="https://en.wikipedia.org/w/index.php?title=ZetaLisp&amp;redirect=no">Zetalisp</a> (Moon 1981), which was based on a special-purpose processor designed at the MIT Artificial Intelligence Laboratory to run Lisp very efficiently. The Lisp dialect used in the first two editions of this book, called <a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme</a> (Steele 1975), was invented in 1975 by Guy Lewis Steele Jr. and Gerald Jay Sussman of the MIT Artificial Intelligence Laboratory and later reimplemented for instructional use at MIT. Scheme became an IEEE standard in 1990 (IEEE 1990). The <a href="https://en.wikipedia.org/wiki/Common_Lisp">Common Lisp</a> dialect (Steele 1982, Steele 1990) was developed by the Lisp community to combine features from the earlier Lisp dialects to make an industrial standard for Lisp. Common Lisp became an ANSI standard in 1994 (ANSI 1994). </p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://en.wikipedia.org/wiki/LFE_%28programming_language%29">Lisp Flavored Erlang</a>, more commonly referred to as LFE, is a Common Lisp (and Scheme) inspired variant created to run on the <a href="https://en.wikipedia.org/wiki/Erlang_%28programming_language%29">Erlang</a> BEAM (also known as the &quot;Erlang virtual machine&quot;). LFE was created by Robert Virding (second co-creator of the Erlang programming language, the first being Joe Armstrong) in late 2007 in the same spirit that Alan Perlis describes in the dedication of this book: fun. The first version was released in early 2008. It received steady development work over the course of the following four years, and then in 2012 and 2013 began to see an up-tick in community interest, contributions, and third-party libraries. By 2014, companies were starting to use it on projects and in 2015 start ups began selecting it as their platform of choice for distributed systems programming.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>One such special application was a breakthrough computation of scientific importance -- an integration of the motion of the Solar System that extended previous results by nearly two orders of magnitude, and demonstrated that the dynamics of the Solar System is chaotic. This computation was made possible by new integration algorithms, a special-purpose compiler, and a special-purpose computer all implemented with the aid of software tools written in Lisp (Abelson et al. 1992; Sussman and Wisdom 1992). </p>
</div>
<h2><a class="header" href="#the-elements-of-programming" id="the-elements-of-programming">The Elements of Programming</a></h2>
<p>A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three mechanisms for accomplishing this:</p>
<ul>
<li>
<p>primitive expressions, which represent the simplest entities the language is concerned with,</p>
</li>
<li>
<p>means of combination, by which compound elements are built from simpler ones, and</p>
</li>
<li>
<p>means of abstraction, by which compound elements can be named and manipulated as units.</p>
</li>
</ul>
<p>In programming, we deal with two kinds of elements: functions and data. (Later we will discover that they are really not so distinct.) Informally, data is &quot;stuff&quot; that we want to manipulate, and functions are descriptions of the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions and should have methods for combining and abstracting functions and data.</p>
<p>In this chapter we will deal only with simple numerical data so that we can focus on the rules for building functions.<sup class="footnote-reference"><a href="#1">1</a></sup> In later chapters we will see that these same rules allow us to build functions to manipulate compound data as well.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The characterization of numbers as &quot;simple data&quot; is a barefaced bluff. In fact, the treatment of numbers is one of the trickiest and most confusing aspects of any programming language. Some typical issues involved are these: Some computer systems distinguish integers, such as 2, from real numbers, such as 2.71. Is the real number 2.00 different from the integer 2? Are the arithmetic operations used for integers the same as the operations used for real numbers? Does 6 divided by 2 produce 3, or 3.0? How large a number can we represent? How many decimal places of accuracy can we represent? Is the range of integers the same as the range of real numbers? Above and beyond these questions, of course, lies a collection of issues concerning roundoff and truncation errors -- the entire science of numerical analysis. Since our focus in this book is on large-scale program design rather than on numerical techniques, we are going to ignore these problems. The numerical examples in this chapter will exhibit the usual roundoff behavior that one observes when using arithmetic operations that preserve a limited number of decimal places of accuracy in noninteger operations. </p>
</div>
<h3><a class="header" href="#expressions" id="expressions">Expressions</a></h3>
<p>One easy way to get started at programming is to examine some typical
interactions with an interpreter for the LFE dialect of Lisp. Imagine that you
are sitting at a computer terminal. You type an expression, and the interpreter
responds by displaying the result of its evaluating that expression.</p>
<p>One kind of primitive expression you might type is a number. (More precisely,
the expression that you type consists of the numerals that represent the number
in base 10.) If you present LFE with a number</p>
<pre><code class="language-lisp">&gt; 42
</code></pre>
<p>the interpreter will respond by printing<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<pre><code class="language-lisp">42
</code></pre>
<p>Expressions representing numbers may be combined with an expression
representing a primitive function (such as <code>+</code> or <code>*</code>) to form a compound
expression that represents the application of the function to those numbers.
For example:</p>
<pre><code class="language-lisp">&gt; (- 309 267)
42
&gt; (+ 1000 337)
1337
&gt; (* 5 99)
495
&gt; (/ 10 5)
2.0
&gt; (+ 2.7 10)
12.7
</code></pre>
<p>Expressions such as these, formed by delimiting a list of expressions within
parentheses in order to denote function application, are called <em>combinations</em>.
The leftmost element in the list is called the <em>operator</em>, and the other
elements are called <em>operands</em>. The value of a combination is obtained by
applying the function specified by the operator to the arguments that are the
values of the operands.</p>
<p>The convention of placing the operator to the left of the operands is known as
<em>prefix notation</em>, and it may be somewhat confusing at first<sup class="footnote-reference"><a href="#2">2</a></sup> because it
departs significantly from the customary mathematical convention. Prefix
notation has several advantages, however. One of them is that it can
accommodate functions that may take an arbitrary number of arguments, as in the
following examples:</p>
<pre><code class="language-lisp">&gt; (+ 21 35 12 7)
75

&gt; (* 25 4 12)
1200
</code></pre>
<p>No ambiguity can arise, because the operator is always the leftmost element and
the entire combination is delimited by the parentheses.</p>
<p>A second advantage of prefix notation is that it extends in a straightforward
way to allow combinations to be nested, that is, to have combinations whose
elements are themselves combinations:</p>
<pre><code class="language-lisp">&gt; (+ (* 3 5) (- 10 6))
19
</code></pre>
<p>There is no limit (in principle) to the depth of such nesting and to the
overall complexity of the expressions that the Lisp interpreter can evaluate.
It is we humans who get confused by still relatively simple expressions such as</p>
<pre><code class="language-lisp">(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
</code></pre>
<p>which the interpreter would readily evaluate to be 57. We can help ourselves by
writing such an expression in the form</p>
<pre><code class="language-lisp">(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
</code></pre>
<p>following a formatting convention known as <em>pretty-printing</em>, in which each
long combination is written so that the operands are aligned vertically. The
resulting indentations display clearly the structure of the expression.<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<p>Even with complex expressions, the interpreter always operates in the same
basic cycle: It reads an expression from the terminal, evaluates the
expression, and prints the result. This mode of operation is often expressed by
saying that the interpreter runs in a <em>read-eval-print loop</em>, or <em>REPL</em>.
Observe in particular that it is not necessary to explicitly instruct the
interpreter to print the value of the expression.<sup class="footnote-reference"><a href="#4">4</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Throughout this book, when we wish to emphasize the distinction between the input typed by the user and the response printed by the interpreter, we will present the former with the standard LFE REPL prompt, <code>&gt;</code>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Such confusion was fabulously and lovingly presented in a playful blog post by Cristina Videira Lopes, entitled <a href="http://tagide.com/blog/2014/10/jedi-masters/">Jedi Masters</a>: &quot;Master Yoda spoke in an unusual way. If he needed to add 2 to 5 and then multiply the result by 3, he would say “multiply by 3 the result of adding 2 to 5.” This made conversations with him always intriguing, as when asked for directions to the bathroom he would say things like “come back to the council room after counting two doors on the left after turning left after coming out of the bathroom after washing your hands after peeing after entering the bathroom on the 3rd door on the right after counting two doors on your right after turning right after exiting the council room.” As a consequence, all Jedi spoke like that… at least until many years later, when a rebellious Jedi called Jolee Bindo found a clever way of transforming the language of the Force into the language spoken by non-Force-sensitives, which helped a lot of people not to get lost on their way to the bathroom… while still being puzzled about whether they were actually allowed to pee, as that would irreversibly change the state of the world. Anyway, I digress.&quot;</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Lisp-enabled text-editors and IDEs (including vi and emacs) typically provide features to aid the user in formatting expressions. Two especially useful features are one that automatically indents to the proper pretty-print position whenever a new line is started and one that highlights the matching left parenthesis whenever a right parenthesis is typed.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Lisp obeys the convention that every expression has a value. This convention, together with the old reputation of Lisp as an inefficient language, is the source of the quip by Alan Perlis (paraphrasing Oscar Wilde) that &quot;Lisp programmers know the value of everything but the cost of nothing.&quot;</p>
</div>
<h3><a class="header" href="#naming-and-the-environment" id="naming-and-the-environment">Naming and the Environment</a></h3>
<p>A critical aspect of a programming language is the means it provides for using names to refer to computational objects. We say that the name identifies a <em>variable</em> whose <em>value</em> is the object.</p>
<p>In the LFE dialect of Lisp, we name things using functions (macros, really; we'll get to that later). In the REPL, we can assign values to variables using <code>set</code>:</p>
<pre><code class="language-lisp">&gt; (set size 2)
2
</code></pre>
<p>causes the interpreter to associate the value <code>2</code> with the name <code>size</code>. Once the name size has been associated with the number <code>2</code>, we can refer to the value <code>2</code> by name:</p>
<pre><code class="language-lisp">&gt; size
2
&gt; (* 5 size)
10
</code></pre>
<p>Here are further examples of the use of <code>set</code>:</p>
<pre><code class="language-lisp">&gt; (set pi 3.14159)
3.14159
&gt; (set radius 10)
10
&gt; (* pi (* radius radius))
314.159
&gt; (set circumference (* 2 pi radius))
62.8318
&gt; circumference
62.8318
</code></pre>
<p>When not in the REPL, we can use such things as the <code>(let ...)</code> form to locally assign values to variables.</p>
<p>Though one could also use <code>set</code> do define a <em>function</em> in the REPL</p>
<pre><code class="language-lisp">&gt; (set identity (lambda (x) x))
#Fun&lt;lfe_eval.12.86468545&gt;
&gt; (funcall identity 2)
2
</code></pre>
<p>it is more idiomatic to use the <code>defun</code> macro:</p>
<pre><code class="language-lisp">&gt; (defun identity (x) x)
identity
&gt; (identity 2)
2
</code></pre>
<p>And, as you can see, it's a bit easier to use.</p>
<p>The <code>defun</code> macro is a convenience macro for <code>define-function</code>. These two, and in the REPL, <code>set</code>, are examples of the sorts of basic tools of abstraction available to the LFE programmer. These allow us to use simple names to refer to the results of compound operations, such as the <code>circumference</code> computed above. In general, computational objects may have very complex structures, and it would be extremely inconvenient to have to remember and repeat their details each time we want to use them. Indeed, complex programs are constructed by building, step by step, computational objects of increasing complexity. The interpreter makes this step-by-step program construction particularly convenient because name-object associations can be created incrementally in successive interactions. This feature encourages the incremental development and testing of programs and is largely responsible for the fact that an LFE program usually consists of a large number of relatively simple functions.</p>
<p>It should be clear that the possibility of associating values with symbols and later retrieving them means that the interpreter must maintain some sort of memory that keeps track of the name-object pairs. This memory is called the <em>environment</em> (more precisely the <em>global environment</em>, since we will see later that a computation may involve a number of different environments).<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Chapter 11 will show that this notion of environment is crucial, both for understanding how the interpreter works and for implementing interpreters. </p>
</div>
<h3><a class="header" href="#evaluating-combinations" id="evaluating-combinations">Evaluating Combinations</a></h3>
<p>One of our goals in this chapter is to isolate issues about thinking procedurally. As a case in point, let us consider that, in evaluating combinations, the interpreter is itself following a function.</p>
<ul>
<li>To evaluate a combination, do the following: 
<ol>
<li>Evaluate the subexpressions of the combination.</li>
<li>Apply the function that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpressions (the operands).</li>
</ol>
</li>
</ul>
<p>Even this simple rule illustrates some important points about processes in general. First, observe that the first step dictates that in order to accomplish the evaluation process for a combination we must first perform the evaluation process on each element of the combination. Thus, the evaluation rule is recursive in nature; that is, it includes, as one of its steps, the need to invoke the rule itself.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>Notice how succinctly the idea of recursion can be used to express what, in the case of a deeply nested combination, would otherwise be viewed as a rather complicated process. For example, evaluating</p>
<pre><code class="language-lisp">(* (+ 2 (* 4 6))
   (+ 3 5 7))
</code></pre>
<p>requires that the evaluation rule be applied to four different combinations. We can obtain a picture of this process by representing the combination in the form of a tree, as shown in <a href="ch1/evaluating-combinations.html#figure-1">figure 1.1</a>. Each combination is represented by a node with branches corresponding to the operator and the operands of the combination stemming from it. The terminal nodes (that is, nodes with no branches stemming from them) represent either operators or numbers. Viewing evaluation in terms of the tree, we can imagine that the values of the operands percolate upward, starting from the terminal nodes and then combining at higher and higher levels. In general, we shall see that recursion is a very powerful technique for dealing with hierarchical, treelike objects. In fact, the &quot;percolate values upward&quot; form of the evaluation rule is an example of a general kind of process known as <em>tree accumulation</em>.</p>
<p><a name="figure-1"></a>
<img src="ch1/images/ch1-Z-G-1.png" alt="Tree representation" /></p>
<p><strong>Figure 1.1</strong>:  Tree representation, showing the value of each subcombination.</p>
<p>Next, observe that the repeated application of the first step brings us to the point where we need to evaluate, not combinations, but primitive expressions such as numerals, built-in operators, or other names. We take care of the primitive cases by stipulating that</p>
<ul>
<li>the values of numerals are the numbers that they name,</li>
<li>the values of built-in operators are the machine instruction sequences that carry out the corresponding operations, and</li>
<li>the values of other names are the objects associated with those names in the environment. </li>
</ul>
<p>We may regard the second rule as a special case of the third one by stipulating that symbols such as <code>+</code> and <code>*</code> are also included in the global environment, and are associated with the sequences of machine instructions that are their &quot;values.&quot; The key point to notice is the role of the environment in determining the meaning of the symbols in expressions. In an interactive language such as Lisp, it is meaningless to speak of the value of an expression such as <code>(+ x 1)</code> without specifying any information about the environment that would provide a meaning for the symbol <code>x</code> (or even for the symbol <code>+</code>). As we shall see in chapter 11, the general notion of the environment as providing a context in which evaluation takes place will play an important role in our understanding of program execution.</p>
<p>Notice that the evaluation rule given above does not handle definitions. For instance, evaluating <code>(set x 3)</code> does not apply <code>set</code> to two arguments, one of which is the value of the symbol <code>x</code> and the other of which is <code>3</code>, since the purpose of the <code>set</code> is precisely to associate <code>x</code> with a value. (That is, <code>(set x 3)</code> is not a combination.)</p>
<p>Such exceptions to the general evaluation rule are called <code>special forms</code>. <code>set</code>, <code>defun</code>, and <code>define-function</code> are the only examples of a special form that we have seen so far, but we will meet others shortly. Each special form has its own evaluation rule. The various kinds of expressions (each with its associated evaluation rule) constitute the syntax of the programming language. In comparison with most other programming languages, Lisp has a very simple syntax; that is, the evaluation rule for expressions can be described by a simple general rule together with specialized rules for a small number of special forms.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>It may seem strange that the evaluation rule says, as part of the first step, that we should evaluate the leftmost element of a combination, since at this point that can only be an operator such as <code>+</code> or <code>*</code> representing a built-in primitive function such as addition or multiplication. We will see later that it is useful to be able to work with combinations whose operators are themselves compound expressions. </p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Special syntactic forms that are simply convenient alternative surface structures for things that can be written in more uniform ways are sometimes called <code>syntactic sugar</code>, to use a phrase coined by Peter Landin. In comparison with users of other languages, Lisp programmers, as a rule, are less concerned with matters of syntax. (By contrast, examine any Pascal manual and notice how much of it is devoted to descriptions of syntax.) This disdain for syntax is due partly to the flexibility of Lisp, which makes it easy to change surface syntax, and partly to the observation that many &quot;convenient&quot; syntactic constructs, which make the language less uniform, end up causing more trouble than they are worth when programs become large and complex. In the words of Alan Perlis, &quot;Syntactic sugar causes cancer of the semicolon.&quot;</p>
</div>
<h3><a class="header" href="#compound-functions" id="compound-functions">Compound Functions</a></h3>
<p>We have identified in Lisp some of the elements that must appear in any powerful programming language:</p>
<ul>
<li>Numbers and arithmetic operations are primitive data and functions.</li>
<li>Nesting of combinations provides a means of combining operations.</li>
<li>Definitions that associate names with values provide a limited means of abstraction.</li>
</ul>
<p>Now we will learn about <em>function definitions</em>, a much more powerful abstraction technique by which a compound operation can be given a name and then referred to as a unit.</p>
<p>We begin by examining how to express the idea of &quot;squaring.&quot; We might say, &quot;To square something, multiply it by itself.&quot; This is expressed in our language as</p>
<pre><code class="language-lisp">(defun square (x) (* x x))
</code></pre>
<p>We can understand this in the following way:</p>
<pre><code class="language-lisp">(defun   square (x)        (*       x      x))
  ^        ^     ^          ^       ^      ^
  |        |     |          |       |      |
 To      square something, multiply it by itself.
</code></pre>
<p>We have here a <em>compound function</em>, which has been given the name <code>square</code>. The function represents the operation of multiplying something by itself. The thing to be multiplied is given a local name, <code>x</code>, which plays the same role that a pronoun plays in natural language. Evaluating the definition creates this compound function and associates it with the name <code>square</code>.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>The general form of a function definition is</p>
<pre><code class="language-lisp">(defun &lt;name&gt; (&lt;formal parameters&gt;) &lt;body&gt;)
</code></pre>
<p>The <code>&lt;name&gt;</code> is a symbol to be associated with the function definition in the environment.<sup class="footnote-reference"><a href="#2">2</a></sup> The <code>&lt;formal parameters&gt;</code> are the names used within the body of the function to refer to the corresponding arguments of the function. The <code>&lt;body&gt;</code> is an expression that will yield the value of the function application when the formal parameters are replaced by the actual arguments to which the function is applied.<sup class="footnote-reference"><a href="#3">3</a></sup> The <code>&lt;name&gt;</code> and the<code> &lt;formal parameters&gt;</code> are grouped within parentheses, just as they would be in an actual call to the function being defined.</p>
<p>Having defined square, we can now use it:</p>
<pre><code class="language-lisp">&gt; (square 21)
441
&gt; (square (+ 2 5))
49
&gt; (square (square 3))
81
</code></pre>
<p>We can also use square as a building block in defining other functions. For example, $$x^2$$ + $$y^2$$ can be expressed as</p>
<pre><code class="language-lisp">(+ (square x) (square y))
</code></pre>
<p>We can easily define a function <code>sum-of-squares</code> that, given any two numbers as arguments, produces the sum of their squares:</p>
<pre><code class="language-lisp">&gt; (defun sum-of-squares (x y)
   (+ (square x) (square y)))
sum-of-squares
&gt; (sum-of-squares 3 4)
25
</code></pre>
<p>Now we can use <code>sum-of-squares</code> as a building block in constructing further functions:</p>
<pre><code class="language-lisp">&gt; (defun f (a)
    (sum-of-squares (+ a 1) (* a 2)))
f
&gt; (f 5)
136
</code></pre>
<p>Compound functions are used in exactly the same way as primitive functions.
Indeed, one could not tell by looking at the definition of <code>sum-of-squares</code>
given above whether <code>square</code> was built into the interpreter, like <code>+</code> and
<code>*</code>, or defined as a compound function.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Observe that there are two different operations being combined here: we are creating the function, and we are giving it the name <code>square</code>. It is possible, indeed important, to be able to separate these two notions -- to create functions without naming them, and to give names to functions that have already been created. We will see how to do this in the section <a href="ch1/">Constructing Functions Using Lambda</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Throughout this book, we will describe the general syntax of expressions by using italic symbols delimited by angle brackets -- e.g., <code>&lt;name&gt;</code> -- to denote the &quot;slots&quot; in the expression to be filled in when such an expression is actually used.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>More generally, the body of the function can be a sequence of expressions. In this case, the interpreter evaluates each expression in the sequence in turn and returns the value of the final expression as the value of the function application.</p>
</div>
<h3><a class="header" href="#the-substitution-model-for-function-application" id="the-substitution-model-for-function-application">The Substitution Model for Function Application</a></h3>
<p>To evaluate a combination whose operator names a compound function, the
interpreter follows much the same process as for combinations whose operators
name primitive functions, which we described in section
<a href="ch1/evaluating-combinations.html">Evaluating Combinations</a>. That is, the
interpreter evaluates the elements of the combination and applies the function
(which is the value of the operator of the combination) to the arguments (which
are the values of the operands of the combination).</p>
<p>We can assume that the mechanism for applying primitive functions to arguments
is built into the interpreter. For compound functions, the application process
is as follows:</p>
<ul>
<li>To apply a compound function to arguments, evaluate the body of the function
with each formal parameter replaced by the corresponding argument.</li>
</ul>
<p>To illustrate this process, let's evaluate the combination</p>
<pre><code class="language-lisp">(f 5)
</code></pre>
<p>where <code>f</code> is the function defined in section
<a href="ch1/compound-functions.html">Compound Functions</a>. We begin by retrieving the body
of <code>f</code>:</p>
<pre><code class="language-lisp">(sum-of-squares (+ a 1) (* a 2))
</code></pre>
<p>Then we replace the formal parameter <code>a</code> by the argument <code>5</code>:</p>
<pre><code class="language-lisp">(sum-of-squares (+ 5 1) (* 5 2))
</code></pre>
<p>Thus the problem reduces to the evaluation of a combination with two operands
and an operator <code>sum-of-squares</code>. Evaluating this combination involves three
subproblems. We must evaluate the operator to get the function to be applied,
and we must evaluate the operands to get the arguments. Now <code>(+ 5 1)</code>
produces 6 and <code>(* 5 2)</code> produces <code>10</code>, so we must apply the
<code>sum-of-squares</code> function to <code>6</code> and <code>10</code>. These values are substituted
for the formal parameters <code>x</code> and <code>y</code> in the body of <code>sum-of-squares</code>,
reducing the expression to</p>
<pre><code class="language-lisp">(+ (square 6) (square 10))
</code></pre>
<p>If we use the definition of <code>square</code>, this reduces to</p>
<pre><code class="language-lisp">(+ (* 6 6) (* 10 10))
</code></pre>
<p>which reduces by multiplication to</p>
<pre><code class="language-lisp">(+ 36 100)
</code></pre>
<p>and finally to</p>
<pre><code class="language-lisp">136
</code></pre>
<p>The process we have just described is called the <em>substitution</em> model for
function application. It can be taken as a model that determines the &quot;meaning&quot;
of function application, insofar as the functions in this chapter are
concerned. However, there are two points that should be stressed:</p>
<ul>
<li>The purpose of the substitution is to help us think about function
application, not to provide a description of how the interpreter really
works. Typical interpreters do not evaluate function applications by
manipulating the text of a function to substitute values for the formal
parameters. In practice, the &quot;substitution&quot; is accomplished by using a local
environment for the formal parameters. We will discuss this more fully in
chapters 11 and 12 when we examine the implementation of an interpreter in
detail.</li>
<li>Over the course of this book, we will present a sequence of increasingly
elaborate models of how interpreters work, culminating with a complete
implementation of an interpreter and compiler in chapter 13. The substitution
model is only the first of these models -- a way to get started thinking
formally about the evaluation process. In general, when modeling phenomena in
science and engineering, we begin with simplified, incomplete models. As we
examine things in greater detail, these simple models become inadequate and
must be replaced by more refined models. The substitution model is no
exception. In particular, when we address in chapter 3 the use of functions
with &quot;mutable data,&quot; we will see that the substitution model breaks down and
must be replaced by a more complicated model of function application.<sup class="footnote-reference"><a href="#1">1</a></sup></li>
</ul>
<h4><a class="header" href="#applicative-order-versus-normal-order" id="applicative-order-versus-normal-order">Applicative order versus normal order</a></h4>
<p>According to the description of evaluation given in the section
<a href="ch1/evaluating-combinations.html">Evaluating Combinations</a>, the interpreter first
evaluates the operator and operands and then applies the resulting function to
the resulting arguments. This is not the only way to perform evaluation. An
alternative evaluation model would not evaluate the operands until their values
were needed. Instead it would first substitute operand expressions for
parameters until it obtained an expression involving only primitive operators,
and would then perform the evaluation. If we used this method, the evaluation
of</p>
<pre><code class="language-lisp">(f 5)
</code></pre>
<p>would proceed according to the sequence of expansions</p>
<pre><code class="language-lisp">(sum-of-squares (+ 5 1) (* 5 2))

(+    (square (+ 5 1))      (square (* 5 2))  )

(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
</code></pre>
<p>followed by the reductions</p>
<pre><code class="language-lisp">(+         (* 6 6)             (* 10 10))

(+           36                   100)

                    136
</code></pre>
<p>This gives the same answer as our previous evaluation model, but the process is
different. In particular, the evaluations of <code>(+ 5 1)</code> and <code>(* 5 2)</code> are
each performed twice here, corresponding to the reduction of the expression</p>
<pre><code class="language-lisp">(* x x)
</code></pre>
<p>with <code>x</code> replaced respectively by <code>(+ 5 1)</code> and <code>(* 5 2)</code>.</p>
<p>This alternative &quot;fully expand and then reduce&quot; evaluation method is known as
<em>normal-order evaluation</em>, in contrast to the &quot;evaluate the arguments and then
apply&quot; method that the interpreter actually uses, which is called
<em>applicative-order evaluation</em>. It can be shown that, for function applications
that can be modeled using substitution (including all the functions in the
first two chapters of this book) and that yield legitimate values, normal-order
and applicative-order evaluation produce the same value. (See exercise 1.5 for
an instance of an &quot;illegitimate&quot; value where normal-order and applicative-order
evaluation do not give the same result.)</p>
<p>LFE uses applicative-order evaluation, partly because of the additional
efficiency obtained from avoiding multiple evaluations of expressions such as
those illustrated with <code>(+ 5 1)</code> and <code>(* 5 2)</code> above and, more
significantly, because normal-order evaluation becomes much more complicated to
deal with when we leave the realm of functions that can be modeled by
substitution. On the other hand, normal-order evaluation can be an extremely
valuable tool, and we will investigate some of its implications in chapters 11
and 12.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Despite the simplicity of the substitution idea, it turns out to be surprisingly complicated to give a rigorous mathematical definition of the substitution process. The problem arises from the possibility of confusion between the names used for the formal parameters of a function and the (possibly identical) names used in the expressions to which the function may be applied. Indeed, there is a long history of erroneous definitions of substitution in the literature of logic and programming semantics. See Stoy 1977 for a careful discussion of substitution.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>In chapter 11 we will introduce stream processing, which is a way of handling apparently &quot;infinite&quot; data structures by incorporating a limited form of normal-order evaluation. In section 12.2 we will modify the LFE interpreter to produce a normal-order variant of LFE.</p>
</div>
<h3><a class="header" href="#conditional-expressions-and-predicates" id="conditional-expressions-and-predicates">Conditional Expressions and Predicates</a></h3>
<p>The expressive power of the class of functions that we can define at this point is very limited, because we have no way to make tests and to perform different operations depending on the result of a test. For instance, we cannot define a function that computes the absolute value of a number by testing whether the number is positive, negative, or zero and taking different actions in the different cases according to the rule</p>
<p>$$
\begin{align}
\mid \ r \mid \ = \ \left{
\begin{array}{1 1}
\ \ r \quad \text{if } r &gt; 0 \
\ \ 0 \quad \text{if } r = 0 \
-r \quad \text{if } r &lt; 0
\end{array}
\right.<br />
\end{align}
$$</p>
<p>This construct is called a <em>case analysis</em>, and there are special forms in LFE for notating such case analyses:</p>
<ul>
<li><code>cond</code></li>
<li><code>if</code></li>
<li><code>case</code></li>
<li>pattern matching and guards</li>
</ul>
<p>We will now explore those.</p>
<h4><a class="header" href="#the-cond-form" id="the-cond-form">The <code>cond</code> Form</a></h4>
<p>It is called <code>cond</code> (which stands for &quot;conditional&quot;), and it is used as follows:</p>
<pre><code class="language-lisp">(defun abs (x)
  (cond ((&gt; x 0) x)
        ((== x 0) 0)
        ((&lt; x 0) (- x))))
</code></pre>
<p>In non-LFE Lisps, the general form of a conditional expression is</p>
<pre><code class="language-lisp">(cond (&lt;p1&gt; &lt;e1&gt;)
      (&lt;p2&gt; &lt;e2&gt;)
      (&lt;p3&gt; &lt;e3&gt;)
      ...
      (&lt;pn&gt; &lt;en&gt;))
</code></pre>
<p>consisting of the symbol cond followed by parenthesized pairs of expressions <code>(&lt;p&gt; &lt;e&gt;)</code> called clauses. The first expression in each pair is a predicate -- that is, an expression whose value is interpreted as either true or false.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>Thanks to that fact that Erlang underlies LFE, the LFE <code>cond</code> supports both pattern-matching and what Erlang calls &quot;<a href="http://learnyousomeerlang.com/syntax-in-functions#guards-guards">guards</a>&quot;. As such, the predicates in LFE <code>cond</code>s may take the following additional forms:</p>
<pre><code class="language-lisp">(cond (&lt;p1&gt; &lt;e1&gt;)
      ((?= &lt;pattern2&gt; &lt;p2&gt;) &lt;e2&gt;)
      ((?= &lt;pattern3&gt; &lt;guard3&gt; &lt;p3&gt;) &lt;e3&gt;)
      ...
      ((?= &lt;patternn&gt; &lt;guardn&gt; &lt;pn&gt;) &lt;en&gt;))
</code></pre>
<p>Conditional expressions are evaluated as follows. The predicate <code>&lt;p1&gt;</code> is evaluated first. If its value is false, then<code>&lt;p2&gt;</code> is evaluated. If <code>&lt;p2&gt;</code>'s value is also false, then <code>&lt;p3&gt;</code> is evaluated. This process continues until a predicate is found whose value is true, in which case the interpreter returns the value of the corresponding <em>consequent expression</em> <code>&lt;e&gt;</code> of the clause as the value of the conditional expression. If none of the <code>&lt;p&gt;</code>'s is found to be <code>true</code>, the value of the <code>cond</code> is <code>false</code>.</p>
<p>The word <em>predicate</em> is used for functions that return <code>true</code> or <code>false</code>, as well as for expressions that evaluate to <code>true</code> or <code>false</code>. The absolute-value function <code>abs</code> makes use of the primitive predicates <code>&gt;</code>, <code>&lt;</code>, and <code>==</code>.<sup class="footnote-reference"><a href="#2">2</a></sup> These take two numbers as arguments and test whether the first number is, respectively, greater than, less than, or equal to the second number, returning true or false accordingly.</p>
<p>Another way to write the absolute-value function is</p>
<pre><code class="language-lisp">(defun abs (x)
  (cond ((&lt; x 0) (- x))
        ('true x)))
</code></pre>
<p>which could be expressed in English as &quot;If <code>x</code> is less than zero return <code>-x</code>; otherwise return <code>x</code>.&quot; Since in LFE a <code>cond</code> with no <code>true</code> predicates returns <code>false</code>, if we want a final, &quot;default&quot; value, we need to provide a predicate that always evaluates to <code>true</code>. The simplest such predicate is <code>true</code>.</p>
<h4><a class="header" href="#the-if-form" id="the-if-form">The <code>if</code> Form</a></h4>
<p>Another condition form available to most Lisps and to LFE is <code>if</code>. Here is yet another way to write the absolute-value function:</p>
<pre><code class="language-lisp">(defun abs (x)
  (if (&lt; x 0)
      (- x)
      x))
</code></pre>
<p>This uses the special form <code>if</code>, a restricted type of conditional that can be used when there are precisely two cases in the case analysis. The general form of an if expression is</p>
<pre><code class="language-lisp">(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)
</code></pre>
<p>To evaluate an <code>if</code> expression, the interpreter starts by evaluating the <code>&lt;predicate&gt;</code> part of the expression. If the <code>&lt;predicate&gt;</code> evaluates to a <code>true</code> value, the interpreter then evaluates the <code>&lt;consequent&gt;</code> and returns its value. Otherwise it evaluates the <code>&lt;alternative&gt;</code> and returns its value.<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<h4><a class="header" href="#the-case-form" id="the-case-form">The <code>case</code> Form</a></h4>
<p>Through Erlang, LFE supports a form not found by default in most Lisps: <code>case</code>. <code>case</code> takes an expression and then provides conditions based on matches for that expression. Here is the general form:</p>
<pre><code class="language-lisp">(case &lt;expression&gt;
  (&lt;pattern1&gt; &lt;e1&gt;)
  (&lt;pattern2&gt; &lt;guard2&gt; &lt;e2&gt;)
  ...
  (&lt;patternn&gt; &lt;guardn&gt; &lt;en&gt;))
</code></pre>
<p>We could rewrite our absolute-value function using <code>case</code> like this:</p>
<pre><code class="language-lisp">
(defun abs (x)
  (case (&lt; x 0)
        ('true (- x))
        (_ x)))
</code></pre>
<p>When the final pattern matched against is the &quot;I-don't-care variable&quot;,<sup class="footnote-reference"><a href="#4">4</a></sup> the effect is the same as the final <code>'true</code> in the <code>cond</code> form: if all else fails to match, the expression associated with the <code>_</code> pattern is returned.</p>
<h4><a class="header" href="#function-argument-patterns" id="function-argument-patterns">Function Argument Patterns</a></h4>
<p>In our discussion of conditionals, we would be remiss in our duties if we did not bring up the topic of pattern-matching in function arguments, or in this case, patterns and guards.</p>
<p>Ordinarily in LFE you define a function as we have discussed, using the form</p>
<pre><code class="language-lisp">(defun &lt;name&gt; (&lt;arguments&gt;) &lt;body&gt;)
</code></pre>
<p>However, like Erlang, LFE supports pattern matching and guards in functions. The more general form of function definition is</p>
<pre><code class="language-lisp">(defun &lt;name&gt;
  ((&lt;argpattern1&gt;) &lt;body1&gt;)
  ((&lt;argpattern2&gt;) &lt;guard2&gt; &lt;body2&gt;)
  ...
  ((&lt;argpatternn&gt;) &lt;guardn&gt; &lt;bodyn&gt;))
</code></pre>
<p>We can rewrite our absolute-value function using a simple pattern and guards</p>
<pre><code class="language-lisp">(defun abs
  ((x) (when (&gt; x 0)) x)
  ((x) (when (== x 0)) 0)
  ((x) (when (&lt; x 0)) (- x)))
</code></pre>
<p>which of course could be consolidated to</p>
<pre><code class="language-lisp">(defun abs
  ((x) (when (&lt; x 0)) (- x))
  ((x) x))
</code></pre>
<p>Note that in both definitions above our argument pattern is simply <code>x</code>. We are not using the mechanics of pattern matching, per se, to implement our conditional logic. Rather, in this case we are taking advantage of the argument pattern's optional guard.</p>
<h4><a class="header" href="#logical-operators-as-predicates" id="logical-operators-as-predicates">Logical Operators as Predicates</a></h4>
<p>In addition to primitive predicates such as <code>&lt;</code>, <code>=</code>, and <code>&gt;</code>, there are logical composition operations, which enable us to construct compound predicates. The three most frequently used are these:</p>
<ul>
<li><code>(and &lt;e1&gt; ... &lt;en&gt;)</code> -
The interpreter evaluates the expressions <code>&lt;e&gt;</code> one at a time, in left-to-right order. If any <code>&lt;e&gt;</code> evaluates to <code>false</code>, the value of the <code>and</code> expression is <code>false</code>, and the rest of the <code>&lt;e&gt;</code>'s are not evaluated. If all <code>&lt;e&gt;</code>'s evaluate to <code>true</code> values, the value of the <code>and</code> expression is <code>true</code>.</li>
<li><code>(or &lt;e1&gt; ... &lt;en&gt;)</code> -
The interpreter evaluates the expressions <code>&lt;e&gt;</code> one at a time, in left-to-right order. If any <code>&lt;e&gt;</code> evaluates to a <code>true</code> value, the value of the <code>or</code> expression is <code>true</code>, and the rest of the <code>&lt;e&gt;</code>'s are not evaluated. If all <code>&lt;e&gt;</code>'s evaluate to <code>false</code>, the value of the <code>or</code> expression is <code>false</code>.</li>
<li><code>(not &lt;e&gt;)</code> -
The value of a <code>not</code> expression is <code>true</code> when the expression <code>&lt;e&gt;</code> evaluates to <code>false</code>, and <code>false</code> otherwise.</li>
</ul>
<p>Notice that <code>and</code> and <code>or</code> are special forms, not functions, because the subexpressions are not necessarily all evaluated. <code>not</code> is an ordinary function.</p>
<p>As an example of how these are used, the condition that a number $$x$$ be in the range $$5 &lt; x &lt; 10$$ may be expressed as</p>
<pre><code class="language-lisp">(and (&gt; x 5) (&lt; x 10))
</code></pre>
<p>As another example, we can define a predicate to test whether one number is greater than or equal to another as</p>
<pre><code class="language-lisp">(defun gte (x y)
  (or (&gt; x y) (== x y)))
</code></pre>
<p>or alternatively as</p>
<pre><code class="language-lisp">(defun gte (x y)
  (not (&lt; x y)))
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>&quot;Interpreted as either true or false&quot; means this: In LFE, there are two distinguished values that are denoted by <code>true</code> and <code>false</code>. When the interpreter checks a predicate's value, if the result cannot be interpreted as either <code>true</code> or <code>false</code>, an error is raised (for <code>cond</code> and <code>if</code> you will see an <code>if_clause</code> exception).</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><code>abs</code> also uses the &quot;minus&quot; operator <code>-</code>, which, when used with a single operand, as in <code>(- x)</code>, indicates negation.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>A minor difference between <code>if</code> and <code>cond</code> is that the <code>&lt;e&gt;</code> part of each <code>cond</code> clause may be a sequence of expressions. If the corresponding <code>&lt;p&gt;</code> is found to be <code>true</code>, the expressions <code>&lt;e&gt;</code> are evaluated in sequence and the value of the final expression in the sequence is returned as the value of the <code>cond</code>. In an <code>if</code> expression, however, the <code>&lt;consequent&gt;</code> and <code>&lt;alternative&gt;</code> must be single expressions.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>The single underscore, anonymous variable, &quot;blah&quot;, &quot;don't care&quot;, or &quot;throw-away&quot; variable has a long history in computing. Many languages, including Prolog, C, Erlang, OCaml, Python, Ruby, etc., share a tradition of treating the underscore as a special variable; special in the sense that the value is not seen as being of any pertinent interest in the given context. In Prolog and Erlang, and thus LFE, the anonymous variable has a significant functional purpose: it is never bound to a value and as such can be used multiple times in pattern matching without throwing an error (which would happen in Prolog or Erlang if you tried to match multiple patterns with a regular, bound variable).</p>
</div>
<h3><a class="header" href="#exercises" id="exercises">Exercises</a></h3>
<h4><a class="header" href="#exercise-11" id="exercise-11">Exercise 1.1</a></h4>
<p>Below is a sequence of expressions. What is the result printed by the interpreter in response to each expression? Assume that the sequence is to be evaluated in the order in which it is presented.</p>
<pre><code class="language-lisp">10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(set a 3)
(set b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a)
(cond ((== a 4) 6)
      ((== b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (&gt; b a) b a))
(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))
</code></pre>
<h4><a class="header" href="#exercise-12" id="exercise-12">Exercise 1.2</a></h4>
<p>Translate the following expression into prefix form</p>
<p>$$
\begin{align}
\frac{5+4+(2-(3-\left(6+\frac{4}{5}\right)}
{3(6-2)(2-7)}
\end{align}
$$</p>
<h4><a class="header" href="#exercise-13" id="exercise-13">Exercise 1.3</a></h4>
<p>Define a function that takes three numbers as arguments and returns the sum of
the squares of the two larger numbers.</p>
<h4><a class="header" href="#exercise-14" id="exercise-14">Exercise 1.4</a></h4>
<p>Observe that our model of evaluation allows for combinations whose operators
are compound expressions. Use this observation to describe the behavior of the
following function:</p>
<pre><code class="language-lisp">(defun a-plus-abs-b (a b)
  (funcall (if (&gt; b 0)
               #'+/2
               #'-/2)
           a b)))
</code></pre>
<h4><a class="header" href="#exercise-15" id="exercise-15">Exercise 1.5</a></h4>
<p>Ben Bitdiddle has invented a test to determine whether the interpreter he is
faced with is using applicative-order evaluation or normal-order evaluation. He
defines the following two functions:</p>
<pre><code class="language-lisp">(defun p () (p))
</code></pre>
<pre><code class="language-lisp">(defun test (x y)
  (if (== x 0)
      0
      y))
</code></pre>
<p>Then he evaluates the expression</p>
<pre><code class="language-lisp">(test 0 (p))
</code></pre>
<p>What behavior will Ben observe with an interpreter that uses applicative-order
evaluation? What behavior will he observe with an interpreter that uses
normal-order evaluation? Explain your answer. (Assume that the evaluation rule
for the special form if is the same whether the interpreter is using normal or
applicative order: The predicate expression is evaluated first, and the result
determines whether to evaluate the consequent or the alternative expression.)</p>
<h3><a class="header" href="#example-square-roots-by-newtons-method" id="example-square-roots-by-newtons-method">Example: Square Roots by Newton's Method</a></h3>
<p>Functions, as introduced above, are much like ordinary mathematical functions. They specify a value that is determined by one or more parameters. But there is an important difference between mathematical functions and computer functions. Functions must be effective.</p>
<p>As a case in point, consider the problem of computing square roots. We can define the square-root function as</p>
<p>$$
\begin{align}
\sqrt{r} = \text{the } y \text{ such that } y \geq 0 \text{ and } y^2 = x
\end{align}
$$</p>
<p>This describes a perfectly legitimate mathematical function. We could use it to recognize whether one number is the square root of another, or to derive facts about square roots in general. On the other hand, the definition does not describe a function. Indeed, it tells us almost nothing about how to actually find the square root of a given number. It will not help matters to rephrase this definition in pseudo-LFE:</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (the y (and (&gt;= y 0)
              (= (square y) x))))
</code></pre>
<p>This only begs the question.</p>
<p>The contrast between function and function is a reflection of the general distinction between describing properties of things and describing how to do things, or, as it is sometimes referred to, the distinction between declarative knowledge and imperative knowledge. In mathematics we are usually concerned with declarative (what is) descriptions, whereas in computer science we are usually concerned with imperative (how to) descriptions.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>How does one compute square roots? The most common way is to use Newton's method of successive approximations, which says that whenever we have a guess $$y$$ for the value of the square root of a number $$x$$, we can perform a simple manipulation to get a better guess (one closer to the actual square root) by averaging $$y$$ with $$x/y$$.<sup class="footnote-reference"><a href="#2">2</a></sup> For example, we can compute the square root of 2 as follows. Suppose our initial guess is 1:</p>
<table><thead><tr><th align="center">Guess</th><th align="center">Quotient</th><th align="center">Average</th></tr></thead><tbody>
<tr><td align="center">1</td><td align="center"><code>(2/1) = 2</code></td><td align="center"><code>((2 + 1)/2) = 1.5 </code></td></tr>
<tr><td align="center">1.5</td><td align="center"><code>(2/1.5) = 1.3333</code></td><td align="center"><code>((1.3333 + 1.5)/2) = 1.4167</code></td></tr>
<tr><td align="center">1.4167</td><td align="center"><code>(2/1.4167) = 1.4118</code></td><td align="center"><code>((1.4167 + 1.4118)/2) = 1.4142</code></td></tr>
<tr><td align="center">1.4142</td><td align="center">...</td><td align="center">...</td></tr>
</tbody></table>
<p>Continuing this process, we obtain better and better approximations to the square root.</p>
<p>Now let's formalize the process in terms of functions. We start with a value for the radicand (the number whose square root we are trying to compute) and a value for the guess. If the guess is good enough for our purposes, we are done; if not, we must repeat the process with an improved guess. We write this basic strategy as a function:</p>
<pre><code class="language-lisp">(defun sqrt (guess x)
  (if (good-enough? guess x)
      guess
      (sqrt (improve guess x)
            x)))
</code></pre>
<p>A guess is improved by averaging it with the quotient of the radicand and the
old guess:</p>
<pre><code class="language-lisp">(defun improve (guess x)
  (average guess (/ x guess)))
</code></pre>
<p>where</p>
<pre><code class="language-lisp">(defun average (x y)
  (/ (+ x y) 2))
</code></pre>
<p>We also have to say what we mean by &quot;good enough.&quot; The following will do for
illustration, but it is not really a very good test. (See exercise 1.7.) The
idea is to improve the answer until it is close enough so that its square
differs from the radicand by less than a predetermined tolerance (here
0.001):<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<pre><code class="language-lisp">(defun good-enough? (guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
</code></pre>
<p>Finally, we need a way to get started. For instance, we can always guess that
the square root of some $$x$$ is $$\frac{x}{2}$$:<sup class="footnote-reference"><a href="#4">4</a></sup></p>
<pre><code class="language-lisp">(defun sqrt (x)
  (sqrt (* 0.5 x) x))
</code></pre>
<p>Note that we used the same name as a previous function, the iterative function
that took two arguments. In LFE, not only do functions and variables have a
difference namespace (unlike Scheme), but functions are also differentiated by
their arity. As such, functions with different arity may share the same
name.<sup class="footnote-reference"><a href="#5">5</a></sup></p>
<p>If we type these definitions to the interpreter, we can use <code>sqrt/1</code><sup class="footnote-reference"><a href="#6">6</a></sup> just
as we can use any function:</p>
<pre><code class="language-lisp">&gt; (sqrt 1)
1.0003048780487804
&gt; (sqrt 2)
1.4142342859400734
&gt; (sqrt 9)
3.0001264920597093
&gt; (sqrt (+ 100 37))
11.704699918046352
&gt; (sqrt (+ (sqrt 2) (sqrt 3)))
1.773849624588538
&gt; (square (sqrt 1000))
1000.0003714258778
</code></pre>
<p>The sqrt program also illustrates that the simple procedural language we have
introduced so far is sufficient for writing any purely numerical program that
one could write in, say, C or Pascal. This might seem surprising, since we have
not included in our language any iterative (looping) constructs that direct the
computer to do something over and over again. <code>sqrt/2</code>, on the other hand,
demonstrates how iteration can be accomplished using no special construct other
than the ordinary ability to call a function.<sup class="footnote-reference"><a href="#7">7</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Declarative and imperative descriptions are intimately related, as indeed are mathematics and computer science. For instance, to say that the answer produced by a program is &quot;correct&quot; is to make a declarative statement about the program. There is a large amount of research aimed at establishing techniques for proving that programs are correct, and much of the technical difficulty of this subject has to do with negotiating the transition between imperative statements (from which programs are constructed) and declarative statements (which can be used to deduce things). In a related vein, an important current area in programming-language design is the exploration of so-called very high-level languages, in which one actually programs in terms of declarative statements. The idea is to make interpreters sophisticated enough so that, given &quot;what is&quot; knowledge specified by the programmer, they can generate &quot;how to&quot; knowledge automatically. This cannot be done in general, but there are important areas where progress has been made. We shall revisit this idea in chapter 12.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This square-root algorithm is actually a special case of Newton's method, which is a general technique for finding roots of equations. The square-root algorithm itself was developed by <a href="https://en.wikipedia.org/wiki/Heron_of_Alexandria">Heron of Alexandria</a> in the first century A.D. We will see how to express the general <a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton's method</a> as a Lisp function in the section <a href="ch1/">Functions as Returned Values</a>.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>We will usually give predicates names ending with question marks, to help us remember that they are predicates. This is just a stylistic convention. As far as the interpreter is concerned, the question mark is just an ordinary character.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>We could also have expressed our initial guess as an integer. As with many Lisp implementations, LFE will convert an integer to a float if an operation (such as division) would result in a non-integer. The first two editions of this text, however, used MIT Scheme and not LFE. MIT Scheme <em>did</em> distinguish between exact integers and decimal values, and dividing two integers produces a rational number rather than a decimal. For example, dividing 10 by 6 yielded $$\frac{5}{3}$$, while dividing 10.0 by 6.0 yielded 1.6666666666666667. (We will learn how to implement arithmetic on rational numbers in the section <a href="ch1/">Example: Arithmetic Operations for Rational Numbers</a>.) In MIT Scheme, if the initial guess had been an integer and the passed argument $$x$$ was an integer, all subsequent values produced in the square-root computation would have been rational numbers rather than decimals. Mixed operations on rational numbers and decimals always yielded decimals, so starting with an initial guess that was a decimal forced all subsequent values to be decimals.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>Not only is this common practice in Erlang and LFE, but it is considered good style.If two functions of differing arity share the same name it is understood that they should be designed to solve the same problem.</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p>Due to the fact that functions of different arity may share the same name, to correctly identify a function, we need to refer to its arity. This is done with a &quot;slash&quot; (<code>/</code>) after the function name, followed by the number representing the function's arity, for example, <code>average/2</code> or <code>sqrt/1</code>.</p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p>Readers who are worried about the efficiency issues involved in using function calls to implement iteration should note the remarks on &quot;tail recursion&quot; in the section <a href="ch1/">Linear Recursion and Iteration</a>.</p>
</div>
<h3><a class="header" href="#exercises-1" id="exercises-1">Exercises</a></h3>
<h4><a class="header" href="#exercise-16" id="exercise-16">Exercise 1.6</a></h4>
<p>Bob Bitwright doesn't see why <code>if</code> needs to be provided as a special form. &quot;Why can't I just define it as an ordinary function in terms of <code>cond</code>?&quot; he asks. Bob's friend Eva Lu Ator claims this can indeed be done, and she defines a new version of <code>if</code>:</p>
<pre><code class="language-lisp">(defun new-if (predicate then-clause else-clause)
  (cond (predicate then-clause)
        ('true else-clause)))
</code></pre>
<p>Eva demonstrates the program for Bob:</p>
<pre><code class="language-lisp">&gt; (new-if (== 2 3) 0 5)
5
&gt; (new-if (== 1 1) 0 5)
0
</code></pre>
<p>Delighted, Bob uses <code>new-if/3</code> to rewrite the square-root program:</p>
<pre><code class="language-lisp">(defun sqrt (guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt (improve guess x)
                     x)))
</code></pre>
<p>What happens when Alyssa attempts to use this to compute square roots? Explain.</p>
<h4><a class="header" href="#exercise-17" id="exercise-17">Exercise 1.7.</a></h4>
<p>The <code>good-enough?/2</code> test used in computing square roots will not be very
effective for finding the square roots of very small numbers. Also, in real
computers, arithmetic operations are almost always performed with limited
precision. This makes our test inadequate for very large numbers. Explain these
statements, with examples showing how the test fails for small and large
numbers. An alternative strategy for implementing <code>good-enough?/2</code> is to
watch how <code>guess</code> changes from one iteration to the next and to stop when the
change is a very small fraction of the guess. Design a square-root function
that uses this kind of end test. Does this work better for small and large
numbers?</p>
<h4><a class="header" href="#exercise-18" id="exercise-18">Exercise 1.8.</a></h4>
<p>Newton's method for cube roots is based on the fact that if $$y$$ is an
approximation to the cube root of $$x$$, then a better approximation is given
by the value</p>
<p>$$
\begin{align}
\frac{\frac{x}{y^2}+2y}
{3}
\end{align}
$$</p>
<p>Use this formula to implement a cube-root function analogous to the square-root
function. (In the section <a href="ch1/">Functions as Returned Values</a> we will see how to
implement Newton's method in general as an abstraction of these square-root and
cube-root functions.)</p>
<h3><a class="header" href="#functions-as-black-box-abstractions" id="functions-as-black-box-abstractions">Functions as Black-Box Abstractions</a></h3>
<p><code>sqrt/1</code> is our first example of a program defined by a set of mutually
defined functions. Notice that the definition of <code>sqrt/2</code> is recursive; that
is, the function is defined in terms of itself. The idea of being able to
define a function in terms of itself may be disturbing; it may seem unclear how
such a &quot;circular&quot; definition could make sense at all, much less specify a
well-defined process to be carried out by a computer. This will be addressed
more carefully in the section <a href="ch1/">Functions and the Processes They Generate</a>.
But first let's consider some other important points illustrated by the
examples of the square-root program.</p>
<p>Observe that the problem of computing square roots breaks up naturally into a
number of subproblems: how to tell whether a guess is good enough, how to
improve a guess, and so on. Each of these tasks is accomplished by a separate
function. The entire square-root program  can be viewed as a cluster of
functions (shown in <a href="ch1/functions-as-black-box-abstractions.html#figure-2">figure 1.2</a>) that mirrors the decomposition of
the problem into subproblems.</p>
<p><a name="figure-2"></a>
<img src="ch1/images/ch1-Z-G-6.png" alt="Tree representation" /></p>
<p><strong>Figure 1.2</strong>:  Procedural decomposition of the square-root program.</p>
<p>The importance of this decomposition strategy is not simply that one is
dividing the program into parts. After all, we could take any large program and
divide it into parts -- the first ten lines, the next ten lines, the next ten
lines, and so on. Rather, it is crucial that each function accomplishes an
identifiable task that can be used as a module in defining other functions. For
example, when we define the <code>good-enough?/2</code> function in terms of
<code>square/1</code>, we are able to regard the <code>square/1</code> function as a &quot;black box.&quot;
We are not at that moment concerned with how the function computes its result,
only with the fact that it computes the square. The details of how the square
is computed can be suppressed, to be considered at a later time. Indeed, as far
as the <code>good-enough?/2</code> function is concerned, <code>square/1</code> is not quite a
function but rather an abstraction of a function, a so-called procedural
abstraction. At this level of abstraction, any function that computes the
square is equally good.</p>
<p>Thus, considering only the values they return, the following two functions for
squaring a number should be indistinguishable. Each takes a numerical argument
and produces the square of that number as the value.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<pre><code class="language-lisp">(defun square (x) (* x x))

(defun square (x)
  (exp (double (log x))))

(defun double (x) (+ x x))
</code></pre>
<p>So a function definition should be able to suppress detail. The users of the function may not have written the function themselves, but may have obtained it from another programmer as a black box. A user should not need to know how the function is implemented in order to use it.</p>
<h4><a class="header" href="#local-names" id="local-names">Local names</a></h4>
<p>One detail of a function's implementation that should not matter to the user of the function is the implementer's choice of names for the function's formal parameters. Thus, the following functions should not be distinguishable:</p>
<pre><code class="language-lisp">(defun square (x) (* x x))

(defun square (y) (* y y))
</code></pre>
<p>This principle -- that the meaning of a function should be independent of the parameter names used by its author -- seems on the surface to be self-evident, but its consequences are profound. The simplest consequence is that the parameter names of a function must be local to the body of the function. For example, we used <code>square/1</code> in the definition of <code>good-enough?/2</code> in our square-root function:</p>
<pre><code class="language-lisp">(defun good-enough? (guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
</code></pre>
<p>The intention of the author of <code>good-enough?/2</code> is to determine if the square of the first argument is within a given tolerance of the second argument. We see that the author of <code>good-enough?/2</code> used the name <code>guess</code> to refer to the first argument and <code>x</code> to refer to the second argument. The argument of <code>square/1</code> is <code>guess</code>. If the author of <code>square/1</code> used <code>x</code> (as above) to refer to that argument, we see that the x in <code>good-enough?/2</code> must be a different <code>x</code> than the one in square. Running the function square must not affect the value of <code>x</code> that is used by <code>good-enough?/2</code>, because that value of <code>x</code> may be needed by <code>good-enough?/2</code> after <code>square/1</code> is done computing.</p>
<p>If the parameters were not local to the bodies of their respective functions, then the parameter <code>x</code> in <code>square/1</code> could be confused with the parameter <code>x</code> in <code>good-enough?/2</code>, and the behavior of <code>good-enough?/2</code> would depend upon which version of <code>square/1</code> we used. Thus, <code>square/1</code> would not be the black box we desired.</p>
<p>A formal parameter of a function has a very special role in the function definition, in that it doesn't matter what name the formal parameter has. Such a name is called a <em>bound variable</em>, and we say that the function definition <em>binds</em> its formal parameters. The meaning of a function definition is unchanged if a bound variable is consistently renamed throughout the definition.<sup class="footnote-reference"><a href="#2">2</a></sup> If a variable is not bound, we say that it is <em>free</em>. The set of expressions for which a binding defines a name is called the <em>scope</em> of that name. In a function definition, the bound variables declared as the formal parameters of the function have the body of the function as their scope.</p>
<p>In the definition of <code>good-enough?/2</code> above, <code>guess</code> and <code>x</code> are bound variables but <code>&lt;</code>, <code>-</code>, <code>abs</code>, and <code>square/1</code> are free. The meaning of <code>good-enough?/2</code> should be independent of the names we choose for <code>guess</code> and <code>x</code> so long as they are distinct and different from <code>&lt;</code>, <code>-</code>, <code>abs</code>, and <code>square</code>. (If we were running this code in the LFE REPL and renamed <code>guess</code> to a variable that had been <code>set</code> earlier in the session, we would have introduced a bug by capturing that previously set variable. It would have changed from free to bound.) The meaning of <code>good-enough?/2</code> is not independent of the names of its free variables, however. It surely depends upon the fact (external to this definition) that the symbol <code>abs</code> names a function for computing the absolute value of a number. <code>good-enough?/2</code> will compute a different function if we substitute <code>cos</code> for <code>abs</code> in its definition.</p>
<h4><a class="header" href="#internal-definitions-and-block-structure" id="internal-definitions-and-block-structure">Internal definitions and block structure</a></h4>
<p>We have one kind of name isolation available to us so far: The formal parameters of a function are local to the body of the function. The square-root program illustrates another way in which we would like to control the use of names. The existing program consists of separate functions:</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (sqrt (* 0.5 x) x))

(defun sqrt (guess x)
  (if (good-enough? guess x)
      guess
      (sqrt (improve guess x)
            x)))

(defun good-enough? (guess x)
  (&lt; (abs (- (square guess) x)) 0.001))

(defun improve (guess x)
  (average guess (/ x guess)))

(defun average (x y)
  (/ (+ x y) 2))

(defun abs
  ((x) (when (&lt; x 0)) (- x))
  ((x) x))

(defun square (x) (* x x))
</code></pre>
<p>The last three are fairly general, useful in many contexts. This leaves us with the following special-purpose functions from our square-root program:</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (sqrt (* 0.5 x) x))

(defun sqrt (guess x)
  (if (good-enough? guess x)
      guess
      (sqrt (improve guess x)
            x)))

(defun good-enough? (guess x)
  (&lt; (abs (- (square guess) x)) 0.001))

(defun improve (guess x)
  (average guess (/ x guess)))
</code></pre>
<p>The problem with this program is that the only function that is important to users of the square-root program  is <code>sqrt/1</code>. The other functions (<code>sqrt/2</code>, <code>good-enough?/2</code>, and <code>improve/2</code>) only clutter up their minds. They may not define any other function called <code>good-enough?/2</code> as part of another program to work together with the square-root program, because the square-root program needs it. The problem is especially severe in the construction of large systems by many separate programmers. For example, in the construction of a large library of numerical functions, many numerical functions are computed as successive approximations and thus might have functions named <code>good-enough?/2</code> and <code>improve/2</code> as auxiliary functions. We would like to localize the subfunctions, hiding them inside <code>sqrt/1</code> so that the square-root program could coexist with other successive approximations, each having its own private <code>good-enough?/2</code> function. To make this possible, we allow a function to have internal definitions that are local to that function. For example, in the square-root problem we can write</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (fletrec ((improve (guess x)
              ;; Improve a given guess for the square root.
              (average guess (/ x guess)))
            (good-enough? (guess x)
              ;; A predicate which determines if a guess is
              ;; close enough to a correct result.
              (&lt; (abs (- (square guess) x)) 0.001))
            (sqrt (guess x)
              ;; A recursive function for approximating
              ;; the square root of a given number.
              (if (good-enough? guess x)
                  guess
                  (sqrt (improve guess x)
                        x))))
    ;; the main body of the function
    (sqrt (* 0.5 x) x)))
</code></pre>
<p>The use of <code>flet</code> (&quot;function let&quot;), <code>flet*</code> (sequential &quot;function let&quot;s) , and <code>fletrec</code> (&quot;recursive function let&quot;s) allows one to define <em>locally scoped</em> functions, or functions that are only scoped within the given form. This is one of the classic solutions to the problem of naming collisions in older Lisp programs.<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<p>But there is a better idea lurking here. In addition to internalizing the definitions of the auxiliary functions, we can simplify them. Since <code>x</code> is bound in the definition of <code>sqrt/1</code>, the functions <code>good-enough?/2</code>, <code>improve/2</code>, and <code>sqrt/2</code>, which are defined internally to sqrt, are in the scope of <code>x</code>. Thus, it is not necessary to pass <code>x</code> explicitly to each of these functions. Instead, we allow <code>x</code> to be a free variable in the internal definitions, as shown below. Then <code>x</code> gets its value from the argument with which the enclosing function <code>sqrt/1</code> is called. This discipline is called <em>lexical scoping</em>.<sup class="footnote-reference"><a href="#4">4</a></sup></p>
<pre><code class="language-lisp">(defun sqrt (x)
  (fletrec ((improve (guess)
              ;; Improve a given guess for the square root.
              (average guess (/ x guess)))
            (good-enough? (guess)
              ;; A predicate which determines if a guess is
              ;; close enough to a correct result.
              (&lt; (abs (- (square guess) x)) 0.001))
            (sqrt-rec (guess)
              ;; A recursive function for approximating
              ;; the square root of a given number.
              (if (good-enough? guess)
                  guess
                  (sqrt-rec (improve guess)))))
    ;; the main body of the function
    (sqrt-rec (* 0.5 x))))
</code></pre>
<p>Note that this required the renaming of the <code>sqrt/2</code> function. We dropped the
arity of <code>sqrt/2</code> from 2 to 1, thus causing a name collision with our
outer-most <code>sqrt/1</code> and thus renamed it to <code>sqrt-rec/1</code>.</p>
<p>The idea of this sort of nested structure originated with the programming
language Algol 60. It appears in most advanced programming languages and, as
mentioned, used to be an important tool for helping to organize the
construction of large programs.</p>
<h4><a class="header" href="#modules-exports-and-private-functions" id="modules-exports-and-private-functions">Modules, exports, and private functions</a></h4>
<p>While Algol 60 pioneered the concept of nested function definitions,<sup class="footnote-reference"><a href="#5">5</a></sup>
later versions of Algol 68 advanced the concept of <em>modules</em>.<sup class="footnote-reference"><a href="#6">6</a></sup> This made a
significant impact in the world of practical computing to the extent that most
modern languages have some form of module support built in.</p>
<p>LFE supports modules. The proper way to provide a &quot;black box&quot; program to an
LFE developer for their use is to define all the functions in one or more
modules and export only those functions which are intended to be
consumed by a developer.</p>
<p>Instead of using <code>fletrec</code>, here is the square-root program using a module
with one exported function:</p>
<pre><code class="language-lisp">(defmodule sqrt
  (export (sqrt 1)))

(defun sqrt (x)
  (sqrt (* 0.5 x) x))

(defun sqrt (guess x)
  (if (good-enough? guess x)
      guess
      (sqrt (improve guess x)
            x)))

(defun good-enough? (guess x)
  (&lt; (abs (- (square guess) x)) 0.001))

(defun improve (guess x)
  (average guess (/ x guess)))

(defun average (x y)
  (/ (+ x y) 2))

(defun abs
  ((x) (when (&lt; x 0)) (- x))
  ((x) x))

(defun square (x) (* x x))
</code></pre>
<p>Then from the LFE REPL we can compile the module and run it, using the LFE <code>(module:function ...)</code> calling syntax</p>
<pre><code class="language-lisp">&gt; (c &quot;ch1/sqrt.lfe&quot;)
#(module sqrt)
&gt; (sqrt:sqrt 25)
5.000012953048684
&gt; (sqrt:sqrt 1)
1.0003048780487804
&gt; (sqrt:sqrt 2)
1.4142156862745097
</code></pre>
<p>Attempting to use functions that are not exported results in an error</p>
<pre><code class="language-lisp">&gt; (sqrt:sqrt 1 25)
exception error: undef
  in (: sqrt sqrt 1 25)
</code></pre>
<p>We will use modules extensively to help us break up large programs into
tractable pieces.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>It is not even clear which of these functions is a more efficient implementation. This depends upon the hardware available. There are machines for which the &quot;obvious&quot; implementation is the less efficient one. Consider a machine that has extensive tables of logarithms and antilogarithms stored in a very efficient manner.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>The concept of consistent renaming is actually subtle and difficult to define formally. Famous logicians have made embarrassing errors here.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>This is one of the pillars of the <a href="https://en.wikipedia.org/wiki/Structured_programming">structured programming</a> paradigm.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Lexical scoping dictates that free variables in a function are taken to refer to bindings made by enclosing function definitions; that is, they are looked up in the environment in which the function was defined. We will see how this works in detail in chapter 11 when we study environments and the detailed behavior of the interpreter.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>Also called <em>block structures</em>.</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p>Extensions for module support in Algol 68 were released in 1970. In 1975, Modula was the first language designed from the beginning to have support for modules. Due to Modula's use of the &quot;dot&quot; <code>.</code> to separate modules and objects, that usage became popular in such languages as Python and and Java. In contrast, Erlang and LFE use the colon <code>:</code> to separate modules from functions.</p>
</div>
<h2><a class="header" href="#functions-and-the-processes-they-generate" id="functions-and-the-processes-they-generate">Functions and the Processes They Generate</a></h2>
<p>We have now considered the elements of programming: We have used primitive arithmetic operations, we have combined these operations, and we have abstracted these composite operations by defining them as compound functions. But that is not enough to enable us to say that we know how to program. Our situation is analogous to that of someone who has learned the rules for how the pieces move in chess but knows nothing of typical openings, tactics, or strategy. Like the novice chess player, we don't yet know the common patterns of usage in the domain. We lack the knowledge of which moves are worth making (which functions are worth defining). We lack the experience to predict the consequences of making a move (calling a function).</p>
<p>The ability to visualize the consequences of the actions under consideration is crucial to becoming an expert programmer, just as it is in any synthetic, creative activity. In becoming an expert photographer, for example, one must learn how to look at a scene and know how dark each region will appear on a print for each possible choice of exposure and development conditions. Only then can one reason backward, planning framing, lighting, exposure, and development to obtain the desired effects. So it is with programming, where we are planning the course of action to be taken by a process and where we control the process by means of a program. To become experts, we must learn to visualize the processes generated by various types of functions. Only after we have developed such a skill can we learn to reliably construct programs that exhibit the desired behavior.</p>
<p>A function is a pattern for the <em>local evolution</em> of a computational process. It specifies how each stage of the process is built upon the previous stage. We would like to be able to make statements about the overall, or <em>global</em>, behavior of a process whose local evolution has been specified by a function. This is very difficult to do in general, but we can at least try to describe some typical patterns of process evolution.</p>
<p>In this section we will examine some common &quot;shapes&quot; for processes generated by simple functions. We will also investigate the rates at which these processes consume the important computational resources of time and space. The functions we will consider are very simple. Their role is like that played by test patterns in photography: as oversimplified prototypical patterns, rather than practical examples in their own right.</p>
<h3><a class="header" href="#linear-recursion-and-iteration" id="linear-recursion-and-iteration">Linear Recursion and Iteration</a></h3>
<p><a name="figure-3"></a>
<img src="ch1/images/ch1-Z-G-7.png" alt="A linear recursive process for computing 6 factorial" /></p>
<p><strong>Figure 1.3</strong>:  A linear recursive process for computing $$6!$$.</p>
<p>We begin by considering the factorial function, defined by</p>
<p>$$
\begin{align}
n!=n\ (n-1)\ (n-2)\cdots3\cdot2\cdot1
\end{align}
$$</p>
<p>There are many ways to compute factorials. One way is to make use of the
observation that $$n!$$ is equal to $$n$$ times $$(n - 1)!$$ for any positive
integer $$n$$:</p>
<p>$$
\begin{align}
n!=\left[n\ (n-1)\ (n-2)\cdots3\cdot2\cdot1\right] = n\ (n-1)!
\end{align}
$$</p>
<p>Thus, we can compute $$n!$$ by computing $$(n - 1)!$$ and multiplying the
result by $$n$$. If we add the stipulation that $$1!$$ is equal to 1, this
observation translates directly into a function:</p>
<pre><code class="language-lisp">(defun factorial (n)
  (if (== n 1)
      1
      (* n (factorial (- n 1)))))
</code></pre>
<p>We can use the substitution model of section <a href="ch1/the-substitution-model-for-function-application.html">The Substitution Model for
Function Application</a> to
watch this function in action computing $$6!$$, as shown in <a href="ch1/linear-recursion-and-iteration.html#figure-3">figure
1.3</a>.</p>
<p>Now let's take a different perspective on computing factorials. We could
describe a rule for computing $$n!$$ by specifying that we first multiply 1 by
2, then multiply the result by 3, then by 4, and so on until we reach n. More
formally, we maintain a running product, together with a counter that counts
from 1 up to $$n$$. We can describe the computation by saying that the counter
and the product simultaneously change from one step to the next according to
the rule</p>
<p>product $$\gets$$ counter $$\cdot$$ product</p>
<p>counter $$\gets$$ counter $$+ 1$$</p>
<p>and stipulating that $$n!$$ is the value of the product when the counter
exceeds $$n$$.</p>
<p><a name="figure-4"></a>
<img src="ch1/images/ch1-Z-G-10.png" alt="A linear iterative process for computing 6 factorial" /></p>
<p><strong>Figure 1.4</strong>:  A linear iterative process for computing $$6!$$.</p>
<p>Once again, we can recast our description as a function for computing
factorials:</p>
<pre><code class="language-lisp">(defun factorial (n)
  (factorial 1 1 n))

(defun factorial (product counter max-count)
  (if (&gt; counter max-count)
      product
      (factorial (* counter product)
                 (+ counter 1)
                 max-count)))
</code></pre>
<p>As before, we can use the substitution model to visualize the process of computing 6!, as shown in <a href="ch1/linear-recursion-and-iteration.html#figure-4">figure 1.4</a>.</p>
<p>Compare the two processes. From one point of view, they seem hardly different at all. Both compute the same mathematical function on the same domain, and each requires a number of steps proportional to $$n$$ to compute $$n!$$. Indeed, both processes even carry out the same sequence of multiplications, obtaining the same sequence of partial products. On the other hand, when we consider the &quot;shapes&quot; of the two processes, we find that they evolve quite differently.</p>
<p>Consider the first process. The substitution model reveals a shape of expansion followed by contraction, indicated by the arrow in <a href="ch1/linear-recursion-and-iteration.html#figure-3">figure 1.3</a>. The expansion occurs as the process builds up a chain of <em>deferred operations</em> (in this case, a chain of multiplications). The contraction occurs as the operations are actually performed. This type of process, characterized by a chain of deferred operations, is called a <em>recursive process</em>. Carrying out this process requires that the interpreter keep track of the operations to be performed later on. In the computation of $$n!$$, the length of the chain of deferred multiplications, and hence the amount of information needed to keep track of it, grows linearly with $$n$$ (is proportional to $$n$$), just like the number of steps. Such a process is called a <em>linear recursive process</em>.</p>
<p>By contrast, the second process does not grow and shrink. At each step, all we need to keep track of, for any n, are the current values of the variables <code>product</code>, <code>counter</code>, and <code>max-count</code>. We call this an <em>iterative process</em>. In general, an iterative process is one whose state can be summarized by a fixed number of <em>state variables</em>, together with a fixed rule that describes how the state variables should be updated as the process moves from state to state and an (optional) end test that specifies conditions under which the process should terminate. In computing $$n!$$, the number of steps required grows linearly with $$n$$. Such a process is called a <em>linear iterative process</em>.</p>
<p>The contrast between the two processes can be seen in another way. In the iterative case, the program variables provide a complete description of the state of the process at any point. If we stopped the computation between steps, all we would need to do to resume the computation is to supply the interpreter with the values of the three program variables. Not so with the recursive process. In this case there is some additional &quot;hidden&quot; information, maintained by the interpreter and not contained in the program variables, which indicates &quot;where the process is&quot; in negotiating the chain of deferred operations. The longer the chain, the more information must be maintained.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>In contrasting iteration and recursion, we must be careful not to confuse the notion of a recursive <em>process</em> with the notion of a recursive <em>function</em>. When we describe a function as recursive, we are referring to the syntactic fact that the function definition refers (either directly or indirectly) to the function itself. But when we describe a process as following a pattern that is, say, linearly recursive, we are speaking about how the process evolves, not about the syntax of how a function is written. It may seem disturbing that we refer to a recursive function such as <code>factorial/3</code> as generating an iterative process. However, the process really is iterative: Its state is captured completely by its three state variables, and an interpreter need keep track of only three variables in order to execute the process.</p>
<p>One reason that the distinction between process and function may be confusing is that most implementations of common languages (including Ada, Pascal, and C) are designed in such a way that the interpretation of any recursive function consumes an amount of memory that grows with the number of function calls, even when the process described is, in principle, iterative. As a consequence, these languages can describe iterative processes only by resorting to special-purpose ``looping constructs'' such as do, repeat, until, for, and while. The implementation of Scheme we shall consider in the chapter <a href="ch1/">Computing with Register Machines</a> does not share this defect. [LFE Editor's Note: we need to revisit this note after we have completed writing Chapter 5, in case the facts referred to in this footnote end up being different or otherwise untrue.] It will execute an iterative process in constant space, even if the iterative process is described by a recursive function. An implementation with this property is called tail-recursive. With a tail-recursive implementation, iteration can be expressed using the ordinary function call mechanism, so that special iteration constructs are useful only as syntactic sugar.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>When we discuss the implementation of functions on register machines in chapter 14, we will see that any iterative process can be realized &quot;in hardware&quot; as a machine that has a fixed set of registers and no auxiliary memory. In contrast, realizing a recursive process requires a machine that uses an auxiliary data structure known as a stack. </p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Tail recursion has long been known as a compiler optimization trick. A coherent semantic basis for tail recursion was provided by Carl Hewitt (1977), who explained it in terms of the &quot;message-passing&quot; model of computation that we shall discuss in chapter 12. Inspired by this, Gerald Jay Sussman and Guy Lewis Steele Jr. (see Steele 1975) constructed a tail-recursive interpreter for Scheme. Steele later showed how tail recursion is a consequence of the natural way to compile function calls (Steele 1977). The IEEE standard for Scheme requires that Scheme implementations be tail-recursive. Note that LFE also supports tail-recursion (<a href="http://learnyousomeerlang.com/recursion">via Erlang</a>).</p>
</div>
<h3><a class="header" href="#exercises-2" id="exercises-2">Exercises</a></h3>
<h4><a class="header" href="#exercise-19" id="exercise-19">Exercise 1.9</a></h4>
<p>Each of the following two functions defines a method for adding two positive integers in terms of the functions inc, which increments its argument by 1, and dec, which decrements its argument by 1.</p>
<pre><code class="language-lisp">(defun add (a b)
  (if (== a 0)
      b
      (inc (+ (dec a) b))))

(defun add (a b)
  (if (== a 0)
      b
      (+ (dec a) (inc b))))
</code></pre>
<p>Using the substitution model, illustrate the process generated by each function in evaluating <code>(+ 4 5)</code>. Are these processes iterative or recursive? </p>
<h4><a class="header" href="#exercise-110" id="exercise-110">Exercise 1.10</a></h4>
<p>The Ackermann function is defined as</p>
<p>$$
A(m, n) =
\begin{cases}
n+1 &amp; \mbox{if } m = 0 \
A(m-1, 1) &amp; \mbox{if } m &gt; 0 \mbox{ and } n = 0 \
A(m-1, A(m, n-1)) &amp; \mbox{if } m &gt; 0 \mbox{ and } n &gt; 0.
\end{cases}
$$</p>
<p>Here is the function in LFE:</p>
<pre><code class="language-lisp">(defun ackermann
  ((0 n) (+ n 1))
  ((m 0) (ackermann (- m 1) 1))
  ((m n) (ackermann (- m 1) (ackermann m (- n 1)))))
</code></pre>
<p>What are the values of the following expressions?</p>
<pre><code class="language-lisp">(ackermann 1 10)
(ackermann 2 4)
(ackermann 3 3)
</code></pre>
<p>Consider the following functions, where <code>ackermann</code> is the function defined above:</p>
<pre><code class="language-lisp">(defun f (n) (ackermann 0 n))

(defun g (n) (ackermann 1 n))

(defun h (n) (ackermann 2 n))

(defun k (n) (* 5 n n))
</code></pre>
<p>Give concise mathematical definitions for the functions computed by the functions <code>f</code>, <code>g</code>, and <code>h</code> for positive integer values of <code>n</code>. For example, <code>(k n)</code> computes $$5n^2$$. </p>
<h3><a class="header" href="#tree-recursion" id="tree-recursion">Tree Recursion</a></h3>
<p>Another common pattern of computation is called <em>tree recursion</em>. As an example, consider computing the sequence of Fibonacci numbers, in which each number is the sum of the preceding two:</p>
<p>$$
0,;1,;1,;2,;3,;5,;8,;13,;21,;34,;55,;89,;144,; \ldots;
$$</p>
<p>In general, the Fibonacci numbers can be defined by the rule</p>
<p>$$
Fib(n) =
\begin{cases}
0 &amp; \mbox{if } n = 0 \
1 &amp; \mbox{if } n = 1  \
Fib(n-1) + Fib(n-2) &amp; \mbox{otherwise }
\end{cases}
$$</p>
<p>We can immediately translate this definition into a recursive function for computing Fibonacci numbers:</p>
<pre><code class="language-lisp">(defun fib
  ((0) 0)
  ((1) 1)
  ((n)
    (+ (fib (- n 1))
       (fib (- n 2)))))
</code></pre>
<p><a name="figure-5"></a>
<img src="ch1/images/ch1-Z-G-13.png" alt="The tree-recursive process generated in computing (fib 5)" /></p>
<p><strong>Figure 1.5</strong>:  The tree-recursive process generated in computing <code>(fib 5)</code>.</p>
<p>Consider the pattern of this computation. To compute <code>(fib 5)</code>, we compute <code>(fib 4)</code> and <code>(fib 3)</code>. To compute <code>(fib 4)</code>, we compute <code>(fib 3)</code> and <code>(fib 2)</code>. In general, the evolved process looks like a tree, as shown in <a href="ch1/tree-recursion.html#figure-5">figure 1.5</a>. Notice that the branches split into two at each level (except at the bottom); this reflects the fact that the <code>fib/1</code> function calls itself twice each time it is invoked.</p>
<p>This function is instructive as a prototypical tree recursion, but it is a terrible way to compute Fibonacci numbers because it does so much redundant computation. Notice in <a href="ch1/tree-recursion.html#figure-5">figure 1.5</a> that the entire computation of <code>(fib 3)</code> -- almost half the work -- is duplicated. In fact, it is not hard to show that the number of times the function will compute <code>(fib 1)</code> or <code>(fib 0)</code> (the number of leaves in the above tree, in general) is precisely $$Fib(n + 1)$$. To get an idea of how bad this is, one can show that the value of $$Fib(n)$$ grows exponentially with $$n$$. More precisely (see exercise 1.13), $$Fib(n)$$ is the closest integer to $$\frac{\phi^n}{\sqrt 5}$$, where</p>
<p>$$
\phi = \frac{1 + \sqrt 5}{2} \approx 1.61803
$$</p>
<p>is the golden ratio, which satisfies the equation</p>
<p>$$
\phi^2 = \phi + 1
$$</p>
<p>Thus, the process uses a number of steps that grows exponentially with the input. On the other hand, the space required grows only linearly with the input, because we need keep track only of which nodes are above us in the tree at any point in the computation. In general, the number of steps required by a tree-recursive process will be proportional to the number of nodes in the tree, while the space required will be proportional to the maximum depth of the tree.</p>
<p>We can also formulate an iterative process for computing the Fibonacci numbers. The idea is to use a pair of integers a and b, initialized to $$Fib(1) = 1$$ and $$Fib(0) = 0$$, and to repeatedly apply the simultaneous transformations</p>
<p>$$a \gets a + b$$</p>
<p>$$b \gets a $$</p>
<p>It is not hard to show that, after applying this transformation $$n$$ times, $$a$$ and $$b$$ will be equal, respectively, to $$Fib(n + 1)$$ and $$Fib(n)$$. Thus, we can compute Fibonacci numbers iteratively using the function</p>
<pre><code class="language-lisp">(defun fib
  ((n) (when (&gt;= n 0))
    (fib n 0 1)))

(defun fib
  ((0 result _)
    result)
  ((n result next)
    (fib (- n 1) next (+ result next))))
</code></pre>
<p>This second method for computing $$Fib(n)$$ is a linear iteration. The difference in number of steps required by the two methods -- one linear in $$n$$, one growing as fast as $$Fib(n)$$ itself -- is enormous, even for small inputs.</p>
<p>One should not conclude from this that tree-recursive processes are useless. When we consider processes that operate on hierarchically structured data rather than numbers, we will find that tree recursion is a natural and powerful tool.<sup class="footnote-reference"><a href="#1">1</a></sup> But even in numerical operations, tree-recursive processes can be useful in helping us to understand and design programs. For instance, although the first <code>fib</code> function is much less efficient than the second one, it is more straightforward, being little more than a translation into Lisp of the definition of the Fibonacci sequence. To formulate the iterative algorithm required noticing that the computation could be recast as an iteration with three state variables.</p>
<h4><a class="header" href="#example-counting-change" id="example-counting-change">Example: Counting change</a></h4>
<p>It takes only a bit of cleverness to come up with the iterative Fibonacci algorithm. In contrast, consider the following problem: How many different ways can we make change of $ 1.00, given half-dollars, quarters, dimes, nickels, and pennies? More generally, can we write a function to compute the number of ways to change any given amount of money?</p>
<p>This problem has a simple solution as a recursive function. Suppose we think of the types of coins available as arranged in some order. Then the following relation holds:</p>
<p>The number of ways to change amount $$a$$ using $$n$$ kinds of coins equals</p>
<ul>
<li>the number of ways to change amount $$a$$ using all but the first kind of coin, plus</li>
<li>the number of ways to change amount $$a$$ - $$d$$ using all n kinds of coins, where $$d$$ is the denomination of the first kind of coin.</li>
</ul>
<p>To see why this is true, observe that the ways to make change can be divided into two groups: those that do not use any of the first kind of coin, and those that do. Therefore, the total number of ways to make change for some amount is equal to the number of ways to make change for the amount without using any of the first kind of coin, plus the number of ways to make change assuming that we do use the first kind of coin. But the latter number is equal to the number of ways to make change for the amount that remains after using a coin of the first kind.</p>
<p>Thus, we can recursively reduce the problem of changing a given amount to the problem of changing smaller amounts using fewer kinds of coins. Consider this reduction rule carefully, and convince yourself that we can use it to describe an algorithm if we specify the following degenerate cases:<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<ul>
<li>If $$a$$ is exactly 0, we should count that as 1 way to make change.</li>
<li>If $$a$$ is less than 0, we should count that as 0 ways to make change.</li>
<li>If $$n$$ is 0, we should count that as 0 ways to make change.</li>
</ul>
<p>We can easily translate this description into a recursive function:</p>
<pre><code class="language-lisp">(defun count-change (amount)
  (cc amount 5))

(defun cc (amount kinds-of-coins)
  (cond ((== amount 0) 1)
        ((or (&lt; amount 0) (== kinds-of-coins 0)) 0)
        ('true (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(defun first-denomination (kinds-of-coins)
  (cond ((== kinds-of-coins 1) 1)
        ((== kinds-of-coins 2) 5)
        ((== kinds-of-coins 3) 10)
        ((== kinds-of-coins 4) 25)
        ((== kinds-of-coins 5) 50)))
</code></pre>
<p>(The <code>first-denomination</code> function takes as input the number of kinds of coins available and returns the denomination of the first kind. Here we are thinking of the coins as arranged in order from largest to smallest, but any order would do as well.)</p>
<p>We can now answer our original question about changing a dollar:</p>
<pre><code class="language-lisp">&gt; (count-change 100)
292
</code></pre>
<p><code>count-change</code> generates a tree-recursive process with redundancies similar to those in our first implementation of <code>fib</code>. (It will take quite a while for that 292 to be computed.) On the other hand, it is not obvious how to design a better algorithm for computing the result, and we leave this problem as a challenge. The observation that a tree-recursive process may be highly inefficient but often easy to specify and understand has led people to propose that one could get the best of both worlds by designing a &quot;smart compiler&quot; that could transform tree-recursive functions into more efficient functions that compute the same result.<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>An example of this was hinted at in the section <a href="ch1/">Evaluating Combinations</a>: The interpreter itself evaluates expressions using a tree-recursive process.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>For example, work through in detail how the reduction rule applies to the problem of making change for 10 cents using pennies and nickels.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>One approach to coping with redundant computations is to arrange matters so that we automatically construct a table of values as they are computed. Each time we are asked to apply the function to some argument, we first look to see if the value is already stored in the table, in which case we avoid performing the redundant computation. This strategy, known as <em>tabulation</em> or <em>memoization</em>, can be implemented in a straightforward way. Tabulation can sometimes be used to transform processes that require an exponential number of steps (such as <code>count-change</code>) into processes whose space and time requirements grow linearly with the input. See exercise 3.27.</p>
</div>
<h3><a class="header" href="#exercises-3" id="exercises-3">Exercises</a></h3>
<h4><a class="header" href="#exercise-111" id="exercise-111">Exercise 1.11</a></h4>
<p>A function $$f$$ is defined by the rule that $$f(n) = n$$ if $$n &lt; 3$$ and $$f(n) = f(n - 1) + 2 \cdot f(n - 2) + 3 \cdot f(n - 3)$$ if $$n &gt; 3$$. Write a function that computes $$f$$ by means of a recursive process. Write a function that computes $$f$$ by means of an iterative process. </p>
<h4><a class="header" href="#exercise-112" id="exercise-112">Exercise 1.12</a></h4>
<p>The following pattern of numbers is called <em>Pascal's triangle</em>.</p>
<p>$$
\begin{array}{ccccccccc}
&amp;     &amp;     &amp;      &amp; 1     &amp;      &amp;      &amp;     &amp;   \
&amp;     &amp;     &amp; 1    &amp;       &amp;  1   &amp;      &amp;     &amp;   \
&amp;     &amp; 1   &amp;      &amp; 2     &amp;      &amp; 1    &amp;     &amp;   \
&amp; 1   &amp;     &amp; 3    &amp;       &amp;  3   &amp;      &amp; 1   &amp;   \
1 &amp;     &amp; 4   &amp;      &amp; 6     &amp;      &amp; 4    &amp;     &amp; 1 \
&amp;     &amp;     &amp;      &amp; \dots &amp;      &amp;      &amp;     &amp;   \
\end{array}
$$</p>
<p>The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it.<sup class="footnote-reference"><a href="#1">1</a></sup> Write a function that computes elements of Pascal's triangle by means of a recursive process. </p>
<h4><a class="header" href="#exercise-113" id="exercise-113">Exercise 1.13</a></h4>
<p>Prove that $$Fib(n)$$ is the closest integer to $$\frac{\phi^n}{\sqrt 5}$$, where $$\phi = \frac{1 + \sqrt 5}{2}$$. Hint: Let $$\psi = \frac{1 - \sqrt 5}{2}$$. Use induction and the definition of the Fibonacci numbers (see the section <a href="ch1/">Tree Recursion</a>) to prove that $$Fib(n) = \frac{\phi^n - \psi^n}{\sqrt5}$$. </p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The elements of Pascal's triangle are called the <em>binomial coefficients</em>, because the nth row consists of the coefficients of the terms in the expansion of $$(x + y)^n$$. This pattern for computing the coefficients appeared in Blaise Pascal's 1653 seminal work on probability theory, <em>Traité du triangle arithmétique</em>. According to Knuth (1973), the same pattern appears in the <em>Szu-yuen Yü-chien</em> (&quot;The Precious Mirror of the Four Elements&quot;), published by the Chinese mathematician Chu Shih-chieh in 1303, in the works of the twelfth-century Persian poet and mathematician Omar Khayyam, and in the works of the twelfth-century Hindu mathematician Bháscara Áchárya. </p>
</div>
<h3><a class="header" href="#orders-of-growth" id="orders-of-growth">Orders of Growth</a></h3>
<p>The previous examples illustrate that processes can differ considerably in the rates at which they consume computational resources. One convenient way to describe this difference is to use the notion of <em>order of growth</em> to obtain a gross measure of the resources required by a process as the inputs become larger.</p>
<p>Let $$n$$ be a parameter that measures the size of the problem, and let $$R(n)$$ be the amount of resources the process requires for a problem of size $$n$$. In our previous examples we took n to be the number for which a given function is to be computed, but there are other possibilities. For instance, if our goal is to compute an approximation to the square root of a number, we might take $$n$$ to be the number of digits accuracy required. For matrix multiplication we might take n to be the number of rows in the matrices. In general there are a number of properties of the problem with respect to which it will be desirable to analyze a given process. Similarly, $$R(n)$$ might measure the number of internal storage registers used, the number of elementary machine operations performed, and so on. In computers that do only a fixed number of operations at a time, the time required will be proportional to the number of elementary machine operations performed.</p>
<p>We say that $$R(n)$$ has order of growth $$\Theta(f(n))$$, written $$R(n) = \Theta(f(n))$$ (pronounced &quot;theta of $$f(n)$$&quot;), if there are positive constants $$k1$$ and $$k2$$ independent of n such that </p>
<p>$$
k_1 f(n) \le R(n) \le k_2 f(n)
$$</p>
<p>for any sufficiently large value of $$n$$. (In other words, for large $$n$$, the value $$R(n)$$ is sandwiched between $$k_1f(n)$$ and $$k_2f(n)$$.)</p>
<p>For instance, with the linear recursive process for computing factorial described in the section <a href="ch1/">Linear Recursion and Iteration</a> the number of steps grows proportionally to the input $$n$$. Thus, the steps required for this process grows as $$\Theta(n)$$. We also saw that the space required grows as $$\Theta(n)$$. For the iterative factorial, the number of steps is still $$\Theta(n)$$ but the space is $$\Theta(1)$$ -- that is, constant.<sup class="footnote-reference"><a href="#1">1</a></sup> The tree-recursive Fibonacci computation requires $$\Theta(\phi^n)$$ steps and space $$\Theta(n)$$, where $$\phi$$ is the golden ratio described in the section <a href="ch1/">Tree Recursion</a>.</p>
<p>Orders of growth provide only a crude description of the behavior of a process. For example, a process requiring $$n^2$$ steps and a process requiring $$1000 n^2$$ steps and a process requiring $$3n^2 + 10n + 17$$ steps all have $$\Theta(n^2)$$ order of growth. On the other hand, order of growth provides a useful indication of how we may expect the behavior of the process to change as we change the size of the problem. For a $$\Theta(n)$$ (linear) process, doubling the size will roughly double the amount of resources used. For an exponential process, each increment in problem size will multiply the resource utilization by a constant factor. In the remainder of the section <a href="ch1/">Functions and the Processes They Generate</a> we will examine two algorithms whose order of growth is logarithmic, so that doubling the problem size increases the resource requirement by a constant amount.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>These statements mask a great deal of oversimplification. For instance, if we count process steps as &quot;machine operations&quot; we are making the assumption that the number of machine operations needed to perform, say, a multiplication is independent of the size of the numbers to be multiplied, which is false if the numbers are sufficiently large. Similar remarks hold for the estimates of space. Like the design and description of a process, the analysis of a process can be carried out at various levels of abstraction. </p>
</div>
<h3><a class="header" href="#exercises-4" id="exercises-4">Exercises</a></h3>
<h4><a class="header" href="#exercise-114" id="exercise-114">Exercise 1.14</a></h4>
<p>Draw the tree illustrating the process generated by the <code>count-change/1</code> function of the section <a href="ch1/">Tree Recursion</a> in making change for 11 cents. What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases? </p>
<h4><a class="header" href="#exercise-115" id="exercise-115">Exercise 1.15</a></h4>
<p>The sine of an angle (specified in radians) can be computed by making use of the approximation $$sin\ x \approx x$$ if $$x$$ is sufficiently small, and the trigonometric identity </p>
<p>$$
sin \ r = 3 sin \frac{r}{3} - 4 sin^3 \frac{r}{3}
$$</p>
<p>to reduce the size of the argument of $$sin$$. (For purposes of this exercise an angle is considered &quot;sufficiently small&quot; if its magnitude is not greater than 0.1 radians.) These ideas are incorporated in the following functions:</p>
<pre><code class="language-lisp">(defun cube (x) (* x x x))

(defun p (x) (- (* 3 x) (* 4 (cube x))))

(defun sine (angle)
   (if (not (&gt; (abs angle) 0.1))
       angle
       (p (sine (/ angle 3.0)))))
</code></pre>
<p>a.  How many times is the function <code>p/1</code> called when <code>(sine 12.15)</code> is evaluated?</p>
<p>b.  What is the order of growth in space and number of steps (as a function of <code>a</code>) used by the process generated by the <code>sine/1</code> function when <code>(sine a)</code> is evaluated? </p>
<h3><a class="header" href="#exponentiation" id="exponentiation">Exponentiation</a></h3>
<p>Consider the problem of computing the exponential of a given number. We would like a function that takes as arguments a base $$b$$ and a positive integer exponent $$n$$ and computes $$b^n$$. One way to do this is via the recursive definition</p>
<p>$$
\begin{align}
&amp; b^n = b \cdot b^{n-1} \
&amp; b^0 = 1
\end{align}
$$</p>
<p>which translates readily into the function</p>
<pre><code class="language-lisp">(defun expt (b n)
  (if (== n 0)
      1
      (* b (expt b (- n 1)))))
</code></pre>
<p>This is a linear recursive process, which requires $$\Theta(n)$$ steps and $$\Theta(n)$$ space. Just as with factorial, we can readily formulate an equivalent linear iteration:</p>
<pre><code class="language-lisp">(defun expt (b n)
  (expt b n 1))

(defun expt (b counter product)
  (if (== counter 0)
      product
      (expt b
            (- counter 1)
            (* b product))))
</code></pre>
<p>This version requires $$\Theta(n)$$ steps and $$\Theta(1)$$ space.</p>
<p>We can compute exponentials in fewer steps by using successive squaring. For instance, rather than computing $$b^8$$ as</p>
<p>$$
b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot b))))))
$$</p>
<p>we can compute it using three multiplications:</p>
<p>$$
\begin{align}
&amp; b^2 = b \cdot b \
&amp; b^4 = b^2 \cdot b^2 \
&amp; b^8 = b^4 \cdot b^4 \
\end{align}
$$</p>
<p>This method works fine for exponents that are powers of 2. We can also take advantage of successive squaring in computing exponentials in general if we use the rule</p>
<p>$$
\begin{align}
&amp; b^n = (b^\frac{n}{2})^2 &amp; \mbox{if } n \ \text{is even} \
&amp; b^n = b \cdot b^{n-1} &amp; \mbox{if } n \ \text{is odd} \
\end{align}
$$</p>
<p>We can express this method as a function:</p>
<pre><code class="language-lisp">(defun fast-expt (b n)
  (cond ((== n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        ('true (* b (fast-expt b (- n 1))))))
</code></pre>
<p>where the predicate to test whether an integer is even is defined in terms of the primitive function <code>rem</code> by</p>
<pre><code class="language-lisp">(defun even? (n)
  (=:= 0 (rem (trunc n) 2)))
</code></pre>
<p>The process evolved by <code>fast-expt</code> grows logarithmically with $$n$$ in both space and number of steps. To see this, observe that computing $$b^{2n}$$ using <code>fast-expt</code> requires only one more multiplication than computing $$b^n$$. The size of the exponent we can compute therefore doubles (approximately) with every new multiplication we are allowed. Thus, the number of multiplications required for an exponent of n grows about as fast as the logarithm of $$n$$ to the base 2. The process has $$\Theta(\log n)$$ growth.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>The difference between $$\Theta(\log n)$$ growth and $$\Theta(n)$$ growth becomes striking as $$n$$ becomes large. For example, <code>fast-expt</code> for $$n = 1000$$ requires only 14 multiplications.<sup class="footnote-reference"><a href="#2">2</a></sup> It is also possible to use the idea of successive squaring to devise an iterative algorithm that computes exponentials with a logarithmic number of steps (see exercise 1.16), although, as is often the case with iterative algorithms, this is not written down so straightforwardly as the recursive algorithm.<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>More precisely, the number of multiplications required is equal to 1 less than the log base 2 of $$n$$ plus the number of ones in the binary representation of $$n$$. This total is always less than twice the log base 2 of $$n$$. The arbitrary constants $$k_1$$ and $$k_2$$ in the definition of order notation imply that, for a logarithmic process, the base to which logarithms are taken does not matter, so all such processes are described as $$\Theta(\log n)$$.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>You may wonder why anyone would care about raising numbers to the 1000th power. See the section <a href="ch1/">Example: Testing for Primality</a>.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>This iterative algorithm is ancient. It appears in the Chandah-sutra by Áchárya Pingala, written before 200 B.C. See Knuth 1981, section 4.6.3, for a full discussion and analysis of this and other methods of exponentiation.</p>
</div>
<h3><a class="header" href="#exercises-5" id="exercises-5">Exercises</a></h3>
<h4><a class="header" href="#exercise-116" id="exercise-116">Exercise 1.16</a></h4>
<p>Design a function that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps, as does <code>fast-expt/2</code>. (Hint: Using the observation that $$(b^\frac{n}{2})^2 = (b^{2})^\frac{n}{2}$$, keep, along with the exponent $$n$$ and the base $$b$$, an additional state variable $$a$$, and define the state transformation in such a way that the product $$a \cdot b^n$$ is unchanged from state to state. At the beginning of the process $$a$$ is taken to be 1, and the answer is given by the value of $$a$$ at the end of the process. In general, the technique of defining an <em>invariant quantity</em> that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.) </p>
<h4><a class="header" href="#exercise-117" id="exercise-117">Exercise 1.17</a></h4>
<p>The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication. In a similar way, one can perform integer multiplication by means of repeated addition. The following multiplication function (in which it is assumed that our language can only add, not multiply) is analogous to the <code>expt</code> function:</p>
<pre><code class="language-lisp">(defun mult (a b)
  (if (== b 0)
      0
      (+ a (mult a (- b 1)))))
</code></pre>
<p>This algorithm takes a number of steps that is linear in <code>b</code>. Now suppose we include, together with addition, operations <code>double</code>, which doubles an integer, and <code>halve</code>, which divides an (even) integer by 2. Using these, design a multiplication function analogous to <code>fast-expt</code> that uses a logarithmic number of steps.</p>
<h4><a class="header" href="#exercise-118" id="exercise-118">Exercise 1.18.</a></h4>
<p>Using the results of exercises 1.16 and 1.17 above, devise a function that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<h4><a class="header" href="#exercise-119" id="exercise-119">Exercise 1.19</a></h4>
<p>There is a clever algorithm for computing the Fibonacci numbers in a logarithmic number of steps. Recall the transformation of the state variables $$a$$ and $$b$$ in the iterative version of <code>fib/1</code> (with <code>fib/2</code>) in the section <a href="ch1/">Tree Recursion</a>: $$a \gets a + b$$ and $$b \gets a $$. Call this transformation $$T$$, and observe that applying $$T$$ over and over again $$n$$ times, starting with 1 and 0, produces the pair $$Fib(n + 1)$$ and $$Fib(n)$$. In other words, the Fibonacci numbers are produced by applying $$T^n$$, the $$n$$th power of the transformation $$T$$, starting with the pair $$(1,0)$$. Now consider $$T$$ to be the special case of $$p = 0$$ and $$q = 1$$ in a family of transformations $$T_{pq}$$, where $$T_{pq}$$ transforms the pair $$(a,b)$$ according to a $$a \gets bq + aq + ap$$ and $$b \gets bp + aq$$. Show that if we apply such a transformation $$T_{pq}$$ twice, the effect is the same as using a single transformation $$T_{p'q'}$$ of the same form, and compute $$p'$$ and $$q'$$ in terms of $$p$$ and $$q$$. This gives us an explicit way to square these transformations, and thus we can compute $$T^n$$ using successive squaring, as in the <code>fast-expt/2</code> function. Put this all together to complete the following functions, which run in a logarithmic number of steps:<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<pre><code class="language-lisp">(defun fib (n)
  (fib 1 0 0 1 n))

(defun fib
  ((_ b _ _ 0)
   b)
  ((a b p q count)
   (if (even? count)
       (fib a
            b
            &lt;??&gt;      ; compute p'
            &lt;??&gt;      ; compute q'
            (/ count 2))
       (fib (+ (* b q) (* a q) (* a p))
            (+ (* b p) (* a q))
            p
            q
            (- count 1)))))
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This algorithm, which is sometimes known as the &quot;Russian peasant method&quot; of multiplication, is ancient. Examples of its use are found in the Rhind Papyrus, one of the two oldest mathematical documents in existence, written about 1700 B.C. (and copied from an even older document) by an Egyptian scribe named A'h-mose. </p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This exercise was suggested to us by Joe Stoy, based on an example in Kaldewaij 1990.</p>
</div>
<h3><a class="header" href="#greatest-common-divisors" id="greatest-common-divisors">Greatest Common Divisors</a></h3>
<p>The greatest common divisor (GCD) of two integers $$a$$ and $$b$$ is defined to be the largest integer that divides both $$a$$ and $$b$$ with no remainder. For example, the GCD of 16 and 28 is 4. In chapter 2, when we investigate how to implement rational-number arithmetic, we will need to be able to compute GCDs in order to reduce rational numbers to lowest terms. (To reduce a rational number to lowest terms, we must divide both the numerator and the denominator by their GCD. For example, 16/28 reduces to 4/7.) One way to find the GCD of two integers is to factor them and search for common factors, but there is a famous algorithm that is much more efficient.</p>
<p>The idea of the algorithm is based on the observation that, if $$r$$ is the remainder when $$a$$ is divided by $$b$$, then the common divisors of $$a$$ and $$b$$ are precisely the same as the common divisors of $$b$$ and $$r$$. Thus, we can use the equation</p>
<p>$$
\DeclareMathOperator*{\gcd}{GCD}
\gcd(a, b) = \gcd(b, r)
$$</p>
<p>to successively reduce the problem of computing a GCD to the problem of computing the GCD of smaller and smaller pairs of integers. For example,</p>
<p>$$
\begin{align}
\DeclareMathOperator*{\gcd}{GCD}
\gcd(206, 40) = \gcd(40, 6) \
= \gcd(6, 4) \ \ \
= \gcd(4, 2) \ \ \
= \gcd(2, 0) \ \ \
= 2;;;;;;;;;;;;:,
\end{align}
$$</p>
<p>reduces $$\text{GCD}(206,40)$$ to $$\text{GCD}(2,0)$$, which is 2. It is possible to show that starting with any two positive integers and performing repeated reductions will always eventually produce a pair where the second number is 0. Then the GCD is the other number in the pair. This method for computing the GCD is known as <em>Euclid's Algorithm</em>.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>It is easy to express Euclid's Algorithm as a function:</p>
<pre><code class="language-lisp">(defun gcd (a b)
  (if (== b 0)
      a
      (gcd b (rem a b))))
</code></pre>
<p>This generates an iterative process, whose number of steps grows as the logarithm of the numbers involved.</p>
<p>The fact that the number of steps required by Euclid's Algorithm has logarithmic growth bears an interesting relation to the Fibonacci numbers:</p>
<p><strong>Lamé's Theorem</strong>: If Euclid's Algorithm requires $$k$$ steps to compute the GCD of some pair, then the smaller number in the pair must be greater than or equal to the $$k$$th Fibonacci number.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p>We can use this theorem to get an order-of-growth estimate for Euclid's Algorithm. Let $$n$$ be the smaller of the two inputs to the function. If the process takes $$k$$ steps, then we must have $$n \ge Fib (k) \approx \frac{\phi^k}{\sqrt 5}$$. Therefore the number of steps $$k$$ grows as the logarithm (to the base $$\phi$$) of $$n$$. Hence, the order of growth is $$\Theta(\log n)$$.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Euclid's Algorithm is so called because it appears in Euclid's Elements (Book 7, ca. 300 B.C.). According to Knuth (1973), it can be considered the oldest known nontrivial algorithm. The ancient Egyptian method of multiplication (exercise 1.18) is surely older, but, as Knuth explains, Euclid's algorithm is the oldest known to have been presented as a general algorithm, rather than as a set of illustrative examples.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This theorem was proved in 1845 by Gabriel Lamé, a French mathematician and engineer known chiefly for his contributions to mathematical physics. To prove the theorem, we consider pairs $$(a_k, b_k)$$, where $$a_k \ge b_k$$, for which Euclid's Algorithm terminates in $$k$$ steps. The proof is based on the claim that, if $$(a_{k+1}, b_{k+1}) \to (a_k, b_k) \to (a_{k-1}, b_{k-1})$$ are three successive pairs in the reduction process, then we must have $$b_{k+1} \ge b_k + b_{k-1}$$. To verify the claim, consider that a reduction step is defined by applying the transformation $$a_{k-1} = b_k$$, $$b_{k-1} = $$ remainder of $$a_k$$ divided by $$b_k$$. The second equation means that $$a_k = qb_k + b_{k-1}$$ for some positive integer $$q$$. And since $$q$$ must be at least 1 we have $$a_k = qb_k + b_{k-1} \ge b_k + b_{k-1}$$. But in the previous reduction step we have $$b_{k+1} = a_k$$. Therefore, $$b_{k+1} = a_k \ge b_k + b_{k-1}$$. This verifies the claim. Now we can prove the theorem by induction on k, the number of steps that the algorithm requires to terminate. The result is true for $$k = 1$$, since this merely requires that $$b$$ be at least as large as $$Fib(1) = 1$$. Now, assume that the result is true for all integers less than or equal to $$k$$ and establish the result for $$k + 1$$. Let $$(a_{k+1}, b_{k+1}) \to (a_k, b_k) \to (a_{k-1}, b_{k-1})$$ be successive pairs in the reduction process. By our induction hypotheses, we have $$b_{k-1} \ge Fib(k - 1)$$ and $$b_k \ge Fib(k)$$. Thus, applying the claim we just proved together with the definition of the Fibonacci numbers gives $$b_{k+1} \ge b_k + b_{k-1} \ge Fib(k) + Fib(k - 1) = Fib(k + 1)$$, which completes the proof of Lamé's Theorem.</p>
</div>
<h3><a class="header" href="#exercises-6" id="exercises-6">Exercises</a></h3>
<h4><a class="header" href="#exercise-120" id="exercise-120">Exercise 1.20.</a></h4>
<p>The process that a function generates is of course dependent on the rules used by the interpreter. As an example, consider the iterative <code>gcd/2</code> function given previously. Suppose we were to interpret this function using normal-order evaluation, as discussed in the section <a href="ch1/">The Substitution Model for Function Application</a>. (The normal-order-evaluation rule for <code>if</code> is described in exercise 1.5.) Using the substitution method (for normal order), illustrate the process generated in evaluating <code>(gcd 206 40)</code> and indicate the <code>rem</code> operations that are actually performed. How many <code>rem</code> operations are actually performed in the normal-order evaluation of <code>(gcd 206 40)</code>? In the applicative-order evaluation? </p>
<h3><a class="header" href="#example-testing-for-primality" id="example-testing-for-primality">Example: Testing for Primality</a></h3>
<p>This section describes two methods for checking the primality of an integer $$n$$, one with order of growth $$\Theta(\sqrt n$$), and a &quot;probabilistic&quot; algorithm with order of growth $$\Theta(\log n)$$. The exercises at the end of this section suggest programming projects based on these algorithms.</p>
<h4><a class="header" href="#searching-for-divisors" id="searching-for-divisors">Searching for divisors</a></h4>
<p>Since ancient times, mathematicians have been fascinated by problems concerning prime numbers, and many people have worked on the problem of determining ways to test if numbers are prime. One way to test if a number is prime is to find the number's divisors. The following program finds the smallest integral divisor (greater than 1) of a given number $$n$$. It does this in a straightforward way, by testing $$n$$ for divisibility by successive integers starting with 2.</p>
<pre><code class="language-lisp">(defun smallest-divisor (n)
  (find-divisor n 2))

(defun find-divisor (n test-divisor)
  (cond ((&gt; (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        ('true (find-divisor n (+ test-divisor 1)))))

(defun divides? (a b)
  (== (rem b a) 0))
</code></pre>
<p>We can test whether a number is prime as follows: n is prime if and only if n is its own smallest divisor.</p>
<pre><code class="language-lisp">(defun prime? (n)
  (== n (smallest-divisor n)))
</code></pre>
<p>The end test for <code>find-divisor/2</code> is based on the fact that if $$n$$ is not prime it must have a divisor less than or equal to $$\sqrt n$$.<sup class="footnote-reference"><a href="#1">1</a></sup> This means that the algorithm need only test divisors between 1 and $$\sqrt n$$. Consequently, the number of steps required to identify $$n$$ as prime will have order of growth $$\Theta(\sqrt n)$$.</p>
<h4><a class="header" href="#the-fermat-test" id="the-fermat-test">The Fermat test</a></h4>
<p>The $$\Theta(\log n)$$ primality test is based on a result from number theory known as Fermat's Little Theorem.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p><strong>Fermat's Little Theorem</strong>: If $$n$$ is a prime number and $$a$$ is any positive integer less than $$n$$, then $$a$$ raised to the $$n$$th power is congruent to a modulo $$n$$.</p>
<p>(Two numbers are said to be <em>congruent modulo</em> $$n$$ if they both have the same remainder when divided by $$n$$. The remainder of a number $$a$$ when divided by $$n$$ is also referred to as the <em>remainder of</em> $$a$$ <em>modulo</em> $$n$$, or simply as $$a$$ <em>modulo</em> $$n$$.)</p>
<p>If $$n$$ is not prime, then, in general, most of the numbers $$a \lt n$$ will not satisfy the above relation. This leads to the following algorithm for testing primality: Given a number $$n$$, pick a random number $$a \lt n$$ and compute the remainder of $$a^n$$ modulo $$n$$. If the result is not equal to $$a$$, then $$n$$ is certainly not prime. If it is $$a$$, then chances are good that $$n$$ is prime. Now pick another random number $$a$$ and test it with the same method. If it also satisfies the equation, then we can be even more confident that $$n$$ is prime. By trying more and more values of $$a$$, we can increase our confidence in the result. This algorithm is known as the Fermat test.</p>
<p>To implement the Fermat test, we need a function that computes the exponential of a number modulo another number:</p>
<pre><code class="language-lisp">(defun expmod (base exp m)
  (cond ((== exp 0) 1)
        ((even? exp)
         (rem (square (expmod base (/ exp 2) m))
              m))
        ('true
         (rem (* base (expmod base (- exp 1) m))
              m))))
</code></pre>
<p>This is very similar to the <code>fast-expt/2</code> function of the section <a href="ch1/">Exponentiation</a>. It uses successive squaring, so that the number of steps grows logarithmically with the exponent.<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<p>The Fermat test is performed by choosing at random a number $$a$$ between 1 and $$n - 1$$ inclusive and checking whether the remainder modulo $$n$$ of the $$n$$th power of $$a$$ is equal to $$a$$. The random number $$a$$ is chosen using the <code>uniform/1</code> function from the <code>random</code> module in the Erlang standard library. <code>uniform/1</code> returns a nonnegative integer between <code>1</code> and the provided input, inclusive; this is exactly what we need.</p>
<pre><code class="language-lisp">(defun fermat-test (n)
  (flet ((try-it (a)
           (== (expmod a n n) a)))
    (try-it (random:uniform (- n 1)))))
</code></pre>
<p>The following function runs the test a given number of times, as specified by a parameter. Its value is true if the test succeeds every time, and false otherwise.</p>
<pre><code class="language-lisp">(defun fast-prime? (n times)
  (cond ((== n 1) 'true)
        ((== times 0) 'true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        ('true 'false)))
</code></pre>
<h4><a class="header" href="#probabilistic-methods" id="probabilistic-methods">Probabilistic methods</a></h4>
<p>The Fermat test differs in character from most familiar algorithms, in which one computes an answer that is guaranteed to be correct. Here, the answer obtained is only probably correct. More precisely, if $$n$$ ever fails the Fermat test, we can be certain that $$n$$ is not prime. But the fact that $$n$$ passes the test, while an extremely strong indication, is still not a guarantee that $$n$$ is prime. What we would like to say is that for any number $$n$$, if we perform the test enough times and find that $$n$$ always passes the test, then the probability of error in our primality test can be made as small as we like.</p>
<p>Unfortunately, this assertion is not quite correct. There do exist numbers that fool the Fermat test: numbers $$n$$ that are not prime and yet have the property that $$a^n$$ is congruent to $$a$$ modulo $$n$$ for all integers $$a \lt n$$. Such numbers are extremely rare, so the Fermat test is quite reliable in practice.<sup class="footnote-reference"><a href="#4">4</a></sup> There are variations of the Fermat test that cannot be fooled. In these tests, as with the Fermat method, one tests the primality of an integer $$n$$ by choosing a random integer $$a \lt n$$ and checking some condition that depends upon $$n$$ and $$a$$. (See exercise 1.28 for an example of such a test.) On the other hand, in contrast to the Fermat test, one can prove that, for any $$n$$, the condition does not hold for most of the integers $$a \lt n$$ unless $$n$$ is prime. Thus, if $$n$$ passes the test for some random choice of $$a$$, the chances are better than even that $$n$$ is prime. If $$n$$ passes the test for two random choices of $$a$$, the chances are better than 3 out of 4 that $$n$$ is prime. By running the test with more and more randomly chosen values of $$a$$ we can make the probability of error as small as we like.</p>
<p>The existence of tests for which one can prove that the chance of error becomes arbitrarily small has sparked interest in algorithms of this type, which have come to be known as <em>probabilistic algorithms</em>. There is a great deal of research activity in this area, and probabilistic algorithms have been fruitfully applied to many fields.<sup class="footnote-reference"><a href="#5">5</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>If $$d$$ is a divisor of $$n$$, then so is $$\frac{n}{d}$$. But $$d$$ and $$\frac{n}{d}$$ cannot both be greater than $$\sqrt n$$.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Pierre de Fermat (1601-1665) is considered to be the founder of modern number theory. He obtained many important number-theoretic results, but he usually announced just the results, without providing his proofs. Fermat's Little Theorem was stated in a letter he wrote in 1640. The first published proof was given by Euler in 1736 (and an earlier, identical proof was discovered in the unpublished manuscripts of Leibniz). The most famous of Fermat's results -- known as Fermat's Last Theorem -- was jotted down in 1637 in his copy of the book <em>Arithmetic</em> (by the third-century Greek mathematician Diophantus) with the remark ``I have discovered a truly remarkable proof, but this margin is too small to contain it.'' Finding a proof of Fermat's Last Theorem became one of the most famous challenges in number theory. A complete solution was finally given in 1995 by Andrew Wiles of Princeton University.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>The reduction steps in the cases where the exponent $$e$$ is greater than 1 are based on the fact that, for any integers $$x$$, $$y$$, and $$m$$, we can find the remainder of $$x$$ times $$y$$ modulo $$m$$ by computing separately the remainders of $$x$$ modulo $$m$$ and $$y$$ modulo $$m$$, multiplying these, and then taking the remainder of the result modulo $$m$$. For instance, in the case where $$e$$ is even, we compute the remainder of $$b^{\frac{e}{2}}$$ modulo $$m$$, square this, and take the remainder modulo $$m$$. This technique is useful because it means we can perform our computation without ever having to deal with numbers much larger than $$m$$. (Compare exercise 1.25.)</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Numbers that fool the Fermat test are called Carmichael numbers, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a &quot;correct&quot; algorithm. Considering an algorithm to be inadequate for the first reason but not for the second illustrates the difference between mathematics and engineering.
<sup class="footnote-reference"><a href="#5">5</a></sup>: One of the most striking applications of probabilistic prime testing has been to the field of cryptography. Although it is now computationally infeasible to factor an arbitrary 200-digit number, the primality of such a number can be checked in a few seconds with the Fermat test. This fact forms the basis of a technique for constructing &quot;unbreakable codes&quot; suggested by Rivest, Shamir, and Adleman (1977). The resulting RSA algorithm has become a widely used technique for enhancing the security of electronic communications. Because of this and related developments, the study of prime numbers, once considered the epitome of a topic in &quot;pure&quot; mathematics to be studied only for its own sake, now turns out to have important practical applications to cryptography, electronic funds transfer, and information retrieval.</p>
</div>
<h3><a class="header" href="#exercises-7" id="exercises-7">Exercises</a></h3>
<h4><a class="header" href="#exercise-121" id="exercise-121">Exercise 1.21</a></h4>
<p>Use the <code>smallest-divisor/1</code> function to find the smallest divisor of each of the following numbers: 199, 1999, 19999.</p>
<h4><a class="header" href="#exercise-122" id="exercise-122">Exercise 1.22</a></h4>
<p>Most Lisp implementations include a primitive called <code>runtime</code> that returns an integer that specifies the amount of time the system has been running (measured, for example, in microseconds). Erlang has something similar, though a bit more specific: <code>timer:tc/1-3</code> are functions which execute functions, returning a tuple of elapsed microseconds and result of function call.</p>
<p>The following <code>timed-prime-test</code> function, when called with an integer <code>n</code> and times the function it uses to checks if <code>n</code> is prime. If <code>n</code> is prime, the function prints three asterisks followed by the amount of time used in performing the test. If <code>n</code> is not prime, it simply prints <code>n</code>.</p>
<pre><code class="language-lisp">(defun timed-prime-test (n)
  (let ((`#(,elapsed-time ,value) (timer:tc #'prime?/1 `(,n))))
    (report-prime elapsed-time value)))

(defun report-prime
  ((elapsed-time 'true)
    (io:format &quot;~p *** ~p~n&quot; `(,n ,elapsed-time)))
  ((elapsed-time 'false)
    (io:format &quot;~p~n&quot; `(,n))))
</code></pre>
<p>Using these functions, write a funtion <code>search-for-primes</code> that checks the primality of consecutive odd integers in a specified range. Use your function to find the three smallest primes larger than 1000; larger than 10,000; larger than 100,000; larger than 1,000,000. Note the time needed to test each prime. Since the testing algorithm has order of growth of $$\Theta(\sqrt n)$$, you should expect that testing for primes around 10,000 should take about $$\sqrt 10$$ times as long as testing for primes around 1000. Do your timing data bear this out? How well do the data for 100,000 and 1,000,000 support the $$\sqrt n$$ prediction? Is your result compatible with the notion that programs on your machine run in time proportional to the number of steps required for the computation?</p>
<h4><a class="header" href="#exercise-123" id="exercise-123">Exercise 1.23</a></h4>
<p>The <code>smallest-divisor/1</code> function shown at the start of the last section does lots of needless testing: After it checks to see if the number is divisible by 2 there is no point in checking to see if it is divisible by any larger even numbers. This suggests that the values used for <code>test-divisor</code> should not be 2, 3, 4, 5, 6, ..., but rather 2, 3, 5, 7, 9, .... To implement this change, define a function <code>next/1</code> that returns 3 if its input is equal to 2 and otherwise returns its input plus 2. Modify the <code>smallest-divisor</code> function to use <code>(next test-divisor)</code> instead of <code>(+ test-divisor 1)</code>. With <code>timed-prime-test/1</code> incorporating this modified version of <code>smallest-divisor/1</code>, run the test for each of the 12 primes found in exercise 1.22. Since this modification halves the number of test steps, you should expect it to run about twice as fast. Is this expectation confirmed? If not, what is the observed ratio of the speeds of the two algorithms, and how do you explain the fact that it is different from 2?</p>
<h4><a class="header" href="#exercise-124" id="exercise-124">Exercise 1.24</a></h4>
<p>Modify the <code>timed-prime-test/1</code> function of exercise 1.22 to use <code>fast-prime?/2</code> (the Fermat method), and test each of the 12 primes you found in that exercise. Since the Fermat test has $$\Theta(\log n)$$ growth, how would you expect the time to test primes near 1,000,000 to compare with the time needed to test primes near 1000? Do your data bear this out? Can you explain any discrepancy you find?</p>
<h4><a class="header" href="#exercise-125" id="exercise-125">Exercise 1.25</a></h4>
<p>Alyssa P. Hacker complains that we went to a lot of extra work in writing <code>expmod/3</code>. After all, she says, since we already know how to compute exponentials, we could have simply written</p>
<pre><code class="language-lisp">(defun expmod (base exp m)
  (rem (trunc (fast-expt base exp)) m))
</code></pre>
<p>Is she correct? Would this function serve as well for our fast prime tester? Explain.</p>
<h4><a class="header" href="#exercise-126" id="exercise-126">Exercise 1.26</a></h4>
<p>Louis Reasoner is having great difficulty doing exercise 1.24. His <code>fast-prime?/2</code> test seems to run more slowly than his <code>prime?/1</code> test. Louis calls his friend Eva Lu Ator over to help. When they examine Louis's code, Eva finds that he has rewritten the <code>expmod/3</code> function to use an explicit multiplication, rather than calling square:</p>
<pre><code class="language-lisp">(defun expmod (base exp m)
  (cond ((== exp 0) 1)
        ((even? exp)
         (rem (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
              m))
        ('true
         (rem (* base (expmod base (- exp 1) m))
              m))))
</code></pre>
<p>&quot;I don't see what difference that could make,&quot; says Louis. &quot;I do.&quot; says Eva. &quot;By writing the function like that, you have transformed the $$\Theta(\log n)$$ process into a $$\Theta(n)$$ process.&quot; Explain.</p>
<h4><a class="header" href="#exercise-127" id="exercise-127">Exercise 1.27</a></h4>
<p>Demonstrate that the Carmichael numbers listed in the <a href="ch1/example_testing_for_primality.html#fn_4">Carmichael footnote</a> really do fool the Fermat test. That is, write a function that takes an integer $$n$$ and tests whether $$a^n$$ is congruent to $$a$$ modulo n for every $$a&lt;n$$, and try your function on the given Carmichael numbers.</p>
<h4><a class="header" href="#exercise-128" id="exercise-128">Exercise 1.28</a></h4>
<p>One variant of the Fermat test that cannot be fooled is called the <em>Miller-Rabin test</em> (Miller 1976; Rabin 1980). This starts from an alternate form of Fermat's Little Theorem, which states that if $$n$$ is a prime number and $$a$$ is any positive integer less than $$n$$, then $$a$$ raised to the $$(n - 1)$$st power is congruent to 1 modulo $$n$$. To test the primality of a number $$n$$ by the Miller-Rabin test, we pick a random number $$a&lt;n$$ and raise $$a$$ to the $$(n - 1)$$st power modulo $$n$$ using the <code>expmod/3</code> function. However, whenever we perform the squaring step in <code>expmod/3</code>, we check to see if we have discovered a &quot;nontrivial square root of 1 modulo $$n$$,&quot; that is, a number not equal to 1 or $$n - 1$$ whose square is equal to 1 modulo $$n$$. It is possible to prove that if such a nontrivial square root of 1 exists, then $$n$$ is not prime. It is also possible to prove that if $$n$$ is an odd number that is not prime, then, for at least half the numbers $$a&lt;n$$, computing $$a^{n-1}$$ in this way will reveal a nontrivial square root of 1 modulo $$n$$. (This is why the Miller-Rabin test cannot be fooled.) Modify the <code>expmod/3</code> function to signal if it discovers a nontrivial square root of 1, and use this to implement the Miller-Rabin test with a function analogous to <code>fermat-test/1</code>. Check your function by testing various known primes and non-primes. Hint: One convenient way to make <code>expmod/3</code> signal is to have it return 0.</p>
<h2><a class="header" href="#formulating-abstractions-with-higher-order-functions" id="formulating-abstractions-with-higher-order-functions">Formulating Abstractions with Higher-Order Functions</a></h2>
<p>We have seen that functions are, in effect, abstractions that describe compound operations on numbers independent of the particular numbers. For example, when we</p>
<pre><code class="language-lisp">(defun cube (x) (* x x x))
</code></pre>
<p>we are not talking about the cube of a particular number, but rather about a method for obtaining the cube of any number. Of course we could get along without ever defining this function, by always writing expressions such as</p>
<pre><code class="language-lisp">(* 3 3 3)
(* x x x)
(* y y y)
</code></pre>
<p>and never mentioning <code>cube/1</code> explicitly. This would place us at a serious disadvantage, forcing us to work always at the level of the particular operations that happen to be primitives in the language (multiplication, in this case) rather than in terms of higher-level operations. Our programs would be able to compute cubes, but our language would lack the ability to express the concept of cubing. One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the abstractions directly. Functions provide this ability. This is why all but the most primitive programming languages include mechanisms for defining functions.</p>
<p>Yet even in numerical processing we will be severely limited in our ability to create abstractions if we are restricted to functions whose parameters must be numbers. Often the same programming pattern will be used with a number of different functions. To express such patterns as concepts, we will need to construct functions that can accept functions as arguments or return functions as values. Functions that manipulate functions are called <em>higher-order functions</em>. This section shows how higher-order functionsp can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.</p>
<h3><a class="header" href="#functions-as-arguments" id="functions-as-arguments">Functions as Arguments</a></h3>
<p>Consider the following three functions. The first computes the sum of the integers from a through b:</p>
<pre><code class="language-lisp">(defun sum-integers (a b)
  (if (&gt; a b)
      0
      (+ a (sum-integers (+ a 1) b))))
</code></pre>
<p>The second computes the sum of the cubes of the integers in the given range:</p>
<pre><code class="language-lisp">(defun sum-cubes (a b)
  (if (&gt; a b)
      0
      (+ (cube a) (sum-cubes (+ a 1) b))))
</code></pre>
<p>The third computes the sum of a sequence of terms in the series</p>
<p>$$
\begin{align}
\frac{1}{1 \cdot 3} + \frac{1}{5 \cdot 7} + \frac{1}{9 \cdot 11} + \dots
\end{align}
$$</p>
<p>which converges to $$\frac{\pi}{8}$$ (very slowly):<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<pre><code class="language-lisp">(defun pi-sum (a b)
  (if (&gt; a b)
      0
      (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))
</code></pre>
<p>These three functions clearly share a common underlying pattern. They are for the most part identical, differing only in the name of the function, the function of <code>a</code> used to compute the term to be added, and the function that provides the next value of <code>a</code>. We could generate each of the functions by filling in slots in the same template:</p>
<pre><code class="language-lisp">(defun &lt;name&gt; (a b)
  (if (&gt; a b)
      0
      (+ (&lt;term&gt; a)
         (&lt;name&gt; (&lt;next&gt; a) b))))
</code></pre>
<p>The presence of such a common pattern is strong evidence that there is a useful abstraction waiting to be brought to the surface. Indeed, mathematicians long ago identified the abstraction of summation of a series and invented &quot;sigma notation,&quot; for example</p>
<p>$$
\begin{align}
\sum_{n=a}^{b} f(n) = f(a) + \dots + f(b)
\end{align}
$$</p>
<p>to express this concept. The power of sigma notation is that it allows mathematicians to deal with the concept of summation itself rather than only with particular sums -- for example, to formulate general results about sums that are independent of the particular series being summed.</p>
<p>Similarly, as program designers, we would like our language to be powerful enough so that we can write a function that expresses the concept of summation itself rather than only functions that compute particular sums. We can do so readily in our procedural language by taking the common template shown above and transforming the &quot;slots&quot; into formal parameters:</p>
<pre><code class="language-lisp">(defun sum (term a next b)
  (if (&gt; a b)
      0
      (+ (funcall term a)
         (sum term (funcall next a) next b))))
</code></pre>
<p>Notice that <code>sum/4</code> takes as its arguments the lower and upper bounds <code>a</code> and <code>b</code> together with the functions <code>term</code> and <code>next</code>. We can use <code>sum/4</code> just as we would any function. For example, we can use it (along with a function <code>inc/1</code> that increments its argument by 1) to define <code>sum-cubes/4</code>:</p>
<pre><code class="language-lisp">(defun inc (n) (+ n 1))

(defun sum-cubes (a b)
  (sum #'cube/1 a #'inc/1 b))
</code></pre>
<p>Using this, we can compute the sum of the cubes of the integers from 1 to 10:</p>
<pre><code class="language-lisp">&gt; (sum-cubes 1 10)
3025
</code></pre>
<p>With the aid of an identity function to compute the term, we can define <code>sum-integers</code> in terms of <code>sum</code>:</p>
<pre><code class="language-lisp">(defun identity (x) x)

(defun sum-integers (a b)
  (sum #'identity/1 a #'inc/1 b))
</code></pre>
<p>Then we can add up the integers from 1 to 10:</p>
<pre><code class="language-lisp">&gt; (sum-integers 1 10)
55
</code></pre>
<p>We can also define pi-sum in the same way:<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<pre><code class="language-lisp">(defun pi-sum (a b)
  (flet ((pi-term (x)
           (/ 1.0 (* x (+ x 2))))
         (pi-next (x)
           (+ x 4)))
    (sum #'pi-term/1 a #'pi-next/1 b)))
</code></pre>
<p>Using these functions, we can compute an approximation to $$\pi$$:</p>
<pre><code class="language-lisp">&gt; (* 8 (pi-sum 1 100000))
3.141572653589795
</code></pre>
<p>Once we have <code>sum/4</code>, we can use it as a building block in formulating further concepts. For instance, the definite integral of a function $$f$$ between the limits $$a$$ and $$b$$ can be approximated numerically using the formula</p>
<p>$$
\begin{align}
\int_a^b f = \left[
f\left(a + \frac{dx}{2} \right) +
f\left(a + dx + \frac{dx}{2} \right) +
f\left(a + 2dx + \frac{dx}{2} \right) + \dots
\right] dx
\end{align}
$$</p>
<p>for small values of $$dx$$. We can express this directly as a function:</p>
<pre><code class="language-lisp">(defun integral (f a b dx)
  (flet ((add-dx (x)
           (+ x dx)))
    (* (sum f (+ a (/ dx 2.0)) #'add-dx/1 b)
       dx)))
</code></pre>
<pre><code class="language-lisp">&gt; (integral #'cube/1 0 1 0.01)
0.24998750000000042
&gt; (integral #'cube/1 0 1 0.001)
0.249999875000001
&gt; (integral #'cube/1 0 1 0.0001)
0.24999999874993412
</code></pre>
<p>(The exact value of the integral of cube between 0 and 1 is 1/4.)</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This series, usually written in the equivalent form $$\frac{\pi}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \dots $$, is due to Leibniz. We'll see how to use this as the basis for some fancy numerical tricks in the section <a href="ch1/">Exploiting the Stream Paradigm</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Notice that we have used <code>flet</code>s (from the section <a href="ch1/">Functions as Black-Box Abstractions</a>) to embed the definitions of <code>pi-next/1</code> and <code>pi-term/1</code> within <code>pi-sum/2</code>, since these functions are unlikely to be useful for any other purpose. We will learn more about how these work when we get to the section <a href="ch1/">Constructing Functions Using Lambda</a>.</p>
</div>
<h3><a class="header" href="#exercises-8" id="exercises-8">Exercises</a></h3>
<h4><a class="header" href="#exercise-129" id="exercise-129">Exercise 1.29</a></h4>
<p>Simpson's Rule is a more accurate method of numerical integration than the method illustrated above. Using Simpson's Rule, the integral of a function f between a and b is approximated as</p>
<p>$$
\begin{align}
\frac{h}{3}
\left[
y_0 + 4y_1 + 2y_2 + 4y_3 + \dots + 2y_{n-2} + 4y_{n-1} + y_n
\right]
\end{align}
$$</p>
<p>where $$h = \frac{b - a}{n}$$ for some integer $$n$$, and $$y_k = f(a + kh)$$.
Increasing $$n$$ increases the accuracy of the approximation.) Define a function that takes as arguments $$f$$, $$a$$, $$b$$, and $$n$$ and returns the value of the integral, computed using Simpson's Rule. Use your function to integrate <code>cube/4</code> between 0 and 1 (with $$n $$= 100 and $$n$$ = 1000), and compare the results to those of the <code>integral/4</code> function shown in the previous section.</p>
<h4><a class="header" href="#exercise-130" id="exercise-130">Exercise 1.30</a></h4>
<p>The <code>sum/4</code> function from the previous section generates a linear recursion. The function can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:</p>
<pre><code class="language-lisp">(defun sum (term a next b)
  (flet ((iter (a result)
    (if &lt;??&gt;
        &lt;??&gt;
        (iter &lt;??&gt; &lt;??&gt;))))
    (iter &lt;??&gt; &lt;??&gt;)))
</code></pre>
<h4><a class="header" href="#exercise-131" id="exercise-131">Exercise 1.31</a></h4>
<p>a.  The <code>sum/4</code> function is only the simplest of a vast number of similar abstractions that can be captured as higher-order functions.<sup class="footnote-reference"><a href="#1">1</a></sup> Write an analogous function called <code>product</code> that returns the product of the values of a function at points over a given range. Show how to define <code>factorial</code> in terms of <code>product</code>. Also use <code>product</code> to compute approximations to $$\pi$$ using the formula <sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p>$$
\begin{align}
\frac{\pi}{4} =
\frac{ 2 \cdot 4 \cdot 4 \cdot 6 \cdot 6 \cdot 8 \dots}
{ 3 \cdot 3 \cdot 5 \cdot 5 \cdot 7 \cdot 7 \dots}
\end{align}
$$</p>
<p>b. If your <code>product</code> function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p>
<h4><a class="header" href="#exercise-132" id="exercise-132">Exercise 1.32</a></h4>
<p>a. Show that <code>sum/4</code> and <code>product</code> (exercise 1.31) are both special cases of a still more general notion called <code>accumulate/6</code> that combines a collection of terms, using some general accumulation function:</p>
<pre><code class="language-lisp">(accumulate combiner null-value term a next b)
</code></pre>
<p><code>accumulate/6</code> takes as arguments the same term and range specifications as sum and <code>product</code>, together with a <code>combiner</code> function (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a <code>null-value</code> that specifies what base value to use when the terms run out. Write <code>accumulate/6</code> and show how <code>sum</code> and <code>product</code> can both be defined as simple calls to <code>accumulate/6</code>.</p>
<p>b. If your <code>accumulate/6</code> function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p>
<h4><a class="header" href="#exercise-133" id="exercise-133">Exercise 1.33</a></h4>
<p>You can obtain an even more general version of <code>accumulate/6</code> (exercise 1.32) by introducing the notion of a <em>filter</em> on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting <code>filtered-accumulate/7</code> abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write <code>filtered-accumulate/7</code> as a function. Show how to express the following using <code>filtered-accumulate/7</code>:</p>
<p>a. the sum of the squares of the prime numbers in the interval $$a$$ to $$b$$ (assuming that you have a <code>prime?/1</code> predicate already written)</p>
<p>b. the product of all the positive integers less than $$n$$ that are relatively prime to $$n$$ (i.e., all positive integers $$i &lt; n$$ such that $$\text{GCD}(i,n) = 1$$).</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The intent of exercises 1.31, 1.32, and 1.33 is to demonstrate the expressive power that is attained by using an appropriate abstraction to consolidate many seemingly disparate operations. However, though accumulation and filtering are elegant ideas, our hands are somewhat tied in using them at this point since we do not yet have data structures to provide suitable means of combination for these abstractions. We will return to these ideas in the section <a href="ch1/">equences as Conventional Interfaces</a> when we show how to use <em>sequences</em> as interfaces for combining filters and accumulators to build even more powerful abstractions. We will see there how these methods really come into their own as a powerful and elegant approach to designing programs.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This formula was discovered by the seventeenth-century English mathematician John Wallis.</p>
</div>
<h3><a class="header" href="#constructing-functions-using-lambda" id="constructing-functions-using-lambda">Constructing Functions Using Lambda</a></h3>
<p>In using <code>pi-sum/2</code> as in the section <a href="ch1/">Functions as Arguments</a>, it seems terribly awkward to have to define trivial <code>flet</code> functions such as <code>pi-term/1</code> and <code>pi-next/1</code> just so we can use them as arguments to our higher-order function. Rather than define <code>pi-next/1</code> and <code>pi-term/1</code>, it would be more convenient to have a way to directly specify &quot;the function that returns its input incremented by 4&quot; and &quot;the function that returns the reciprocal of its input times its input plus 2.&quot; We can do this by introducing the special form <code>lambda</code>, which creates functions. Using lambda we can describe what we want as</p>
<pre><code class="language-lisp">(lambda (x) (+ x 4))
</code></pre>
<p>and</p>
<pre><code class="language-lisp">(lambda (x) (/ 1.0 (* x (+ x 2))))
</code></pre>
<p>Then our <code>pi-sum/2</code> function can be expressed (without defining any auxiliary functions in an <code>flet</code>) as</p>
<pre><code class="language-lisp">(defun pi-sum (a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
</code></pre>
<p>Again using <code>lambda</code>, we can write the <code>integral/4</code> function without having to define the auxiliary function <code>add-dx/1</code>:</p>
<pre><code class="language-lisp">(defun integral (f a b dx)
  (* (sum f
          (+ a (/ dx 2.0))
          (lambda (x) (+ x dx))
          b)
     dx))
</code></pre>
<p>In general, lambda is used to create functions in the same way as <code>defun</code>, except that no name is specified for the function:</p>
<pre><code class="language-lisp">(lambda (&lt;formal-parameters&gt;) &lt;body&gt;)
</code></pre>
<p>The resulting function is just as much a function as one that is created using define. The only difference is that it has not been associated with any name in the environment.</p>
<p>We can read a lambda expression as follows:</p>
<pre><code class="language-lisp">   (lambda             (x)            (+     x       4))
      ^                 ^              ^     ^       ^
      |                 |              |     |       |
 the function   of an argument x  that adds  x  and  4
</code></pre>
<p>Like any expression that has a function as its value, a <code>lambda</code> expression can be used as the operator in a combination such as</p>
<pre><code class="language-lisp">&gt; (apply (lambda (x y z) (+ x y (square z))) '(1 2 3))
12
</code></pre>
<p>or, more generally, in any context where we would normally use a function name.<sup class="footnote-reference"><a href="#1">1</a></sup> For example, if we defined the <code>lambda</code> expression above as a function</p>
<pre><code class="language-lisp">(defun add-sq (x y z)
  (+ x y (square z)))
</code></pre>
<p>we would apply it the same way as we did the <code>lambda</code> expression:</p>
<pre><code class="language-lisp">&gt; (apply #'add-sq/3 '(1 2 3))
12
</code></pre>
<h4><a class="header" href="#using-let-to-create-local-variables" id="using-let-to-create-local-variables">Using <code>let</code> to create local variables</a></h4>
<p>Another use of <code>lambda</code> is in creating local variables. We often need local variables in our functions other than those that have been bound as formal parameters. For example, suppose we wish to compute the function</p>
<p>$$
\begin{align}
f(x, y) = x(1 + xy)^2 + y(1 -y) + (1 + xy)(1 - y)
\end{align}
$$</p>
<p>which we could also express as</p>
<p>$$
\begin{align}
a = &amp; \ 1 + xy \
b = &amp; \ 1 - y \
f(x, y) = &amp; \ ra^2 + yb + ab.
\end{align}
$$</p>
<p>In writing a function to compute $$f$$, we would like to include as local variables not only $$x$$ and $$y$$ but also the names of intermediate quantities like $$a$$ and $$b$$. One way to accomplish this is to use an auxiliary function to bind the local variables:</p>
<pre><code class="language-lisp">(defun f (x y)
  (flet ((f-helper (a b)
          (+ (* x (square a))
             (* y b)
             (* a b))))
    (f-helper (+ 1 (* x y))
              (- 1 y))))
</code></pre>
<p>Of course, we could use a <code>lambda</code> expression to specify an anonymous function for binding our local variables. The body of <code>f</code> then becomes a single call to that function:</p>
<pre><code class="language-lisp">(defun f (x y)
  (funcall
    (lambda (a b)
      (+ (* x (square a))
         (* y b)
         (* a b)))
    (+ 1 (* x y))
    (- 1 y)))
</code></pre>
<p>This construct is so useful that there is a special form called <code>let</code> to make its use more convenient. Using <code>let</code>, the <code>f/2</code> function could be written as</p>
<pre><code class="language-lisp">(defun f (x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
</code></pre>
<p>The general form of a <code>let</code> expression is</p>
<pre><code class="language-lisp">(let ((&lt;var-1&gt; &lt;exp-1&gt;)
      (&lt;var-2&gt; &lt;exp-2&gt;)
      ...
      (&lt;var-n&gt; &lt;exp-n&gt;))
   &lt;body&gt;)
</code></pre>
<p>which can be thought of as saying</p>
<ul>
<li>Let <code>&lt;var-1&gt;</code> have the value <code>&lt;exp-1&gt;</code> and</li>
<li>Let <code>&lt;var-2&gt;</code> have the value <code>&lt;exp-2&gt;</code> and</li>
<li>... and</li>
<li>Let <code>&lt;var-n&gt;</code> have the value <code>&lt;exp-n&gt;</code></li>
<li>All in the context of <code>&lt;body&gt;</code></li>
</ul>
<p>The first part of the <code>let</code> expression is a list of name-expression pairs. When the <code>let</code> is evaluated, each name is associated with the value of the corresponding expression. The body of the <code>let</code> is evaluated with these names bound as local variables. The way this happens is that the <code>let</code> expression is interpreted as an alternate syntax for</p>
<pre><code class="language-lisp">(funcall
  (lambda (&lt;var-1&gt; ... &lt;var-n&gt;)
    &lt;body&gt;)
   &lt;exp-1&gt;
   ...
   &lt;exp-n&gt;)
</code></pre>
<p>No new mechanism is required in the interpreter in order to provide local variables. A <code>let</code> expression is simply syntactic sugar for the underlying <code>lambda</code> application.</p>
<p>We can see from this equivalence that the scope of a variable specified by a <code>let</code> expression is the body of the <code>let</code>. This implies that:</p>
<ul>
<li>
<p><code>let</code> allows one to bind variables as locally as possible to where they are to be used. For example, if the value of <code>x</code> is 5, the value of the expression</p>
<pre><code class="language-lisp">(+ (let ((x 3))
   (+ x (* x 10)))
 x)
</code></pre>
<p>is 38. Here, the <code>x</code> in the body of the <code>let</code> is 3, so the value of the let expression is 33. On the other hand, the <code>x</code> that is the second argument to the outermost <code>+</code> is still 5.</p>
</li>
<li>
<p>The variables' values are computed outside the <code>let</code>. This matters when the expressions that provide the values for the local variables depend upon variables having the same names as the local variables themselves. For example, if the value of <code>x</code> is 2, the expression</p>
<pre><code class="language-lisp">(let ((x 3)
    (y (+ x 2)))
(* x y))
</code></pre>
<p>will have the value 12 because, inside the body of the <code>let</code>, <code>x</code> will be 3 and <code>y</code> will be 4 (which is the outer <code>x</code> plus 2).</p>
</li>
</ul>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>It would be clearer and less intimidating to people learning Lisp if a name more obvious than <code>lambda</code>, such as <code>make-function</code>, were used. But the convention is firmly entrenched. The notation is adopted from the $$\lambda$$ calculus, a mathematical formalism introduced by the mathematical logician Alonzo Church (1941). Church developed the $$\lambda$$ calculus to provide a rigorous foundation for studying the notions of function and function application. The $$\lambda$$ calculus has become a basic tool for mathematical investigations of the semantics of programming languages.</p>
</div>
<h3><a class="header" href="#exercises-9" id="exercises-9">Exercises</a></h3>
<h4><a class="header" href="#exercise-134" id="exercise-134">Exercise 1.34</a></h4>
<p>Suppose we define the function</p>
<pre><code class="language-lisp">(defun f (g)
  (funcall g 2))
</code></pre>
<p>Then we have</p>
<pre><code class="language-lisp">&gt; (f #'square/1)
4
&gt; (f (lambda (z) (* z (+ z 1))))
6
</code></pre>
<p>What happens if we (perversely) ask the interpreter to evaluate the combination <code>(f #'f/1)</code>? Explain.</p>
<h3><a class="header" href="#functions-as-general-methods" id="functions-as-general-methods">Functions as General Methods</a></h3>
<p>We introduced compound functions in the section <a href="ch1/">Compound Functions</a> as a mechanism for abstracting patterns of numerical operations so as to make them independent of the particular numbers involved. With higher-order functions, such as the <code>integral/4</code> function of the section <a href="ch1/">Functions as Arguments</a>, we began to see a more powerful kind of abstraction: functions used to express general methods of computation, independent of the particular functions involved. In this section we discuss two more elaborate examples -- general methods for finding zeros and fixed points of functions -- and show how these methods can be expressed directly as functions.</p>
<h4><a class="header" href="#finding-roots-of-equations-by-the-half-interval-method" id="finding-roots-of-equations-by-the-half-interval-method">Finding roots of equations by the half-interval method</a></h4>
<p>The <em>half-interval method</em> is a simple but powerful technique for finding roots of an equation $$f(x) = 0$$, where $$f$$ is a continuous function. The idea is that, if we are given points $$a$$ and $$b$$ such that $$f(a) &lt; 0 &lt; f(b)$$, then $$f$$ must have at least one zero between $$a$$ and $$b$$. To locate a zero, let $$x$$ be the average of $$a$$ and $$b$$ and compute $$f(x)$$. If $$f(x) &gt; 0$$, then $$f$$ must have a zero between $$a$$ and $$x$$. If $$f(x) &lt; 0$$, then $$f$$ must have a zero between $$x$$ and $$b$$. Continuing in this way, we can identify smaller and smaller intervals on which $$f$$ must have a zero. When we reach a point where the interval is small enough, the process stops. Since the interval of uncertainty is reduced by half at each step of the process, the number of steps required grows as $$\Theta(log( L/T))$$, where $$L$$ is the length of the original interval and $$T$$ is the error tolerance (that is, the size of the interval we will consider &quot;small enough&quot;). Here is a function that implements this strategy:</p>
<pre><code class="language-lisp">(defun negative? (x)
  (&lt; x 0))

(defun positive? (x)
  (&gt; x 0))

(defun search (f neg-point pos-point)
  (let ((midpoint (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (funcall f midpoint)))
          (cond ((positive? test-value)
                 (search f neg-point midpoint))
                ((negative? test-value)
                 (search f midpoint pos-point))
                (else midpoint))))))
</code></pre>
<p>We assume that we are initially given the function $$f$$ together with points at which its values are negative and positive. We first compute the midpoint of the two given points. Next we check to see if the given interval is small enough, and if so we simply return the midpoint as our answer. Otherwise, we compute as a test value the value of $$f$$ at the midpoint. If the test value is positive, then we continue the process with a new interval running from the original negative point to the midpoint. If the test value is negative, we continue with the interval from the midpoint to the positive point. Finally, there is the possibility that the test value is 0, in which case the midpoint is itself the root we are searching for.</p>
<p>To test whether the endpoints are &quot;close enough&quot; we can use a function similar to the one used in the section <a href="ch1/">Example: Square Roots by Newton's Method</a> for computing square roots:<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<pre><code class="language-lisp">(defun close-enough? (x y)
  (&lt; (abs (- x y)) 0.001))
</code></pre>
<p><code>search/3</code> is awkward to use directly, because we can accidentally give it points at which $$f$$'s values do not have the required sign, in which case we get a wrong answer. Instead we will use <code>search/3</code> via the following function, which checks to see which of the endpoints has a negative function value and which has a positive value, and calls the <code>search/3</code> function accordingly. If the function has the same sign on the two given points, the half-interval method cannot be used, in which case the function signals an error.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<pre><code class="language-lisp">
(defun half-interval-method (f a b)
  (let ((a-value (funcall f a))
        (b-value (funcall f b)))
    (cond ((and (negative? a-value) (positive? b-value))
           (search f a b))
          ((and (negative? b-value) (positive? a-value))
           (search f b a))
          (else
           (error &quot;Values are not of opposite sign&quot;)))))
</code></pre>
<p>The following example uses the half-interval method to approximate $$\pi$$ as the root between 2 and 4 of $$sin x = 0$$:</p>
<pre><code class="language-lisp">&gt; (half-interval-method #'math:sin/1 2.0 4.0)
3.14111328125
</code></pre>
<p>Here is another example, using the half-interval method to search for a root of the equation $$x^3 - 2x - 3 = 0$$ between 1 and 2:</p>
<pre><code class="language-lisp">&gt; (half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                        1.0
                        2.0)
1.89306640625
</code></pre>
<h4><a class="header" href="#finding-fixed-points-of-functions" id="finding-fixed-points-of-functions">Finding fixed points of functions</a></h4>
<p>A number $$x$$ is called a <em>fixed point</em> of a function $$f$$ if $$x$$ satisfies the equation $$f(x) = x$$. For some functions $$f$$ we can locate a fixed point by beginning with an initial guess and applying $$f$$ repeatedly,</p>
<p>$$
\begin{align}
f(x),f(f(x)), f(f(f(x))), \dots
\end{align}
$$</p>
<p>until the value does not change very much. Using this idea, we can devise a function <code>fixed-point/2</code> that takes as inputs a function and an initial guess and produces an approximation to a fixed point of the function. We apply the function repeatedly until we find two successive values whose difference is less than some prescribed tolerance:</p>
<pre><code class="language-lisp">(defun fixed-point (f first-guess)
  (fletrec ((close-enough? (v1 v2)
              (&lt; (abs (- v1 v2)) tolerance))
            (try-it (guess)
              (let ((next (funcall f guess)))
                (if (close-enough? guess next)
                    next
                    (try-it next)))))
    (try-it first-guess)))
</code></pre>
<p>For example, we can use this method to approximate the fixed point of the cosine function, starting with 1 as an initial approximation:<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<pre><code class="language-lisp">&gt; (set tolerance 0.00001)
1.0e-5
&gt; (fixed-point #'math:cos/1 1.0)
0.7390822985224023
</code></pre>
<p>Similarly, we can find a solution to the equation $$y = \sin y + \cos y$$:</p>
<pre><code class="language-lisp">&gt; (fixed-point (lambda (y) (+ (math:sin y) (math:cos y)))
               1.0)
1.2587315962971173
</code></pre>
<p>The fixed-point process is reminiscent of the process we used for finding square roots in the section <a href="ch1/">Example: Square Roots by Newton's Method</a>. Both are based on the idea of repeatedly improving a guess until the result satisfies some criterion. In fact, we can readily formulate the square-root computation as a fixed-point search. Computing the square root of some number $$x$$ requires finding a $$y$$ such that $$y^2 = x$$. Putting this equation into the equivalent form $$y = \frac{x}{y}$$, we recognize that we are looking for a fixed point of the function<sup class="footnote-reference"><a href="#4">4</a></sup> $$y \mapsto \frac{x}{y}$$, and we can therefore try to compute square roots as</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (fixed-point (lambda (y) (/ x y))
               1.0))
</code></pre>
<p>Unfortunately, this fixed-point search does not converge. Consider an initial guess $$y_1$$. The next guess is $$y_2 = x/y1$$ and the next guess is $$y_3 = x/y2 = x/(x/y1) = y_1$$. This results in an infinite loop in which the two guesses $$y_1$$ and $$y_2$$ repeat over and over, oscillating about the answer.</p>
<p>One way to control such oscillations is to prevent the guesses from changing so much. Since the answer is always between our guess $$y$$ and $$\frac{x}{y}$$, we can make a new guess that is not as far from $$y$$ as $$\frac{x}{y}$$ by averaging $$y$$ with $$\frac{x}{y}$$, so that the next guess after $$y$$ is $$\frac{y + \frac{x}{y}}{2}$$ instead of $$\frac{x}{y}$$. The process of making such a sequence of guesses is simply the process of looking for a fixed point of $$y \mapsto \frac{y + \frac{x}{y}}{2}$$:</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (fixed-point (lambda (y) (average y (/ x y)))
               1.0))
</code></pre>
<p>(Note that $$y = \frac{y + \frac{x}{y}}{2}$$ is a simple transformation of the equation $$y = \frac{x}{y}$$; to derive it, add $$y$$ to both sides of the equation and divide by 2.)</p>
<p>With this modification, the square-root function works. In fact, if we unravel the definitions, we can see that the sequence of approximations to the square root generated here is precisely the same as the one generated by our original square-root function of the section <a href="ch1/">Example: Square Roots by Newton's Method</a>. This approach of averaging successive approximations to a solution, a technique we that we call <em>average damping</em>, often aids the convergence of fixed-point searches.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>We have used 0.001 as a representative &quot;small&quot; number to indicate a tolerance for the acceptable error in a calculation. The appropriate tolerance for a real calculation depends upon the problem to be solved and the limitations of the computer and the algorithm. This is often a very subtle consideration, requiring help from a numerical analyst or some other kind of magician.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This can be accomplished using <code>error/1</code>, which takes a &quot;reason&quot; as an argument and stops the execution of the calling process with with an exception error and the provided reason.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Try this during a boring lecture: Set your calculator to radians mode and then repeatedly press the <code>cos</code> button until you obtain the fixed point.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>$$\mapsto$$ (pronounced &quot;maps to&quot;) is the mathematician's way of writing <code>lambda</code>. $$y \mapsto \frac{x}{y}$$ means <code>(lambda(y) (/ x y))</code>, that is, the function whose value at $$y$$ is $$\frac{x}{y}$$.</p>
</div>
<h3><a class="header" href="#exercises-10" id="exercises-10">Exercises</a></h3>
<h4><a class="header" href="#exercise-135" id="exercise-135">Exercise 1.35</a></h4>
<p>Show that the golden ratio $$\phi$$ (the section <a href="ch1/">Tree Recursion</a>) is a fixed point of the transformation $$x \mapsto 1 + \frac{1}{x}$$, and use this fact to compute $$\phi$$ by means of the <code>fixed-point/2</code> function.</p>
<h4><a class="header" href="#exercise-136" id="exercise-136">Exercise 1.36</a></h4>
<p>Modify <code>fixed-point/2</code> so that it prints the sequence of approximations it generates, using <code>io:format</code> as shown in exercise 1.22. Then find a solution to $$x^x = 1000$$ by finding a fixed point of $$x \mapsto \frac{log(1000)}{log(x)}$$. (Use Erlang's <code>math:log</code> function, which computes natural logarithms.) Compare the number of steps this takes with and without average damping. (Note that you cannot start <code>fixed-point/2</code> with a guess of 1, as this would cause division by $$log(1) = 0 $$.)</p>
<h4><a class="header" href="#exercise-137" id="exercise-137">Exercise 1.37</a></h4>
<p>a. An infinite <em>continued fraction</em> is an expression of the form</p>
<p>$$
\begin{align}
f= \frac{N_1}{D_1 + \frac{N_2}{D_2 + \frac{N_3}{D_3 + \cdots}}}
\end{align}
$$</p>
<p>As an example, one can show that the infinite continued fraction expansion with the $$N_i$$ and the $$D_i$$ all equal to 1 produces $$frac{1}{\phi}$$, where $$\phi$$ is the golden ratio (described in the section <a href="ch1/">Tree Recursion</a>]). One way to approximate an infinite continued fraction is to truncate the expansion after a given number of terms. Such a truncation -- a so-called <em>k-term finite continued fraction</em> -- has the form</p>
<p>$$
\begin{align}
\frac{N_1}{D_1 + \frac{N_2}{\ddots + \frac{N_K}{D_K}}}
\end{align}
$$</p>
<p>Suppose that <code>n</code> and <code>d</code> are functions of one argument (the term index $$i$$) that return the $$N_i$$ and $$D_i$$ of the terms of the continued fraction. Define a function <code>cont-frac/3</code> such that evaluating <code>(cont-frac n d k)</code> computes the value of the $$k$$-term finite continued fraction. Check your function by approximating $$\frac{1}{\phi}$$ using</p>
<pre><code class="language-lisp">(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
</code></pre>
<p>for successive values of <code>k</code>. How large must you make <code>k</code> in order to get an approximation that is accurate to 4 decimal places?</p>
<p>b. If your <code>cont-frac/3</code> function generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</p>
<h4><a class="header" href="#exercise-138" id="exercise-138">Exercise 1.38</a></h4>
<p>In 1737, the Swiss mathematician Leonhard Euler published a memoir <em>De Fractionibus Continuis</em>, which included a continued fraction expansion for $$e - 2$$, where $$e$$ is the base of the natural logarithms. In this fraction, the $$N_i$$ are all 1, and the $$D_i$$ are successively $$1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, \cdot $$. Write a program that uses your <code>cont-frac/3</code> function from exercise 1.37 to approximate $$e$$, based on Euler's expansion.</p>
<h4><a class="header" href="#exercise-139" id="exercise-139">Exercise 1.39</a></h4>
<p>A continued fraction representation of the tangent function was published in 1770 by the German mathematician J.H. Lambert:</p>
<p>$$
\begin{align}
\tan r = \frac{r}{1 - \frac{r^2}{3 - \frac{r^2}{5 - \ddots}}}
\end{align}
$$</p>
<p>where $$x$$ is in radians. Define a function <code>(tan-cf x k)</code> that computes an approximation to the tangent function based on Lambert's formula. <code>k</code> specifies the number of terms to compute, as in exercise 1.37.</p>
<h3><a class="header" href="#functions-as-returned-values" id="functions-as-returned-values">Functions as Returned Values</a></h3>
<p>The previous examples demonstrate how the ability to pass functions as arguments significantly enhances the expressive power of our programming language. We can achieve even more expressive power by creating functions whose returned values are themselves functions.</p>
<p>We can illustrate this idea by looking again at the fixed-point example described at the end of the section <a href="ch1/">Functions as General Methods</a>. We formulated a new version of the square-root function as a fixed-point search, starting with the observation that $$\sqrt x$$ is a fixed-point of the function $$y \mapsto \frac{x}{y}$$. Then we used average damping to make the approximations converge. Average damping is a useful general technique in itself. Namely, given a function $$f$$, we consider the function whose value at $$x$$ is equal to the average of $$x$$ and $$f(x)$$.</p>
<p>We can express the idea of average damping by means of the following function:</p>
<pre><code class="language-lisp">(defun average-damp (f)
  (lambda (x)
    (average x (funcall f x))))
</code></pre>
<p><code>average-damp/1</code> is a function that takes as its argument a function <code>f</code> and returns as its value a function (produced by the <code>lambda</code>) that, when applied to a number <code>x</code>, produces the average of <code>x</code> and <code>(f x)</code>. For example, applying <code>average-damp/1</code> to the <code>square/1</code> function produces a function whose value at some number $$x$$ is the average of $$x$$ and $$x^2$$. Applying this resulting function to 10 returns the average of 10 and 100, or 55:<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<pre><code class="language-lisp">&gt; (funcall (average-damp #'square/1) 10)
55.0
</code></pre>
<p>Using <code>average-damp/1</code>, we can reformulate the <code>sqrt/1</code> function as follows:</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
</code></pre>
<p>Notice how this formulation makes explicit the three ideas in the method: fixed-point search, average damping, and the function $$y \mapsto \frac{x}{y}$$. It is instructive to compare this formulation of the square-root method with the original version given in the section <a href="ch1/">Example: Square Roots by Newton's Method</a>. Bear in mind that these functions express the same process, and notice how much clearer the idea becomes when we express the process in terms of these abstractions. In general, there are many ways to formulate a process as a function. Experienced programmers know how to choose procedural formulations that are particularly perspicuous, and where useful elements of the process are exposed as separate entities that can be reused in other applications. As a simple example of reuse, notice that the cube root of $$x$$ is a fixed point of the function $$y \mapsto \frac{x}{y^2}$$, so we can immediately generalize our square-root function to one that extracts cube roots:<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<pre><code class="language-lisp">(defun cube-root (x)
  (fixed-point (average-damp (lambda (y) (/ x (square y))))
               1.0))
</code></pre>
<h4><a class="header" href="#newtons-method" id="newtons-method">Newton's method</a></h4>
<p>When we first introduced the square-root function in the section <a href="ch1/">Example: Square Roots by Newton's Method</a>, we mentioned that this was a special case of <em>Newton's method</em>. If $$x \mapsto g(x)$$ is a differentiable function, then a solution of the equation $$g(x) = 0$$ is a fixed point of the function $$x \mapsto f(x)$$ where</p>
<p>$$
\begin{align}
f(x) = r - \frac{g(x)}{Dg(x)}
\end{align}
$$</p>
<p>and $$Dg(x)$$ is the derivative of $$g$$ evaluated at $$x$$. Newton's method is the use of the fixed-point method we saw above to approximate a solution of the equation by finding a fixed point of the function $$f$$.<sup class="footnote-reference"><a href="#3">3</a></sup> For many functions $$g$$ and for sufficiently good initial guesses for $$x$$, Newton's method converges very rapidly to a solution of $$g(x) = 0$$.<sup class="footnote-reference"><a href="#4">4</a></sup></p>
<p>In order to implement Newton's method as a function, we must first express the idea of derivative. Note that &quot;derivative,&quot; like average damping, is something that transforms a function into another function. For instance, the derivative of the function $$x \mapsto x^3$$ is the function $$x \mapsto 3x^2$$. In general, if $$g$$ is a function and $$dx$$ is a small number, then the derivative $$Dg$$ of $$g$$ is the function whose value at any number $$x$$ is given (in the limit of small $$dx$$) by</p>
<p>$$
\begin{align}
Dg(x) = \frac{g(x + dx) - g(x)}{dx}
\end{align}
$$</p>
<p>Thus, we can express the idea of derivative (taking $$dx$$ to be, say, 0.00001) as the function</p>
<pre><code class="language-lisp">(defun deriv (g)
  (lambda (x)
    (/ (- (funcall g (+ x dx)) (funcall g x))
       dx)))
</code></pre>
<p>along with the definition</p>
<pre><code class="language-lisp">&gt; (set dx 0.00001)
1.0e-5
</code></pre>
<p>Like <code>average-damp/1</code>, <code>deriv/1</code> is a function that takes a function as argument and returns a function as value. For example, to approximate the derivative of $$x \mapsto x^3$$ at 5 (whose exact value is 75) we can evaluate</p>
<pre><code class="language-lisp">&gt; (defun cube (x) (* x x x))
cube
&gt; (funcall (deriv #'cube/1) 5)
75.00014999664018
</code></pre>
<p>With the aid of <code>deriv/1</code>, we can express Newton's method as a fixed-point process:</p>
<pre><code class="language-lisp">(defun newton-transform (g)
  (lambda (x)
    (- x (/ (funcall g x) (funcall (deriv g) x)))))

(defun newtons-method (g guess)
  (fixed-point (newton-transform g) guess))
</code></pre>
<p>The <code>newton-transform/1</code> function expresses the formula at the beginning of this section, and <code>newtons-method/2</code> is readily defined in terms of this. It takes as arguments a function that computes the function for which we want to find a zero, together with an initial guess. For instance, to find the square root of $$x$$, we can use Newton's method to find a zero of the function $$y \mapsto y^2 - x$$ starting with an initial guess of 1.<sup class="footnote-reference"><a href="#5">5</a></sup> This provides yet another form of the square-root function:</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (newtons-method (lambda (y) (- (square y) x))
                  1.0))
</code></pre>
<h4><a class="header" href="#abstractions-and-first-class-functions" id="abstractions-and-first-class-functions">Abstractions and first-class functions</a></h4>
<p>We've seen two ways to express the square-root computation as an instance of a more general method, once as a fixed-point search and once using Newton's method. Since Newton's method was itself expressed as a fixed-point process, we actually saw two ways to compute square roots as fixed points. Each method begins with a function and finds a fixed point of some transformation of the function. We can express this general idea itself as a function:</p>
<pre><code class="language-lisp">(defun fixed-point-of-transform (g transform guess)
  (fixed-point (transform g) guess))
</code></pre>
<p>This very general function takes as its arguments a function <code>g</code> that computes some function, a function that transforms <code>g</code>, and an initial guess. The returned result is a fixed point of the transformed function.</p>
<p>Using this abstraction, we can recast the first square-root computation from this section (where we look for a fixed point of the average-damped version of $$y \mapsto \frac{x}{y}
$$) as an instance of this general method:</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (fixed-point-of-transform (lambda (y) (/ x y))
                            average-damp
                            1.0))
</code></pre>
<p>Similarly, we can express the second square-root computation from this section (an instance of Newton's method that finds a fixed point of the Newton transform of $$y \mapsto y^2 - x$$) as</p>
<pre><code class="language-lisp">(defun sqrt (x)
  (fixed-point-of-transform (lambda (y) (- (square y) x))
                            newton-transform
                            1.0))
</code></pre>
<p>We began the section <a href="ch1/">Formulating Abstractions with Higher-Order Functions</a> with the observation that compound functions are a crucial abstraction mechanism, because they permit us to express general methods of computing as explicit elements in our programming language. Now we've seen how higher-order functions permit us to manipulate these general methods to create further abstractions.</p>
<p>As programmers, we should be alert to opportunities to identify the underlying abstractions in our programs and to build upon them and generalize them to create more powerful abstractions. This is not to say that one should always write programs in the most abstract way possible; expert programmers know how to choose the level of abstraction appropriate to their task. But it is important to be able to think in terms of these abstractions, so that we can be ready to apply them in new contexts. The significance of higher-order functions is that they enable us to represent these abstractions explicitly as elements in our programming language, so that they can be handled just like other computational elements.</p>
<p>In general, programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have <em>first-class</em> status. Some of the &quot;rights and privileges&quot; of first-class elements are:<sup class="footnote-reference"><a href="#6">6</a></sup></p>
<ul>
<li>They may be named by variables.</li>
<li>They may be passed as arguments to functions.</li>
<li>They may be returned as the results of functions.</li>
<li>They may be included in data structures.<sup class="footnote-reference"><a href="#7">7</a></sup></li>
</ul>
<p>Lisp, unlike other common programming languages, awards functions full first-class status. This poses challenges for efficient implementation, but the resulting gain in expressive power is enormous.<sup class="footnote-reference"><a href="#8">8</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Observe that this is a combination whose operator is itself a combination. Exercise 1.4 already demonstrated the ability to form such combinations, but that was only a toy example. Here we begin to see the real need for such combinations -- when applying a function that is obtained as the value returned by a higher-order function.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>See exercise 1.45 for a further generalization.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Elementary calculus books usually describe Newton's method in terms of the sequence of approximations $$x_{n+1} = x_n - g(x_n)/Dg(x_n)$$. Having language for talking about processes and using the idea of fixed points simplifies the description of the method.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Newton's method does not always converge to an answer, but it can be shown that in favorable cases each iteration doubles the number-of-digits accuracy of the approximation to the solution. In such cases, Newton's method will converge much more rapidly than the half-interval method.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>For finding square roots, Newton's method converges rapidly to the correct solution from any starting point.</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p>The notion of first-class status of programming-language elements is due to the British computer scientist Christopher Strachey (1916-1975).</p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p>We'll see examples of this after we introduce data structures in the next chapter 2.</p>
</div>
<div class="footnote-definition" id="8"><sup class="footnote-definition-label">8</sup>
<p>The major implementation cost of first-class functions is that allowing functions to be returned as values requires reserving storage for a function's free variables even while the function is not executing. In the Scheme implementation we will study in the section <a href="ch1/">The Metacircular Evaluator</a>, these variables are stored in the function's environment.</p>
</div>
<h3><a class="header" href="#exercises-11" id="exercises-11">Exercises</a></h3>
<h4><a class="header" href="#exercise-140" id="exercise-140">Exercise 1.40</a></h4>
<p>Define a function <code>cubic/3</code> that can be used together with the <code>newtons-method/2</code> function in expressions of the form</p>
<pre><code class="language-lisp">(newtons-method (cubic a b c) 1)
</code></pre>
<p>to approximate zeros of the cubic $$x^3 + ax^2 + bx + c$$.</p>
<h4><a class="header" href="#exercise-141" id="exercise-141">Exercise 1.41</a></h4>
<p>Define a function <code>double</code> that takes a function of one argument as argument and returns a function that applies the original function twice. For example, if inc is a function that adds 1 to its argument, then (double inc) should be a function that adds 2. What value is returned by</p>
<pre><code class="language-lisp">(funcall (funcall (double (double #'double/1)) #'inc/1) 5)
</code></pre>
<h4><a class="header" href="#exercise-142" id="exercise-142">Exercise 1.42</a></h4>
<p>Let $$f$$ and $$g$$ be two one-argument functions. The <em>composition</em> $$f$$ after $$g$$ is defined to be the function $$x \mapsto f(g(x))$$. Define a function <code>compose</code> that implements composition. For example, if <code>inc/1</code> is a function that adds 1 to its argument,</p>
<pre><code class="language-lisp">&gt; (funcall (compose square inc) 6)
49
</code></pre>
<h4><a class="header" href="#exercise-143" id="exercise-143">Exercise 1.43</a></h4>
<p>If $$f$$ is a numerical function and $$n$$ is a positive integer, then we can form the $$n$$th repeated application of $$f$$, which is defined to be the function whose value at x is $$f(f( \cdots (f(x)) \cdots ))$$. For example, if $$f$$ is the function $$x \mapsto x + 1$$, then the $$n$$th repeated application of $$f$$ is the function $$x \mapsto x + n$$. If $$f$$ is the operation of squaring a number, then the $$n$$th repeated application of $$f$$ is the function that raises its argument to the $$2^n$$th power. Write a function that takes as inputs a function that computes $$f$$ and a positive integer $$n$$ and returns the function that computes the $$n$$th repeated application of $$f$$. Your function should be able to be used as follows:</p>
<pre><code class="language-lisp">(funcall (repeated square 2) 5)
625
</code></pre>
<p>Hint: You may find it convenient to use compose from exercise 1.42.</p>
<h4><a class="header" href="#exercise-144" id="exercise-144">Exercise 1.44</a></h4>
<p>The idea of $$smoothing$$ a function is an important concept in signal processing. If $$f$$ is a function and $$dx$$ is some small number, then the smoothed version of $$f$$ is the function whose value at a point $$x$$ is the average of $$f(x - dx)$$, $$f(x)$$, and $$f(x + dx)$$. Write a function <code>smooth</code> that takes as input a function that computes $$f$$ and returns a function that computes the smoothed $$f$$. It is sometimes valuable to repeatedly smooth a function (that is, smooth the smoothed function, and so on) to obtained the <em>n-fold smoothed function</em>. Show how to generate the <em>n</em>-fold smoothed function of any given function using <code>smooth</code> as well as <code>repeated</code> from exercise 1.43.</p>
<h4><a class="header" href="#exercise-145" id="exercise-145">Exercise 1.45</a></h4>
<p>We saw in the section <a href="ch1/">Functions as General Methods</a> that attempting to compute square roots by naively finding a fixed point of $$y \mapsto \frac{x}{y}$$ does not converge, and that this can be fixed by average damping. The same method works for finding cube roots as fixed points of the average-damped $$y \mapsto \frac{x}{y^2}. Unfortunately, the process does not work for fourth roots -- a single average damp is not enough to make a fixed-point search for $$y \mapts \frac{x}{y^3}$$ converge. On the other hand, if we average damp twice (i.e., use the average damp of the average damp of $$y \mapsto \frac{x}{y^3}) the fixed-point search does converge. Do some experiments to determine how many average damps are required to compute $$n$$th roots as a fixed-point search based upon repeated average damping of $$y \mapsto \frac{x}{y^{n-1}}$$. Use this to implement a simple function for computing $$n$$th roots using <code>fixed-point/2</code>, <code>average-damp/1</code>, and the <code>repeated</code> function of exercise 1.43. Assume that any arithmetic operations you need are available as primitives.</p>
<h4><a class="header" href="#exercise-146" id="exercise-146">Exercise 1.46</a></h4>
<p>Several of the numerical methods described in this chapter are instances of an extremely general computational strategy known as <em>iterative improvement</em>. Iterative improvement says that, to compute something, we start with an initial guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess. Write a function <code>iterative-improve/2</code> that takes two functions as arguments: a method for telling whether a guess is good enough and a method for improving a guess. <code>iterative-improve/2</code> should return as its value a function that takes a guess as argument and keeps improving the guess until it is good enough. Rewrite the <code>sqrt/1</code> function of the section <a href="ch1/">Example: Square Roots by Newton's Method</a> and the <code>fixed-point/2</code> function of the section <a href="ch1/">Functions as General Methods</a> in terms of <code>iterative-improve/2</code>.</p>
<p><strong>Chapter 2</strong></p>
<h1><a class="header" href="#building-abstractions-with-data" id="building-abstractions-with-data">Building Abstractions with Data</a></h1>
<blockquote>
We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. ...[The mathematician] need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for.
</blockquote>
<p>-- Hermann Weyl, <em>The Mathematical Way of Thinking</em></p>
<p>We concentrated in chapter 1 on computational processes and on the role of functions in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine functions to form compound functions through composition, conditionals, and the use of parameters, and how to abstract functions by using <code>defun</code>. We saw that a function can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in functions. We also saw that higher-order functions enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming.</p>
<p>In this chapter we are going to look at more complex data. All the functions in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining functions to form compound functions, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form <em>compound data</em>.</p>
<p>Why do we want compound data in a programming language? For the same reasons that we want compound functions: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to define functions enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language.</p>
<p>Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation <code>add-rat/2</code> that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where <code>add-rat/2</code> would be implemented by two functions (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could &quot;glue together&quot; a numerator and denominator to form a pair -- a <em>compound data object</em> -- that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit.</p>
<p>The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called <em>data abstraction</em>. We will see how data abstraction makes programs much easier to design, maintain, and modify.</p>
<p>The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a &quot;linear combination&quot; $$a x + b y$$. We might like to write a function that would accept $$a$$, $$b$$, $$x$$, and $$y$$ as arguments and return the value of ax + by. This presents no difficulty if the arguments are to be numbers, because we can readily define the function</p>
<pre><code class="language-lisp">(defun linear-combination (a b x y)
  (+ (* a x) (* b y)))
</code></pre>
<p>But suppose we are not concerned only with numbers. Suppose we would like to express, in procedural terms, the idea that one can form linear combinations whenever addition and multiplication are defined -- for rational numbers, complex numbers, polynomials, or whatever. We could express this as a function of the form</p>
<pre><code class="language-lisp">(defun linear-combination (a b x y)
  (add (mul a x) (mul b y)))
</code></pre>
<p>where <code>add/2</code> and <code>mul/2</code> are not the primitive functions <code>+</code> and <code>*</code> but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments <code>a</code>, <code>b</code>, <code>x</code>, and <code>y</code>. The key point is that the only thing <code>linear-combination/4</code> should need to know about <code>a</code>, <code>b</code>, <code>x</code>, and <code>y</code> is that the functions <code>add/2</code> and <code>mul/2</code> will perform the appropriate manipulations. From the perspective of the function <code>linear-combination/4</code>, it is irrelevant what <code>a</code>, <code>b</code>, <code>x</code>, and <code>y</code> are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a function such as <code>linear-combination/2</code> to pass its arguments along to <code>add/2</code> and <code>mul/2</code> without having to know their detailed structure.<sup class="footnote-reference"><a href="#1">1</a></sup> We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound functions, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable <em>abstraction barriers</em> between different parts of a program.</p>
<p>We will see that the key to forming compound data is that a programming language should provide some kind of &quot;glue&quot; so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special &quot;data&quot; operations at all, only functions. This will further blur the distinction between &quot;function&quot; and &quot;data,&quot; which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of <em>closure</em> -- that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as <em>conventional interfaces</em> for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure.</p>
<p>We will then augment the representational power of our language by introducing <em>symbolic expressions</em> -- data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information.</p>
<p>Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement <em>generic operations</em>, which must handle many different types of data. Maintaining modularity in the presence of generic operations requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce <em>data-directed programming</em> as a technique that allows individual data representations to be designed in isolation and then combined <em>additively</em> (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The ability to directly manipulate functions provides an analogous increase in the expressive power of a programming language. For example, in the section <a href="ch2/">Functions as Arguments</a> we introduced the <code>sum/4</code> function, which takes a function <code>term</code> as an argument and computes the sum of the values of <code>term</code> over some specified interval. In order to define <code>sum/4</code>, it is crucial that we be able to speak of a function such as <code>term</code> as an entity in its own right, without regard for how term might be expressed with more primitive operations. Indeed, if we did not have the notion of &quot;a function,&quot; it is doubtful that we would ever even think of the possibility of defining an operation such as <code>sum/4</code>. Moreover, insofar as performing the summation is concerned, the details of how <code>term</code> may be constructed from more primitive operations are irrelevant.</p>
</div>
<h2><a class="header" href="#introduction-to-data-abstraction" id="introduction-to-data-abstraction">Introduction to Data Abstraction</a></h2>
<p>In the section <a href="ch2/">Functions as Black-Box Abstractions</a>, we noted that a function used as an element in creating a more complex function could be regarded not only as a collection of particular operations but also as a procedural abstraction. That is, the details of how the function was implemented could be suppressed, and the particular function itself could be replaced by any other function with the same overall behavior. In other words, we could make an abstraction that would separate the way the function would be used from the details of how the function would be implemented in terms of more primitive functions. The analogous notion for compound data is called <em>data abstraction</em>. Data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects.</p>
<p>The basic idea of data abstraction is to structure the programs that are to use compound data objects so that they operate on &quot;abstract data.&quot; That is, our programs should use data in such a way as to make no assumptions about the data that are not strictly necessary for performing the task at hand. At the same time, a &quot;concrete&quot; data representation is defined independent of the programs that use the data. The interface between these two parts of our system will be a set of functions, called <em>selectors</em> and <em>constructors</em>, that implement the abstract data in terms of the concrete representation. To illustrate this technique, we will consider how to design a set of functions for manipulating rational numbers.</p>
<h3><a class="header" href="#example-arithmetic-operations-for-rational-numbers" id="example-arithmetic-operations-for-rational-numbers">Example: Arithmetic Operations for Rational Numbers</a></h3>
<p>Suppose we want to do arithmetic with rational numbers. We want to be able to add, subtract, multiply, and divide them and to test whether two rational numbers are equal.</p>
<p>Let us begin by assuming that we already have a way of constructing a rational number from a numerator and a denominator. We also assume that, given a rational number, we have a way of extracting (or selecting) its numerator and its denominator. Let us further assume that the constructor and selectors are available as functions:</p>
<ul>
<li><code>(make-rat &lt;n&gt; &lt;d&gt;)</code> returns the rational number whose numerator is the integer <code>&lt;n&gt;</code> and whose denominator is the integer <code>&lt;d&gt;</code>.</li>
<li><code>(numer &lt;x&gt;)</code> returns the numerator of the rational number <code>&lt;x&gt;</code>.</li>
<li><code>(denom &lt;x&gt;)</code> returns the denominator of the rational number <code>&lt;x&gt;</code>.</li>
</ul>
<p>We are using here a powerful strategy of synthesis: <em>wishful thinking</em>. We haven't yet said how a rational number is represented, or how the functions <code>numer/1</code>, <code>denom/1</code>, and <code>make-rat/2</code> should be implemented. Even so, if we did have these three functions, we could then add, subtract, multiply, divide, and test equality by using the following relations:</p>
<p>$$
\begin{align}
\frac{n_1}{d_1} + \frac{n_2}{d_2} =
\frac{n_1 d_2 + n_2 d_1}{d_1 d_2}
\end{align}
$$</p>
<p>$$
\begin{align}
\frac{n_1}{d_1} - \frac{n_2}{d_2} =
\frac{n_1 d_2 - n_2 d_1}{d_1 d_2}
\end{align}
$$</p>
<p>$$
\begin{align}
\frac{n_1}{d_1} \cdot \frac{n_2}{d_2} =
\frac{n_1 n_2}{d_1 d_2}
\end{align}
$$</p>
<p>$$
\begin{align}
\frac{\frac{n_1}{d_1}}{\frac{n_2}{d_2}} =
\frac{n_1 d_2}{d_1 n_2}
\end{align}
$$</p>
<p>$$
\begin{align}
\frac{n_1}{d_1} = \frac{n_2}{d_2} \text{if and only if }
n_1 d_2 = n_2 d_1
\end{align}
$$</p>
<p>We can express these rules as functions:</p>
<pre><code class="language-lisp">(defun add-rat (x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(defun sub-rat (x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(defun mul-rat (x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(defun div-rat (x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(defun equal-rat? (x y)
  (== (* (numer x) (denom y))
      (* (numer y) (denom x))))
</code></pre>
<p>Now we have the operations on rational numbers defined in terms of the selector and constructor functions <code>numer/1</code>, <code>denom/1</code>, and <code>make-rat/2</code>. But we haven't yet defined these. What we need is some way to glue together a numerator and a denominator to form a rational number.</p>
<p>Now we have the operations on rational numbers defined in terms of the selector and constructor functions <code>numer/1</code>, <code>denom/1</code>, and <code>make-rat/2</code>. But we haven't yet defined these. What we need is some way to glue together a numerator and a denominator to form a rational number.</p>
<h4><a class="header" href="#pairs" id="pairs">Pairs</a></h4>
<p>To enable us to implement the concrete level of our data abstraction, our language provides a compound structure called a <em>pair</em>, which can be constructed with the primitive function <code>cons/2</code>. This function takes two arguments and returns a compound data object that contains the two arguments as parts. Given a pair, we can extract the parts using the primitive functions <code>car/1</code> and <code>cdr/1</code>.<sup class="footnote-reference"><a href="#1">1</a></sup> Thus, we can use <code>cons/2</code>, <code>car/1</code>, and <code>cdr/1</code> as follows:</p>
<pre><code class="language-lisp">&gt; (set x (cons 1 2))
(1 . 2)
&gt; (car x)
1
&gt; (cdr x)
2
</code></pre>
<p>Notice that a pair is a data object that can be given a name and manipulated, just like a primitive data object. Moreover, <code>cons/2</code> can be used to form pairs whose elements are pairs, and so on:</p>
<pre><code class="language-lisp">&gt; (set x (cons 1 2))
(1 . 2)
&gt; (set y (cons 3 4))
(3 . 4)
&gt; (set z (cons x y))
((1 . 2) 3 . 4)
&gt; (car (car z))
1
&gt; (car (cdr z))
3
</code></pre>
<p>In the section <a href="ch2/">Hierarchical Data and the Closure Property</a> we will see how this ability to combine pairs means that pairs can be used as general-purpose building blocks to create all sorts of complex data structures. The single compound-data primitive <em>pair</em>, implemented by the functions <code>cons/2</code>, <code>car/1</code>, and <code>cdr/1</code>, is the only glue we need. Data objects constructed from pairs are called <em>list-structured</em> data.</p>
<h4><a class="header" href="#representing-rational-numbers" id="representing-rational-numbers">Representing rational numbers</a></h4>
<p>Pairs offer a natural way to complete the rational-number system. Simply represent a rational number as a pair of two integers: a numerator and a denominator. Then <code>make-rat/2</code>, <code>numer/1</code>, and <code>denom/1</code> and are readily implemented as follows:<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<pre><code class="language-lisp">(defun make-rat (x y)
  (cons x y))

(defun numer (rat)
  (car rat))

(defun denom (rat)
  (cdr rat))
</code></pre>
<p>However, LFE pattern matching provides another possibility for implementating <code>numer/1</code> and <code>denom/1</code>. Without using <code>car</code> or <code>cdr</code>, we can match the numerator and denomenator in function arguments itself, without making a call in the body of the function.</p>
<pre><code class="language-lisp">(defun numer
  (((cons x _))
    x))

(defun denom
  (((cons _ y))
    y))
</code></pre>
<p>Though nothing obvious is gained through the use of pattern matching here<sup class="footnote-reference"><a href="#2">2</a></sup>, this is a good opportunity to see its usage again, after the introduction in the first chapter.</p>
<p>In order to display the results of our computations, we can print rational numbers by printing the numerator, a slash, and the denominator:4</p>
<pre><code class="language-lisp">(defun print-rat (rat)
  (io:format &quot;~p/~p~n&quot; (list (numer rat)
                             (denom rat))))
</code></pre>
<p>Now we can try our rational-number functions:</p>
<pre><code class="language-lisp">&gt; (set one-half (make-rat 1 2))
(1 . 2)
&gt; (print-rat one-half)
1/2
ok
&gt; (set one-third (make-rat 1 3))
(1 . 3)
&gt; (print-rat (add-rat one-half one-third))
5/6
ok
&gt; (print-rat (mul-rat one-half one-third))
1/6
ok
&gt; (print-rat (add-rat one-third one-third))
6/9
ok
</code></pre>
<p>As the final example shows, our rational-number implementation does not reduce rational numbers to lowest terms. We can remedy this by changing <code>make-rat/2</code>. If we have a <code>gcd/2</code> function like the one in the section <a href="ch2/">Greatest Common Divisors</a> that produces the greatest common divisor of two integers, we can use <code>gcd/2</code> to reduce the numerator and the denominator to lowest terms before constructing the pair:</p>
<pre><code class="language-lisp">(defun make-rat (n d)
  (let ((g (gcd n d)))
    (cons (trunc (/ n g))
          (trunc (/ d g)))))
</code></pre>
<p>Now we have</p>
<pre><code class="language-lisp">&gt; (print-rat (add-rat one-third one-third))
2/3
ok
</code></pre>
<p>as desired. This modification was accomplished by changing the constructor <code>make-rat/2</code> without changing any of the functions (such as <code>add-rat/2</code> and <code>mul-rat/2</code>) that implement the actual operations.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The name <code>cons</code> stands for &quot;construct.&quot; The names <code>car</code> and <code>cdr</code> derive from the original implementation of Lisp on the <a href="http://en.wikipedia.org/wiki/IBM_704">IBM 704</a>. That machine had an addressing scheme that allowed one to reference the &quot;address&quot; and &quot;decrement&quot; parts of a memory location. <code>car</code> stands for &quot;Contents of Address part of Register&quot; and <code>cdr</code> (pronounced &quot;could-er&quot; or &quot;cudder&quot;) stands for &quot;Contents of Decrement part of Register.&quot;</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>In fact, something is lost: about 2 $$\mu$$seconds. Arguably, this could be within a margin of uncertainty, though the results are consistent. The timing was performed upon the LFE author's 2009 MacBook Air using <code>(set counts (lists:seq 1 10000))</code> and <code>(/ (lists:sum (lists:map (lambda (_) (element 1 (timer:tc #'numer/1 (list one-half)))) counts)) (length counts))</code>. Without pattern matching, results ranged between 7 and 8 $$\mu$$seconds; with pattern matching, results ranged from 8 to 11 $$\mu$$seconds.</p>
</div>
<h3><a class="header" href="#exercises-12" id="exercises-12">Exercises</a></h3>
<h4><a class="header" href="#exercise-21" id="exercise-21">Exercise 2.1</a></h4>
<p>Define a better version of <code>make-rat</code> that handles both positive and negative arguments. <code>make-rat</code> should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.</p>
<h3><a class="header" href="#abstraction-barriers" id="abstraction-barriers">Abstraction Barriers</a></h3>
<p>Before continuing with more examples of compound data and data abstraction, let us consider some of the issues raised by the rational-number example. We defined the rational-number operations in terms of a constructor <code>make-rat/2</code> and selectors <code>numer/1</code> and <code>denom/1</code>. In general, the underlying idea of data abstraction is to identify for each type of data object a basic set of operations in terms of which all manipulations of data objects of that type will be expressed, and then to use only those operations in manipulating the data.</p>
<p>We can envision the structure of the rational-number system as shown in the figure below. The horizontal lines represent <em>abstraction barriers</em> that isolate different &quot;levels&quot; of the system. At each level, the barrier separates the programs (above) that use the data abstraction from the programs (below) that implement the data abstraction. Programs that use rational numbers manipulate them solely in terms of the functions supplied &quot;for public use&quot; by the rational-number package: <code>add-rat/2</code>, <code>sub-rat/2</code>, <code>mul-rat/2</code>, <code>div-rat/2</code>, and <code>equal-rat?/2</code>. These, in turn, are implemented solely in terms of the constructor and selectors <code>make-rat/2</code>, <code>numer/1</code>, and <code>denom/1</code>, which themselves are implemented in terms of pairs. The details of how pairs are implemented are irrelevant to the rest of the rational-number package so long as pairs can be manipulated by the use of <code>cons/2</code>, <code>car/1</code>, and <code>cdr/1</code>. In effect, functions at each level are the interfaces that define the abstraction barriers and connect the different levels.</p>
<p><a name="figure-1"></a></p>
<p><img src="ch2/images/ch2-Z-G-6.png" alt="Data-abstraction barriers in the rational-number package" /></p>
<p><strong>Figure 2.1</strong>: Data-abstraction barriers in the rational-number package.</p>
<p>This simple idea has many advantages. One advantage is that it makes programs much easier to maintain and to modify. Any complex data structure can be represented in a variety of ways with the primitive data structures provided by a programming language. Of course, the choice of representation influences the programs that operate on it; thus, if the representation were to be changed at some later time, all such programs might have to be modified accordingly. This task could be time-consuming and expensive in the case of large programs unless the dependence on the representation were to be confined by design to a very few program modules.</p>
<p>For example, an alternate way to address the problem of reducing rational numbers to lowest terms is to perform the reduction whenever we access the parts of a rational number, rather than when we construct it. This leads to different constructor and selector functions:</p>
<pre><code class="language-lisp">(defun make-rat (n d)
  (cons n d))

(defun numer (x)
  (let ((g (gcd (car x) (cdr x))))
    (trunc (/ (car x) g))))

(defun denom (x)
  (let ((g (gcd (car x) (cdr x))))
    (trunc (/ (cdr x) g))))
</code></pre>
<p>The difference between this implementation and the previous one lies in when we compute the <code>gcd/2</code>. If in our typical use of rational numbers we access the numerators and denominators of the same rational numbers many times, it would be preferable to compute <code>gcd/2</code> when the rational numbers are constructed. If not, we may be better off waiting until access time to compute <code>gcd/2</code>. In any case, when we change from one representation to the other, the functions <code>add-rat/2</code>, <code>sub-rat/2</code>, and so on do not have to be modified at all.</p>
<p>Constraining the dependence on the representation to a few interface functions helps us design programs as well as modify them, because it allows us to maintain the flexibility to consider alternate implementations. To continue with our simple example, suppose we are designing a rational-number package and we can't decide initially whether to perform the gcd at construction time or at selection time. The data-abstraction methodology gives us a way to defer that decision without losing the ability to make progress on the rest of the system.</p>
<h3><a class="header" href="#exercises-13" id="exercises-13">Exercises</a></h3>
<h4><a class="header" href="#exercise-22" id="exercise-22">Exercise 2.2</a></h4>
<p>Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor <code>make-segment</code> and selectors <code>start-segment</code> and <code>end-segment</code> that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the $$x$$ coordinate and the $$y$$ coordinate. Accordingly, specify a constructor <code>make-point</code> and selectors <code>x-point</code> and <code>y-point</code> that define this representation. Finally, using your selectors and constructors, define a function <code>midpoint-segment</code> that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your functions, you'll need a way to print points:</p>
<pre><code class="language-lisp">(defun print-point (p)
 (io:format &quot;(~p, ~p)~n&quot; (list (x-point p)
                               (y-point p))))
</code></pre>
<h4><a class="header" href="#exercise-23" id="exercise-23">Exercise 2.3</a></h4>
<p>Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise 2.2.) In terms of your constructors and selectors, create functions that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area functions will work using either representation?</p>
<h3><a class="header" href="#what-is-meant-by-data" id="what-is-meant-by-data">What Is Meant by Data?</a></h3>
<p>We began the rational-number implementation in the section <a href="ch2/">Example: Arithmetic Operations for Rational Numbers</a> by implementing the rational-number operations <code>add-rat/2</code>, <code>sub-rat/2</code>, and so on in terms of three unspecified functions: <code>make-rat/2</code>, <code>numer/1</code>, and <code>denom/1</code>. At that point, we could think of the operations as being defined in terms of data objects -- numerators, denominators, and rational numbers -- whose behavior was specified by the latter three functions.</p>
<p>But exactly what is meant by <em>data</em>? It is not enough to say &quot;whatever is implemented by the given selectors and constructors.&quot; Clearly, not every arbitrary set of three functions can serve as an appropriate basis for the rational-number implementation. We need to guarantee that, if we construct a rational number <code>x</code> from a pair of integers <code>n</code> and <code>d</code>, then extracting the <code>numer</code> and the <code>denom</code> of <code>x</code> and dividing them should yield the same result as dividing <code>n</code> by <code>d</code>. In other words, <code>make-rat/2</code>, <code>numer/1</code>, and <code>denom/1</code> must satisfy the condition that, for any integer <code>n</code> and any non-zero integer <code>d</code>, if <code>x</code> is <code>(make-rat n d)</code>, then</p>
<p>$$
\begin{align}
\frac{\text{(numer x)}}{\text{(denom x)}} = \frac{\text{n}}{\text{d}}
\end{align}
$$</p>
<p>In fact, this is the only condition <code>make-rat/2</code>, <code>numer/1</code>, and <code>denom/1</code> must fulfill in order to form a suitable basis for a rational-number representation. In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these functions must fulfill in order to be a valid representation.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>This point of view can serve to define not only &quot;high-level&quot; data objects, such as rational numbers, but lower-level objects as well. Consider the notion of a pair, which we used in order to define our rational numbers. We never actually said what a pair was, only that the language supplied functions <code>cons</code>, <code>car</code>, and <code>cdr</code> for operating on pairs. But the only thing we need to know about these three operations is that if we glue two objects together using <code>cons</code> we can retrieve the objects using <code>car</code> and <code>cdr</code>. That is, the operations satisfy the condition that, for any objects <code>x</code> and <code>y</code>, if <code>z</code> is <code>(cons x y)</code> then <code>(car z)</code> is <code>x</code> and <code>(cdr z)</code> is <code>y</code>. Indeed, we mentioned that these three functions are included as primitives in our language. However, any triple of functions that satisfies the above condition can be used as the basis for implementing pairs. This point is illustrated strikingly by the fact that we could implement <code>cons</code>, <code>car</code>, and <code>cdr</code> without using any data structures at all but only using functions. Here are the definitions <sup class="footnote-reference"><a href="#2">2</a></sup><sup>,</sup> <sup class="footnote-reference"><a href="#3">3</a></sup>:</p>
<pre><code class="language-lisp">(defun cons2 (x y)
  (match-lambda
    ((0) x)
    ((1) y)
    ((n) (error (++ &quot;cons2: argument must be 0 or 1 -- got &quot;
                    (integer_to_list n))
                'bad-argument))))

(defun car2 (z)
  (funcall z 0))

(defun cdr2 (z)
  (funcall z 1))
</code></pre>
<p>This use of functions corresponds to nothing like our intuitive notion of what data should be. Nevertheless, all we need to do to show that this is a valid way to represent pairs is to verify that these functions satisfy the condition given above.<sup class="footnote-reference"><a href="#4">4</a></sup></p>
<p>The subtle point to notice is that the value returned by <code>(cons2 x y)</code> is a function -- namely the anonymous dispatch function, which takes one argument and returns either <code>x</code> or <code>y</code> depending on whether the argument is 0 or 1. Correspondingly, <code>(car2 z)</code> is defined to apply <code>z</code> to <code>0</code>. Hence, if <code>z</code> is the function formed by <code>(cons2 x y)</code>, then <code>z</code> applied to 0 will yield <code>x</code>. Thus, we have shown that <code>(car2 (cons2 x y))</code> yields <code>x</code>, as desired. Similarly, <code>(cdr2 (cons2 x y))</code> applies the function returned by <code>(cons2 x y)</code> to 1, which returns <code>y</code>. Therefore, this procedural implementation of pairs is a valid implementation, and if we access pairs using only <code>cons2/2</code>, <code>car2/1</code>, and <code>cdr2/1</code> we cannot distinguish this implementation from one that uses ``real'' data structures.</p>
<p>The point of exhibiting the procedural representation of pairs is not that our language works this way (Lisp systems in general, implement pairs directly, for efficiency reasons) but that it could work this way. The procedural representation, although obscure, is a perfectly adequate way to represent pairs, since it fulfills the only conditions that pairs need to fulfill. This example also demonstrates that the ability to manipulate functions as objects automatically provides the ability to represent compound data. This may seem a curiosity now, but procedural representations of data will play a central role in our programming repertoire. This style of programming is often called <em>message passing</em>; not only will we be using it as a basic tool in the next chapter when we address the issues of modeling and simulation, but Erlang -- and thus LFE -- are built upon concepts similar to these.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Surprisingly, this idea is very difficult to formulate rigorously. There are two approaches to giving such a formulation. One, pioneered by C. A. R. Hoare (1972), is known as the method of abstract models. It formalizes the &quot;functions plus conditions&quot; specification as outlined in the rational-number example above. Note that the condition on the rational-number representation was stated in terms of facts about integers (equality and division). In general, abstract models define new kinds of data objects in terms of previously defined types of data objects. Assertions about data objects can therefore be checked by reducing them to assertions about previously defined data objects. Another approach, introduced by Zilles at MIT, by Goguen, Thatcher, Wagner, and Wright at IBM (see Thatcher, Wagner, and Wright 1978), and by Guttag at Toronto (see Guttag 1977), is called algebraic specification. It regards the &quot;functions&quot; as elements of an abstract algebraic system whose behavior is specified by axioms that correspond to our &quot;conditions,&quot; and uses the techniques of abstract algebra to check assertions about data objects. Both methods are surveyed in the <a href="http://csg.csail.mit.edu/CSGArchives/memos/Memo-117.pdf">paper by Liskov and Zilles</a> (1975).</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Note that LFE supports pattern mathcing in anonymous functions.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>In this case we have a very good justification for the use of pattern nmatching in the function arguments: value-based dispatch.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>We had to rename our functions from <code>cons</code>, <code>car</code>, and <code>cdr</code>. to <code>cons2</code>, etc. in order to avoid having LFE silently ignore them: LFE doesn't allow shadowing of certain forms (<code>cons</code>, etc. being among those).</p>
</div>
<h3><a class="header" href="#exercises-14" id="exercises-14">Exercises</a></h3>
<h4><a class="header" href="#exercise-24" id="exercise-24">Exercise 2.4</a></h4>
<p>Here is an alternative procedural representation of pairs. For this representation, verify that <code>(car3 (cons3 x y))</code> yields <code>x</code> for any objects <code>x</code> and <code>y</code>.</p>
<pre><code class="language-lisp">(defun cons3 (x y)
  (lambda (m) (funcall m x y)))

(defun car3 (z)
  (funcall z (lambda (p q) p)))
</code></pre>
<p>What is the corresponding definition of <code>cdr3/1</code>? (Hint: To verify that this works, make use of the substitution model from the section <a href="ch2/">The Substitution Model for Function Application</a>.)</p>
<h4><a class="header" href="#exercise-25" id="exercise-25">Exercise 2.5</a></h4>
<p>Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair $$a$$ and $$b$$ as the integer that is the product $$2^a \cdot 3^b$$. Give the corresponding definitions of the functions <code>cons4/2</code>, <code>car4/1</code>, and <code>cdr4/1</code>.</p>
<h4><a class="header" href="#exercise-26" id="exercise-26">Exercise 2.6</a></h4>
<p>In case representing pairs as functions wasn't mind-boggling enough, consider that, in a language that can manipulate functions, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as</p>
<pre><code class="language-lisp">(defun zero
  (lambda (f)
    (lambda (x) x)))

(defun add-1 (n)
  (lambda (f)
    (lambda (x)
      (f (funcall (funcall n f) x)))))
</code></pre>
<p>This representation is known as <em>Church numerals</em>, after its inventor, Alonzo Church, the logician who invented the $$\lambda$$-calculus.</p>
<p>Define <code>one</code> and <code>two</code> directly (not in terms of <code>zero/1</code> and <code>add-1/1</code>). (Hint: Use substitution to evaluate <code>(funcall add-1 zero)</code>). Give a direct definition of the addition function <code>#'+/2</code> (not in terms of repeated application of <code>add-1/1</code>).</p>
<h3><a class="header" href="#extended-exercise-interval-arithmetic" id="extended-exercise-interval-arithmetic">Extended Exercise: Interval Arithmetic</a></h3>
<p>Alyssa P. Hacker is designing a system to help people solve engineering problems. One feature she wants to provide in her system is the ability to manipulate inexact quantities (such as measured parameters of physical devices) with known precision, so that when computations are done with such approximate quantities the results will be numbers of known precision.</p>
<p>Electrical engineers will be using Alyssa's system to compute electrical quantities. It is sometimes necessary for them to compute the value of a parallel equivalent resistance R_p of two resistors R_1 and R_2 using the formula</p>
<p>$$
\begin{align}
R_p = \frac{1}{\frac{1}{R_1} + \frac{1}{R_2}}
\end{align}
$$</p>
<p>Resistance values are usually known only up to some tolerance guaranteed by the manufacturer of the resistor. For example, if you buy a resistor labeled &quot;6.8 ohms with 10% tolerance&quot; you can only be sure that the resistor has a resistance between 6.8 - 0.68 = 6.12 and 6.8 + 0.68 = 7.48 ohms. Thus, if you have a 6.8-ohm 10% resistor in parallel with a 4.7-ohm 5% resistor, the resistance of the combination can range from about 2.58 ohms (if the two resistors are at the lower bounds) to about 2.97 ohms (if the two resistors are at the upper bounds).</p>
<p>Alyssa's idea is to implement &quot;interval arithmetic&quot; as a set of arithmetic operations for combining &quot;intervals&quot; (objects that represent the range of possible values of an inexact quantity). The result of adding, subtracting, multiplying, or dividing two intervals is itself an interval, representing the range of the result.</p>
<p>Alyssa postulates the existence of an abstract object called an &quot;interval&quot; that has two endpoints: a lower bound and an upper bound. She also presumes that, given the endpoints of an interval, she can construct the interval using the data constructor <code>make-interval</code>. Alyssa first writes a function for adding two intervals. She reasons that the minimum value the sum could be is the sum of the two lower bounds and the maximum value it could be is the sum of the two upper bounds:</p>
<pre><code class="language-lisp">(defun add-interval (x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
</code></pre>
<p>Alyssa also works out the product of two intervals by finding the minimum and the maximum of the products of the bounds and using them as the bounds of the resulting interval.</p>
<pre><code class="language-lisp">(defun mul-interval (x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
</code></pre>
<p>To divide two intervals, Alyssa multiplies the first by the reciprocal of the second. Note that the bounds of the reciprocal interval are the reciprocal of the upper bound and the reciprocal of the lower bound, in that order.</p>
<pre><code class="language-lisp">(defun div-interval (x y)
  (mul-interval x 
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))
</code></pre>
<h3><a class="header" href="#exercises-15" id="exercises-15">Exercises</a></h3>
<h4><a class="header" href="#exercise-27" id="exercise-27">Exercise 2.7</a></h4>
<p>Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:</p>
<pre><code class="language-lisp">(defun make-interval (a b)
  (cons a b))
</code></pre>
<p>Define selectors <code>upper-bound</code> and <code>lower-bound</code> to complete the implementation.</p>
<h4><a class="header" href="#exercise-28" id="exercise-28">Exercise 2.8</a></h4>
<p>Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed. Define a corresponding subtraction function, called <code>sub-interval</code>.</p>
<h4><a class="header" href="#exercise-29" id="exercise-29">Exercise 2.9</a></h4>
<p>The <em>width</em> of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.</p>
<h4><a class="header" href="#exercise-210" id="exercise-210">Exercise 2.10</a></h4>
<p>Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa's code to check for this condition and to signal an error if it occurs.</p>
<h4><a class="header" href="#exercise-211" id="exercise-211">Exercise 2.11</a></h4>
<p>In passing, Ben also cryptically comments: &quot;By testing the signs of the endpoints of the intervals, it is possible to break mul-interval into nine cases, only one of which requires more than two multiplications.&quot; Rewrite this function using Ben's suggestion.</p>
<p>After debugging her program, Alyssa shows it to a potential user, who complains that her program solves the wrong problem. He wants a program that can deal with numbers represented as a center value and an additive tolerance; for example, he wants to work with intervals such as 3.5± 0.15 rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this problem by supplying an alternate constructor and alternate selectors:</p>
<pre><code class="language-lisp">(defun make-center-width (c w)
  (make-interval (- c w) (+ c w)))

(defun center (i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))

(defun width (i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
</code></pre>
<p>Unfortunately, most of Alyssa's users are engineers. Real engineering situations usually involve measurements with only a small uncertainty, measured as the ratio of the width of the interval to the midpoint of the interval. Engineers usually specify percentage tolerances on the parameters of devices, as in the resistor specifications given earlier.</p>
<h4><a class="header" href="#exercise-212" id="exercise-212">Exercise 2.12</a></h4>
<p>Define a constructor <code>make-center-percent/2</code> that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector <code>percent</code> that produces the percentage tolerance for a given interval. The <code>center</code> selector is the same as the one shown above.</p>
<h4><a class="header" href="#exercise-213" id="exercise-213">Exercise 2.13</a></h4>
<p>Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.</p>
<p>After considerable work, Alyssa P. Hacker delivers her finished system. Several years later, after she has forgotten all about it, she gets a frenzied call from an irate user, Lem E. Tweakit. It seems that Lem has noticed that the formula for parallel resistors can be written in two algebraically equivalent ways:</p>
<p>$$
\begin{align}
\frac{R_1 R_2}{R_1 + R_2}
\end{align}
$$</p>
<p>and</p>
<p>$$
\begin{align}
\frac{1}{\frac{1}{R_1} + \frac{1}{R_2}}
\end{align}
$$</p>
<p>He has written the following two programs, each of which computes the parallel-resistors formula differently:</p>
<pre><code class="language-lisp">(defun par1 (r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(defun par2 (r1 r2)
  (let ((one (make-interval 1 1))) 
    (div-interval one
                  (add-interval (div-interval one r1)
                                (div-interval one r2)))))
</code></pre>
<p>Lem complains that Alyssa's program gives different answers for the two ways of computing. This is a serious complaint.</p>
<h4><a class="header" href="#exercise-214" id="exercise-214">Exercise 2.14</a></h4>
<p>Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals A and B, and use them in computing the expressions $$\frac{A}{A}$$ and $$\frac{A}{B}$$. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see exercise 2.12).</p>
<h4><a class="header" href="#exercise-215" id="exercise-215">Exercise 2.15</a></h4>
<p>Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions. She says that a formula to compute with intervals using Alyssa's system will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated. Thus, she says, <code>par2</code> is a &quot;better&quot; program for parallel resistances than <code>par1</code>. Is she right? Why?</p>
<h4><a class="header" href="#exercise-216" id="exercise-216">Exercise 2.16</a></h4>
<p>Explain, in general, why equivalent algebraic expressions may lead to different answers. Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible? (Warning: This problem is very difficult.)</p>
<h2><a class="header" href="#hierarchical-data-and-the-closure-property" id="hierarchical-data-and-the-closure-property">Hierarchical Data and the Closure Property</a></h2>
<p>As we have seen, pairs provide a primitive &quot;glue&quot; that we can use to construct compound data objects. <a href="ch2/hierarchical-data-and-the-closure-property.html#figure-2">Figure 2.2</a> shows a standard way to visualize a pair -- in this case, the pair formed by <code>(cons 1 2)</code>. In this representation, which is called <em>box-and-pointer notation</em>, each object is shown as a <em>pointer</em> to a box. The box for a primitive object contains a representation of the object. For example, the box for a number contains a numeral. The box for a pair is actually a double box, the left part containing (a pointer to) the <code>car</code> of the pair and the right part containing the <code>cdr</code>.</p>
<p>We have already seen that <code>cons</code> can be used to combine not only numbers but pairs as well. (You made use of this fact, or should have, in doing exercises 2.2 and 2.3.) As a consequence, pairs provide a universal building block from which we can construct all sorts of data structures. <a href="ch2/hierarchical-data-and-the-closure-property.html#figure-3">Figure 2.3</a> shows two ways to use pairs to combine the numbers 1, 2, 3, and 4.</p>
<p><a name="figure-2"></a></p>
<p><img src="ch2/images/ch2-Z-G-11.png" alt="Box-and-pointer representation of (cons 1 2)l" /></p>
<p><strong>Figure 2.2</strong>:  Box-and-pointer representation of (cons 1 2).</p>
<p><a name="figure-3"></a></p>
<p><img src="ch2/images/ch2-Z-G-12.png" alt="Two ways to combine 1, 2, 3, and 4 using pairs" /></p>
<p><strong>Figure 2.3</strong>:  Two ways to combine 1, 2, 3, and 4 using pairs.</p>
<p>The ability to create pairs whose elements are pairs is the essence of list structure's importance as a representational tool. We refer to this ability as the <em>closure property</em> of <code>cons</code>. In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.<sup class="footnote-reference"><a href="#1">1</a></sup> Closure is the key to power in any means of combination because it permits us to create <em>hierarchical</em> structures -- structures made up of parts, which themselves are made up of parts, and so on.</p>
<p>From the outset of chapter 1, we've made essential use of closure in dealing with functions, because all but the very simplest programs rely on the fact that the elements of a combination can themselves be combinations. In this section, we take up the consequences of closure for compound data. We describe some conventional techniques for using pairs to represent sequences and trees, and we exhibit a graphics language that illustrates closure in a vivid way.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The use of the word &quot;closure&quot; here comes from abstract algebra, where a set of elements is said to be closed under an operation if applying the operation to elements in the set produces an element that is again an element of the set. The Lisp community also (unfortunately) uses the word &quot;closure&quot; to describe a totally unrelated concept: A closure is an implementation technique for representing functions with free variables. We do not use the word &quot;closure&quot; in this second sense in this book.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>The notion that a means of combination should satisfy closure is a straightforward idea. Unfortunately, the data combiners provided in many popular programming languages do not satisfy closure, or make closure cumbersome to exploit. In Fortran or Basic, one typically combines data elements by assembling them into arrays -- but one cannot form arrays whose elements are themselves arrays. Pascal and C admit structures whose elements are structures. However, this requires that the programmer manipulate pointers explicitly, and adhere to the restriction that each field of a structure can contain only elements of a prespecified form. Unlike Lisp with its pairs, these languages have no built-in general-purpose glue that makes it easy to manipulate compound data in a uniform way. This limitation lies behind Alan Perlis's comment in his foreword to this book: &quot;In Pascal the plethora of declarable data structures induces a specialization within functions that inhibits and penalizes casual cooperation. It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.&quot;</p>
</div>
<h3><a class="header" href="#representing-sequences" id="representing-sequences">Representing Sequences</a></h3>
<p><a name="figure-4"></a></p>
<p><img src="ch2/images/ch2-Z-G-13.png" alt="The sequence 1, 2, 3, 4 represented as a chain of pairs" /></p>
<p><strong>Figure 2.4</strong>: The sequence 1, 2, 3, 4 represented as a chain of pairs.</p>
<p>One of the useful structures we can build with pairs is a <em>sequence</em> -- an ordered collection of data objects. There are, of course, many ways to represent sequences in terms of pairs. One particularly straightforward representation is illustrated in the figure above, where the sequence 1, 2, 3, 4 is represented as a chain of pairs. The <code>car</code> of each pair is the corresponding item in the chain, and the <code>cdr</code> of the pair is the next pair in the chain. The <code>cdr</code> of the final pair signals the end of the sequence by pointing to a distinguished value that is not a pair, represented in box-and-pointer diagrams as a diagonal line and in programs as the value of the empty list.<sup class="footnote-reference"><a href="#1">1</a></sup> The entire sequence is constructed by nested <code>cons</code> operations:</p>
<pre><code class="language-lisp">(cons 1 (cons 2 (cons 3 (cons 4 '()))))
</code></pre>
<p>Such a sequence of pairs, formed by nested <code>cons</code>es, is called a <em>list</em>, and Scheme provides a primitive called list to help in constructing lists.<sup class="footnote-reference"><a href="#2">2</a></sup> The above sequence could be produced by <code>(list 1 2 3 4)</code>. In general,</p>
<pre><code class="language-lisp">(list &lt;a1&gt; &lt;a2&gt; ... &lt;an&gt;)
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-lisp">(cons &lt;a1&gt; (cons &lt;a2&gt; (cons ... (cons &lt;an&gt; '()) ... ))
</code></pre>
<p>Lisp systems conventionally print lists by printing the sequence of elements, enclosed in parentheses. Thus, the data object in figure 2.4 is printed as <code>(1 2 3 4)</code>:</p>
<pre><code class="language-lisp">&gt; (set one-through-four (list 1 2 3 4))
(1 2 3 4)
</code></pre>
<p>Be careful not to confuse the expression <code>(list 1 2 3 4)</code> with the list <code>(1 2 3 4)</code>, which is the result obtained when the expression is evaluated. Attempting to evaluate the expression <code>(1 2 3 4)</code> will signal an error when the interpreter tries to apply the function <code>1/3</code> to arguments <code>2</code>, <code>3</code>, and <code>4</code>.</p>
<p>We can think of <code>car</code> as selecting the first item in the list, and of <code>cdr</code> as selecting the sublist consisting of all but the first item. Nested applications of <code>car</code> and <code>cdr</code> can be used to extract the second, third, and subsequent items in the list.<sup class="footnote-reference"><a href="#3">3</a></sup> The constructor <code>cons</code> makes a list like the original one, but with an additional item at the beginning.</p>
<pre><code class="language-lisp">&gt; (car one-through-four)
1
&gt; (cdr one-through-four)
(2 3 4)
&gt; (car (cdr one-through-four))
2
&gt; (cons 10 one-through-four)
(10 1 2 3 4)
&gt; (cons 5 one-through-four)
(5 1 2 3 4)
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The empty list will be discussed more in the section <a href="ch2/">Symbolic Data</a> when we cover the topic of quoting.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>In this book, we use <em>list</em> to mean a chain of pairs terminated by the end-of-list marker. In contrast, the term <em>list structure</em> refers to any data structure made out of pairs, not just to lists.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Since nested applications of <code>car</code> and <code>cdr</code> are cumbersome to write, Lisp dialects provide abbreviations for them -- for instance, <code>(cadr &lt;arg&gt;)</code> is equivalent to <code>(car (cdr &lt;arg&gt;))</code>. The names of all such functions start with <code>c</code> and end with <code>r</code>. Each <code>a</code> between them stands for a <code>car</code> operation and each <code>d</code> for a <code>cdr</code> operation, to be applied in the same order in which they appear in the name. The names <code>car</code> and <code>cdr</code> persist because simple combinations like cadr are pronounceable.</p>
</div>
<h4><a class="header" href="#list-operations" id="list-operations">List Operations</a></h4>
<p>The use of pairs to represent sequences of elements as lists is accompanied by conventional programming techniques for manipulating lists by successively &quot;<code>cdr</code>ing down&quot; the lists. For example, the function <code>list-ref/2</code> takes as arguments a list and a number $$n$$ and returns the $$n$$th item of the list. In Erlang, and thus LFE, is customary to number the elements of the list beginning with 1. The method for computing <code>list-ref/2</code> is the following: <sup class="footnote-reference"><a href="#1">1</a></sup></p>
<ul>
<li>For $$n = 1$$, <code>list-ref/2</code> should return the <code>car</code> of the list.</li>
<li>Otherwise, <code>list-ref/2</code> should return the $$n$$th item of the <code>cdr</code> of the list.</li>
</ul>
<pre><code class="language-lisp">(defun list-ref
  ((items 1)
   (car items))
  ((items n)
   (list-ref (cdr items) (- n 1))))
</code></pre>
<pre><code class="language-lisp">&gt; (set squares (list 1 4 9 16 25))
(1 4 9 16 25)
&gt; (list-ref squares 4)
16
</code></pre>
<p>Note, though, that with LFE we can simplify this process: when we use pattern matching on the function arguments, we don't need to explicitly call <code>car</code> and <code>cdr</code> -- we get those for free. The previous function can be rewritten to take advantage of this: <sup class="footnote-reference"><a href="#2">2</a></sup>:</p>
<pre><code class="language-lisp">(defun list-ref
  (((cons head _) 1)
   head)
  (((cons _ tail) n)
   (list-ref tail (- n 1))))
</code></pre>
<p>Often we &quot;<code>cdr</code> down&quot; the whole list. The function <code>len/1</code>,<sup class="footnote-reference"><a href="#3">3</a></sup> which returns the number of items in a list, illustrates this typical pattern of use:</p>
<pre><code class="language-lisp">(defun len
  (('())
   0)
  ((items)
   (+ 1 (len (cdr items)))))
</code></pre>
<pre><code class="language-lisp">&gt; (set odds (list 1 3 5 7))
(1 3 5 7)
&gt; (len odds)
4
</code></pre>
<p>Again, we can rewrite that using LFE <code>cons</code>ing in the function arguments:</p>
<pre><code class="language-lisp">(defun len
  (('())
   0)
  (((cons _ tail))
   (+ 1 (len tail))))
</code></pre>
<p>The <code>len/1</code> function implements a simple recursive plan. The reduction step is:</p>
<ul>
<li>The length of any list is 1 plus the length of the <code>cdr</code> of the list.</li>
</ul>
<p>This is applied successively until we reach the base case:</p>
<ul>
<li>The passed list matches the pattern of the empty list.</li>
</ul>
<p>We could also compute length in an iterative style:</p>
<pre><code class="language-lisp">(defun len (items)
  (len items 0))

(defun len
  (('() count)
   count)
  (((cons _ tail) count)
   (len tail (+ 1 count))))
</code></pre>
<p>Another conventional programming technique is to &quot;<code>cons</code> up&quot; an answer list while <code>cdr</code>ing down a list, as in the function <code>append/2</code>,<sup class="footnote-reference"><a href="#4">4</a></sup> which takes two lists as arguments and combines their elements to make a new list:</p>
<pre><code class="language-lisp">&gt; (append squares odds)
(1 4 9 16 25 1 3 5 7)
&gt; (append odds squares)
(1 3 5 7 1 4 9 16 25)
</code></pre>
<p><code>append/2</code> is also implemented using a recursive plan. To append lists <code>list1</code> and <code>list2</code>, do the following:</p>
<ul>
<li>If <code>list1</code> is the empty list, then the result is just <code>list2</code>.</li>
<li>Otherwise, append the <code>cdr</code> of <code>list1</code> and <code>list2</code>, and <code>cons</code> the <code>car</code> of <code>list1</code> onto the result.</li>
</ul>
<p>We will first show without <code>cons</code> pattern-matching:</p>
<pre><code class="language-lisp">(defun append
  (('() list2)
   list2)
  ((list1 list2)
   (cons (car list1) (append (cdr list1) list2))))
</code></pre>
<p>With <code>cons</code> pattern-matching, we have this as</p>
<pre><code class="language-lisp">(defun append
  (('() list2)
   list2)
  (((cons head tail) list2)
   (cons head (append tail list2))))
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This function is provided for pedagogical purposes and that one should usually rely upon the function from the Erlang <code>lists</code> module: <code>(lists:nth 4 squares)</code>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Pattern-matching by<code>cons</code>ing in function arguments is very common in both Erlang and LFE code. We will be making good use of it in further examples.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>One should normally not define one's own <code>len/1</code> function, but instead use the built-in <code>erlang:length/1</code> function which is also available as simply <code>length/1</code>.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Similarly, the Erlang function <code>lists:append/2</code> (or <code>lists:append/1</code>) generally should be used instead.</p>
</div>
<h3><a class="header" href="#exercises-16" id="exercises-16">Exercises</a></h3>
<h4><a class="header" href="#exercise-217" id="exercise-217">Exercise 2.17</a></h4>
<p>Define a function <code>last-pair/1</code> that returns the list that contains only the last element of a given (nonempty) list:</p>
<pre><code class="language-lisp">&gt; (last-pair (list 23 72 149 34))
(34)
</code></pre>
<h4><a class="header" href="#exercise-218" id="exercise-218">Exercise 2.18</a></h4>
<p>Define a function <code>reverse/1</code> that takes a list as argument and returns a list of the same elements in reverse order:</p>
<pre><code class="language-lisp">&gt; (reverse (list 1 4 9 16 25))
(25 16 9 4 1)
</code></pre>
<h4><a class="header" href="#exercise-219" id="exercise-219">Exercise 2.19</a></h4>
<p>Consider the change-counting program of the section <a href="ch2/">Tree Recursion</a>. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the function <code>first-denomination/1</code> and partly into the function <code>count-change/1</code> (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.</p>
<p>We want to rewrite the function <code>cc/2</code> so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:</p>
<pre><code class="language-lisp">&gt; (set us-coins (list 50 25 10 5 1))
(50 25 10 5 1)
&gt; (set uk-coins (list 100 50 20 10 5 2 1 0.5))
(100 50 20 10 5 2 1 0.5)
</code></pre>
<p>We could then call <code>cc/2</code> as follows:</p>
<pre><code class="language-lisp">&gt; (cc 100 us-coins)
292
</code></pre>
<p>To do this will require changing the program <code>cc/2</code> somewhat. It will still have the same form, but it will access its second argument differently, as follows:</p>
<pre><code class="language-lisp">(defun cc
  ((0 _) 1)
  ((amount coin-values)
   (if (or (&lt; amount 0) (no-more? coin-values))
       0
       (+ (cc amount
              (except-first-denomination coin-values))
          (cc (- amount
                 (first-denomination coin-values))
              coin-values)))))
</code></pre>
<p>Define the functions <code>first-denomination/1</code>, <code>except-first-denomination/1</code>, and <code>no-more?/1</code> in terms of primitive operations on list structures. Does the order of the list coin-values affect the answer produced by <code>cc/2</code>? Why or why not?</p>
<h4><a class="header" href="#exercise-220" id="exercise-220">Exercise 2.20</a></h4>
<p>Removed from the LFE Edition.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>In the Scheme 2nd edition, <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html">Exercise 2.20</a> covers a feature in Scheme that is not present in LFE. The analog would require creating a macro with a single parameter that is the body of the code; as we haven't covered quoting or macros yet, this is not a suitable exercise at this point.</p>
</div>
<h4><a class="header" href="#mapping-over-lists" id="mapping-over-lists">Mapping over lists</a></h4>
<p>One extremely useful operation is to apply some transformation to each element in a list and generate the list of results. For instance, the following function scales each number in a list by a given factor:</p>
<pre><code class="language-lisp">(defun scale-list
  (('() _)
   '())
  (((cons head tail) factor)
   (cons (* head factor)
         (scale-list tail factor))))
</code></pre>
<pre><code class="language-lisp">&gt; (scale-list (list 1 2 3 4 5) 10)
(10 20 30 40 50)
</code></pre>
<p>We can abstract this general idea and capture it as a common pattern expressed as a higher-order function, just as in the section <a href="ch2/">Formulating Abstractions with Higher-Order Functions</a>. The higher-order function here is called <code>mapper/2</code>.<sup class="footnote-reference"><a href="#1">1</a></sup> <code>mapper/2</code> takes as arguments a function of one argument and a list, and returns a list of the results produced by applying the function to each element in the list:<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<pre><code class="language-lisp">(defun mapper
  ((_ '())
   '())
  ((func (cons head tail))
   (cons (funcall func head)
         (mapper func tail))))
</code></pre>
<pre><code class="language-lisp">&gt; (mapper #'abs/1 (list -10 2.5 -11.6 17))
(10 2.5 11.6 17)
&gt; (mapper (lambda (x) (* x x))
     (list 1 2 3 4))
(1 4 9 16)
</code></pre>
<p>Now we can give a new definition of <code>scale-list/2</code> in terms of <code>mapper/2</code>:</p>
<pre><code class="language-lisp">(defun scale-list (items factor)
  (mapper
    (lambda (x) (* x factor))
    items))
</code></pre>
<p><code>mapper/2</code> is an important construct, not only because it captures a common pattern, but because it establishes a higher level of abstraction in dealing with lists. In the original definition of <code>scale-list/2</code>, the recursive structure of the program draws attention to the element-by-element processing of the list. Defining <code>scale-list/2</code> in terms of <code>mapper/2</code> suppresses that level of detail and emphasizes that scaling transforms a list of elements to a list of results. The difference between the two definitions is not that the computer is performing a different process (it isn't) but that we think about the process differently. In effect, <code>mapper/2</code> helps establish an abstraction barrier that isolates the implementation of functions that transform lists from the details of how the elements of the list are extracted and combined. Like the barriers shown in <a href="ch2/abstraction-barriers.html#figure-1">figure 2.1</a>, this abstraction gives us the flexibility to change the low-level details of how sequences are implemented, while preserving the conceptual framework of operations that transform sequences to sequences. The section <a href="ch2/">Sequences as Conventional Interfaces</a> expands on this use of sequences as a framework for organizing programs.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Functions with this behaviour are ordinarily called <code>map</code>, however the <code>map</code> name in LFE is already taken for creating Erlang map data structures.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>The canonical <code>map</code> function used in LFE is <code>lists:map/2</code>.</p>
</div>
<h3><a class="header" href="#exercises-17" id="exercises-17">Exercises</a></h3>
<h4><a class="header" href="#exercise-221" id="exercise-221">Exercise 2.21</a></h4>
<p>The function <code>square-list/1</code> takes a list of numbers as argument and returns a list of the squares of those numbers.</p>
<pre><code class="language-lisp">&gt; (square-list (list 1 2 3 4))
(1 4 9 16)
</code></pre>
<p>Here are two different definitions of <code>square-list/1</code>. Complete both of them by filling in the missing expressions:</p>
<pre><code class="language-lisp">(defun square-list
  (('()) '())
  ((items) (cons &lt;??&gt; &lt;??&gt;)))
</code></pre>
<pre><code class="language-lisp">(defun square-list (items)
  (map &lt;??&gt; &lt;??&gt;))
</code></pre>
<h4><a class="header" href="#exercise-222" id="exercise-222">Exercise 2.22</a></h4>
<p>Louis Reasoner tries to rewrite the first square-list function of exercise 2.21 so that it evolves an iterative process:</p>
<pre><code class="language-lisp">(defun square-list (items)
  (square-list items '()))

(defun square-list
  (('() answer) answer)
  (((cons head tail) answer)
    (square-list tail
                 (cons (square head)
                       answer))))
</code></pre>
<p>Unfortunately, defining <code>square-list</code> this way produces the answer list in the reverse order of the one desired. Why?</p>
<p>Louis then tries to fix his bug by interchanging the arguments to cons:</p>
<pre><code class="language-lisp">(defun square-list (items)
  (square-list items '()))

(defun square-list
  (('() answer) answer)
  (((cons head tail) answer)
    (square-list tail
                 (cons answer
                       (square head)))))
</code></pre>
<p>This doesn't work either. Explain.</p>
<h4><a class="header" href="#exercise-223" id="exercise-223">Exercise 2.23</a></h4>
<p>The built-in LFE function <code>lists:foreach/2</code> is similar to our <code>mapper/2</code> and the built-in <code>lists:map/2</code>. It takes as arguments a function and a list of elements. However, rather than forming a list of the results, <code>foreach/2</code> just applies the function to each of the elements in turn, from left to right. The values returned by applying the function to the elements are not used at all -- <code>foreach/2</code> is used with functions that perform an action, such as printing. For example,</p>
<pre><code class="language-lisp">&gt; (lists:foreach (lambda (x) (io:format &quot;~n~p~n&quot; (list x)))
                 (list 57 321 88))
57
321
88
</code></pre>
<p>The value returned by the call to <code>foreach/2</code> (not illustrated above) can be something arbitrary, such as <code>true</code>. Give an implementation of <code>foreach/2</code> that mimics the behaviour of the built-in function.</p>
<h3><a class="header" href="#hierarchical-structures" id="hierarchical-structures">Hierarchical Structures</a></h3>
<p>The representation of sequences in terms of lists generalizes naturally to represent sequences whose elements may themselves be sequences. For example, we can regard the object <code>((1 2) 3 4)</code> constructed by</p>
<pre><code class="language-lisp">(cons (list 1 2) (list 3 4))
</code></pre>
<p>as a list of three items, the first of which is itself a list, <code>(1 2)</code>. Indeed, this is suggested by the form in which the result is printed by the interpreter. The figure below shows the representation of this structure in terms of pairs.</p>
<p><a name="figure-5"></a></p>
<p><img src="ch2/images/ch2-Z-G-15.png" alt="Structure formed by (cons (list 1 2) (list 3 4))" /></p>
<p><strong>Figure 2.5</strong>: Structure formed by <code>(cons (list 1 2) (list 3 4))</code>.</p>
<p>Another way to think of sequences whose elements are sequences is as <em>trees</em>. The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees. Figure 2.6 shows the structure in figure 2.5 viewed as a tree.</p>
<p><a name="figure-6"></a></p>
<p><img src="ch2/images/ch2-Z-G-16.png" alt="The list structure in figure 2.5 viewed as a tree" /></p>
<p><strong>Figure 2.6</strong>: The list structure in figure 2.5 viewed as a tree.</p>
<p>Recursion is a natural tool for dealing with tree structures, since we can
often reduce operations on trees to operations on their branches, which reduce
in turn to operations on the branches of the branches, and so on, until we
reach the leaves of the tree. As an example, compare the <code>len/1</code> function of
the section <a href="ch2/">Representing Sequences</a> with the <code>count-leaves/1</code> function, which returns the total number of leaves of a tree:</p>
<pre><code class="language-lisp">&gt; (set x (cons (list 1 2) (list 3 4)))
((1 2) 3 4)
&gt; (len x)
3
&gt; (count-leaves x)
4
&gt; (list x x)
(((1 2) 3 4) ((1 2) 3 4))
&gt; (len (list x x))
2
&gt; (count-leaves (list x x))
8
</code></pre>
<p>To implement <code>count-leaves/1</code>, recall the recursive plan for computing <code>len/1</code>:</p>
<ul>
<li><code>len/1</code> of a list <code>x</code> is 1 plus <code>len/1</code> of the <code>cdr</code> of <code>x</code>.</li>
<li><code>len/1</code> of the empty list is 0.</li>
</ul>
<p><code>count-leaves/1</code> is similar. The value for the empty list is the same:</p>
<ul>
<li><code>count-leaves/1</code> of the empty list is 0.</li>
</ul>
<p>But in the reduction step, where we strip off the car of the list, we must take into account that the car may itself be a tree whose leaves we need to count. Thus, the appropriate reduction step is</p>
<ul>
<li><code>count-leaves/1</code> of a tree <code>x</code> is <code>count-leaves/1</code> of the <code>car</code> of <code>x</code> plus <code>count-leaves/1</code> of the <code>cdr</code> of <code>x</code>.</li>
</ul>
<p>Finally, by taking <code>car</code>s we reach actual leaves, so we need another base case:</p>
<ul>
<li><code>count-leaves/1</code> of a leaf is 1.</li>
</ul>
<p>Here is the complete function:</p>
<pre><code class="language-lisp">(defun count-leaves
  (('()) 0)
  (((cons head tail))
    (+ (count-leaves head)
       (count-leaves tail)))
  ((_) 1))
</code></pre>
<p>Once again we use pattern matching in the function arguments. In particular, note when the <code>cons</code> pattern fails to match on a single element, the final and default pattern succeeds, returning the count for a leaf.</p>
<h3><a class="header" href="#exercises-18" id="exercises-18">Exercises</a></h3>
<h4><a class="header" href="#exercise-224" id="exercise-224">Exercise 2.24</a></h4>
<p>Suppose we evaluate the expression <code>(list 1 (list 2 (list 3 4)))</code>. Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree diagram.</p>
<h4><a class="header" href="#exercise-225" id="exercise-225">Exercise 2.25</a></h4>
<p>Give combinations of <code>car</code>s and <code>cdr</code>s that will pick 7 from each of the following lists:</p>
<pre><code class="language-lisp">(1 3 (5 7) 9)

((7))

(1 (2 (3 (4 (5 (6 7))))))
</code></pre>
<h4><a class="header" href="#exercise-226" id="exercise-226">Exercise 2.26</a></h4>
<p>Suppose we define x and y to be two lists:</p>
<pre><code class="language-lisp">(defun x () (list 1 2 3))
(defun y () (list 4 5 6))
</code></pre>
<p>What result is printed by the interpreter in response to evaluating each of the following expressions:</p>
<pre><code class="language-lisp">(append (x) (y))
</code></pre>
<pre><code class="language-lisp">(cons (x) (y))
</code></pre>
<pre><code class="language-lisp">(list (x) (y))
</code></pre>
<h4><a class="header" href="#exercise-227" id="exercise-227">Exercise 2.27</a></h4>
<p>Modify your reverse function of exercise 2.18 to produce a deep-reverse function that takes a list as argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well. For example,</p>
<pre><code class="language-lisp">&gt; (defun x () (list (list 1 2) (list 3 4)))
x
&gt; (x)
((1 2) (3 4))
&gt; (reverse (x))
((3 4) (1 2))
&gt; (deep-reverse (x))
((4 3) (2 1))
</code></pre>
<h4><a class="header" href="#exercise-228" id="exercise-228">Exercise 2.28</a></h4>
<p>Write a function <code>fringe</code> that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order. For example,</p>
<pre><code class="language-lisp">&gt; (defun x () (list (list 1 2) (list 3 4)))
&gt; (fringe (x))
(1 2 3 4)
&gt; (fringe (list (x) (x)))
(1 2 3 4 1 2 3 4)
</code></pre>
<h4><a class="header" href="#exercise-229" id="exercise-229">Exercise 2.29</a></h4>
<p>A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compound data by constructing it from two branches (for example, using <code>list</code>):</p>
<pre><code class="language-lisp">(defun make-mobile (left right)
  (list left right))
</code></pre>
<p>A branch is constructed from a <code>length</code> (which must be a number) together with a <code>structure</code>, which may be either a number (representing a simple weight) or another mobile:</p>
<pre><code class="language-lisp">(defun make-branch (length structure)
  (list length structure))
</code></pre>
<p>a.  Write the corresponding selectors <code>left-branch</code> and <code>right-branch</code>, which return the branches of a mobile, and <code>branch-length</code> and <code>branch-structure</code>, which return the components of a branch.</p>
<p>b.  Using your selectors, define a function <code>total-weight</code> that returns the total weight of a mobile.</p>
<p>c.  A mobile is said to be <em>balanced</em> if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced. Design a predicate that tests whether a binary mobile is balanced.</p>
<p>d.  Suppose we change the representation of mobiles so that the constructors are</p>
<pre><code class="language-lisp">(defun make-mobile (left right)
  (cons left right))
(defun make-branch (length structure)
  (cons length structure))
</code></pre>
<p>How much do you need to change your programs to convert to the new representation?</p>
<h4><a class="header" href="#mapping-over-trees" id="mapping-over-trees">Mapping over trees</a></h4>
<p>Just as <code>map</code> is a powerful abstraction for dealing with sequences, <code>map</code> together with recursion is a powerful abstraction for dealing with trees. For instance, the <code>scale-tree/2</code> function, analogous to <code>scale-list/2</code> of the section <a href="ch2/">Representing Sequences</a>, takes as arguments a numeric factor and a tree whose leaves are numbers. It returns a tree of the same shape, where each number is multiplied by the factor. The recursive plan for <code>scale-tree/2</code> is similar to the one for <code>count-leaves/2</code>:</p>
<pre><code class="language-lisp">(defun scale-tree
  (('() _)
   '())
  (((cons head tail) factor)
   (cons (scale-tree head factor)
         (scale-tree tail factor)))
  ((tree factor)
    (* tree factor)))
</code></pre>
<pre><code class="language-lisp">&gt; (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 100)
(100 (200 (300 400) 500) (600 700))
</code></pre>
<p>Another way to implement <code>scale-tree/2</code> is to regard the tree as a sequence of sub-trees and use <code>map</code>. We map over the sequence, scaling each sub-tree in turn, and return the list of results. In the base case, where the tree is a leaf, we simply multiply by the factor:</p>
<pre><code class="language-lisp">(defun scale-tree (tree factor)
  (lists:map #'scale-sub-tree/1 tree))
       
(defun scale-sub-tree
  ((sub-tree) (when (is_integer sub-tree))
   (* sub-tree factor))
  ((sub-tree)
   (scale-tree sub-tree factor)))
</code></pre>
<pre><code class="language-lisp">&gt; (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 100)
(100 (200 (300 400) 500) (600 700))
</code></pre>
<p>Many tree operations can be implemented by similar combinations of sequence operations and recursion.</p>
<h3><a class="header" href="#exercises-19" id="exercises-19">Exercises</a></h3>
<h4><a class="header" href="#exercise-230" id="exercise-230">Exercise 2.30</a></h4>
<p>Define a function <code>square-tree</code> analogous to the <code>square-list</code> function of exercise 2.21. That is, <code>square-list</code> should behave as follows:</p>
<pre><code class="language-lisp">&gt; (square-tree
    (list 1
          (list 2 (list 3 4) 5)
          (list 6 7)))
(1 (4 (9 16) 25) (36 49))
</code></pre>
<p>Define <code>square-tree</code> both directly (i.e., without using any higher-order functions) and also by using <code>map</code> and recursion.</p>
<h4><a class="header" href="#exercise-231" id="exercise-231">Exercise 2.31</a></h4>
<p>Abstract your answer to exercise 2.30 to produce a function <code>tree-map</code> with the property that <code>square-tree</code> could be defined as</p>
<pre><code class="language-lisp">(defun square-tree (tree)
  (tree-map square tree))
</code></pre>
<h4><a class="header" href="#exercise-232" id="exercise-232">Exercise 2.32</a></h4>
<p>We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is <code>(1 2 3)</code>, then the set of all subsets is <code>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</code>. Complete the following definition of a function that generates the set of subsets of a set and give a clear explanation of why it works:</p>
<pre><code class="language-lisp">(defun subsets
  (('())
   '(()))
  (((cons _ tail))
   (let ((rest (subsets tail)))
     (append rest (lists:map &lt;??&gt; rest)))))
</code></pre>
<h3><a class="header" href="#sequences-as-conventional-interfaces" id="sequences-as-conventional-interfaces">Sequences as Conventional Interfaces</a></h3>
<p>In working with compound data, we've stressed how data abstraction permits us to design programs without becoming enmeshed in the details of data representations, and how abstraction preserves for us the flexibility to experiment with alternative representations. In this section, we introduce another powerful design principle for working with data structures -- the use of <em>conventional interfaces</em>.</p>
<p>In the section <a href="ch2/">Formulating Abstractions with Higher-Order Functions</a> we saw how program abstractions, implemented as higher-order functions, can capture common patterns in programs that deal with numerical data. Our ability to formulate analogous operations for working with compound data depends crucially on the style in which we manipulate our data structures. Consider, for example, the following function, analogous to the <code>count-leaves/2</code> function of the section <a href="ch2/">Hierarchical Structures</a>, which takes a tree as argument and computes the sum of the squares of the leaves that are odd:</p>
<pre><code class="language-lisp">(defun odd? (n)
  (=:= 1 (rem (trunc n) 2)))

(defun sum-odd-squares
  (('())
    0)
  (((cons head tail))
    (+ (sum-odd-squares head)
       (sum-odd-squares tail)))
  ((elem)
    (if (funcall #'odd?/1 elem)
        (square elem)
        0)))
</code></pre>
<p>On the surface, this function is very different from the following one, which constructs a list of all the even Fibonacci numbers $$Fib(k)$$, where $$k$$ is less than or equal to a given integer $$n$$:</p>
<pre><code class="language-lisp">(defun even-fibs (n)
  (fletrec ((next (k)
              (if (&gt; k n)
                  '()
                  (let ((f (fib k)))
                    (if (even? f)
                        (cons f (next (+ k 1)))
                        (next (+ k 1)))))))
    (next 0)))
</code></pre>
<p>Despite the fact that these two functions are structurally very different, a more abstract description of the two computations reveals a great deal of similarity. The first program</p>
<ul>
<li>enumerates the leaves of a tree;</li>
<li>filters them, selecting the odd ones;</li>
<li>squares each of the selected ones; and</li>
<li>accumulates the results using <code>+</code>, starting with 0.</li>
</ul>
<p>The second program</p>
<ul>
<li>enumerates the integers from 0 to $$n$$;</li>
<li>computes the Fibonacci number for each integer;</li>
<li>filters them, selecting the even ones; and</li>
<li>accumulates the results using <code>cons</code>, starting with the empty list.</li>
</ul>
<p>A signal-processing engineer would find it natural to conceptualize these processes in terms of signals flowing through a cascade of stages, each of which implements part of the program plan, as shown in figure 2.7. In <code>sum-odd-squares/1</code>, we begin with an <em>enumerator</em>, which generates a &quot;signal&quot; consisting of the leaves of a given tree. This signal is passed through a <em>filter</em>, which eliminates all but the odd elements. The resulting signal is in turn passed through a <em>map</em>, which is a &quot;transducer&quot; that applies the square function to each element. The output of the map is then fed to an <em>accumulator</em>, which combines the elements using <code>+</code>, starting from an initial <code>0</code>. The plan for <code>even-fibs/1</code> is analogous.</p>
<p><a name="figure-7"></a></p>
<p><img src="ch2/images/ch2-Z-G-17.png" alt="Signal-flow plans" /></p>
<p><strong>Figure 2.7</strong>: The signal-flow plans for the functions <code>sum-odd-squares/1</code> (top) and <code>even-fibs/1</code> (bottom) reveal the commonality between the two programs.</p>
<p>Unfortunately, the two function definitions above fail to exhibit this
signal-flow structure. For instance, if we examine the <code>sum-odd-squares/1</code>
function, we find that the enumeration is implemented partly by the pattern
matching tests and partly by the tree-recursive structure of the function.
Similarly, the accumulation is found partly in the tests and partly in the
addition used in the recursion. In general, there are no distinct parts of
either function that correspond to the elements in the signal-flow description.
Our two functions decompose the computations in a different way, spreading the
enumeration over the program and mingling it with the map, the filter, and the
accumulation. If we could organize our programs to make the signal-flow
structure manifest in the functions we write, this would increase the conceptual clarity of the resulting code.</p>
<h4><a class="header" href="#sequence-operations" id="sequence-operations">Sequence Operations</a></h4>
<p>The key to organizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the &quot;signals&quot; that flow from one stage in the process to the next. If we represent these signals as lists, then we can use list operations to implement the processing at each of the stages. For instance, we can implement the mapping stages of the signal-flow diagrams using the <code>mapper/2</code> function from the section <a href="ch2/">Representing Sequences</a>:</p>
<pre><code class="language-lisp">&gt; (mapper #'square/1 (list 1 2 3 4 5))
(1 4 9 16 25)
</code></pre>
<p>Filtering a sequence to select only those elements that satisfy a given predicate is accomplished by</p>
<pre><code class="language-lisp">(defun filter
  ((_ '())
   '())
  ((predicate (cons head tail))
   (if (funcall predicate head)
       (cons head (filter predicate tail))
       (filter predicate tail))))
</code></pre>
<p>For example,</p>
<pre><code class="language-lisp">&gt; (filter #'odd?/1 (list 1 2 3 4 5))
(1 3 5)
</code></pre>
<p>Accumulations can be implemented by</p>
<pre><code class="language-lisp">(defun accumulate
  ((_ initial '())
   initial)
  ((op initial (cons head tail))
   (funcall op head (accumulate op initial tail))))
</code></pre>
<p>With usage such as</p>
<pre><code class="language-lisp">&gt; (accumulate #'+/2 0 (list 1 2 3 4 5))
15
&gt; (accumulate #'*/2 1 (list 1 2 3 4 5))
120
&gt; (accumulate #'cons/2 '() (list 1 2 3 4 5))
(1 2 3 4 5)
</code></pre>
<p>All that remains to implement signal-flow diagrams is to enumerate the sequence of elements to be processed. For <code>even-fibs/1</code>, we need to generate the sequence of integers in a given range, which we can do as follows<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<pre><code class="language-lisp">(defun enumerate-interval
  ((low high) (when (&gt; low high))
   '())
  ((low high)
   (cons low (enumerate-interval (+ low 1) high))))
</code></pre>
<pre><code class="language-lisp">&gt; (enumerate-interval 2 7)
(2 3 4 5 6 7)
</code></pre>
<p>To enumerate the leaves of a tree, we can use <sup class="footnote-reference"><a href="#2">2</a></sup>:</p>
<pre><code class="language-lisp">(defun enumerate-tree
  (('())
   '())
  (((cons head tail))
   (append (enumerate-tree head)
           (enumerate-tree tail)))
  ((tree)
   (list tree)))
</code></pre>
<pre><code class="language-lisp">&gt; (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
(1 2 3 4 5)
</code></pre>
<p>Now we can reformulate <code>sum-odd-squares/1</code> and <code>even-fibs/1</code> as in the signal-flow diagrams. For <code>sum-odd-squares/1</code>, we enumerate the sequence of leaves of the tree, filter this to keep only the odd numbers in the sequence, square each element, and sum the results:</p>
<pre><code class="language-lisp">(defun sum-odd-squares (tree)
  (accumulate #'+/2
              0
              (mapper #'square/1
                      (filter #'odd?/1
                              (enumerate-tree tree)))))
</code></pre>
<p>Compare that to our first implementation, noting how much more clear the code with composition is:</p>
<pre><code class="language-lisp">(defun sum-odd-squares
  (('())
    0)
  (((cons head tail))
    (+ (sum-odd-squares head)
       (sum-odd-squares tail)))
  ((elem)
    (if (odd?)
        (square elem)
        0)))
</code></pre>
<p>For <code>even-fibs/1</code>, we enumerate the integers from 0 to $$n$$, generate the Fibonacci number for each of these integers, filter the resulting sequence to keep only the even elements, and accumulate the results into a list:</p>
<pre><code class="language-lisp">(defun even-fibs (n)
  (accumulate #'cons/2
              '()
              (filter #'even?/1
                      (mapper #'fib/1
                              (enumerate-interval 0 n)))))
</code></pre>
<p>Again, compare with the original, where the contrast in clarity is even more stark than in the previous example: <sup class="footnote-reference"><a href="#3">3</a></sup></p>
<pre><code class="language-lisp">(defun even-fibs (n)
  (fletrec ((next (k)
              (if (&gt; k n)
                  '()
                  (let ((f (fib k)))
                    (if (even? f)
                        (cons f (next (+ k 1)))
                        (next (+ k 1)))))))
    (next 0)))
</code></pre>
<p>The value of expressing programs as sequence operations is that this helps us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces. We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways.</p>
<p>Modular construction is a powerful strategy for controlling complexity in
engineering design. In real signal-processing applications, for example,
designers regularly build systems by cascading elements selected from
standardized families of filters and transducers. Similarly, sequence
operations provide a library of standard program elements that we can mix and
match. For instance, we can reuse pieces from the <code>sum-odd-squares/1</code> and
<code>even-fibs/1</code> functions in a program that constructs a list of the squares of the first $$n + 1$$ Fibonacci numbers:</p>
<pre><code class="language-lisp">(defun list-fib-squares (n)
  (accumulate #'cons/2
              '()
              (mapper #'square/1
                      (mapper #'fib/1
                              (enumerate-interval 0 n)))))
</code></pre>
<pre><code class="language-lisp">&gt; (list-fib-squares 10)
(0 1 1 4 9 25 64 169 441 1156 3025)
</code></pre>
<p>We can rearrange the pieces and use them in computing the product of the odd integers in a sequence:</p>
<pre><code class="language-lisp">(defun product-of-squares-of-odd-elements (sequence)
  (accumulate #'*/2
              1
              (mapper #'square/1
                      (filter #'odd?/1 sequence))))
</code></pre>
<pre><code class="language-lisp">&gt; (product-of-squares-of-odd-elements (list 1 2 3 4 5))
225
</code></pre>
<p>We can also formulate conventional data-processing applications in terms of sequence operations. Suppose we have a sequence of personnel records and we want to find the salary of the highest-paid programmer. Assume that we have a selector <code>salary</code> that returns the salary of a record, and a predicate <code>programmer?/1</code> that tests if a record is for a programmer. Then we can write</p>
<pre><code class="language-lisp">(defun salary-of-highest-paid-programmer (records)
  (accumulate #'max/2
              0
              (mapper #'salary/1
                      (filter #'programmer?/1 records))))
</code></pre>
<p>These examples give just a hint of the vast range of operations that can be expressed as sequence operations. <sup class="footnote-reference"><a href="#4">4</a></sup></p>
<p>Sequences, implemented here as lists, serve as a conventional interface that permits us to combine processing modules. Additionally, when we uniformly represent structures as sequences, we have localized the data-structure dependencies in our programs to a small number of sequence operations. By changing these, we can experiment with alternative representations of sequences, while leaving the overall design of our programs intact. We will exploit this capability in the section <a href="ch2/">Streams</a>, when we generalize the sequence-processing paradigm to admit infinite sequences.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>In an actual program you would want to use the BIF (built-in function) <code>lists:seq/2</code> instead of creating your own less efficient version as is done here.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This is, in fact, precisely the <code>fringe</code> function from exercise 2.28. Here we've renamed it to emphasize that it is part of a family of general sequence-manipulation functions.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>This importance of this type of refactoring is hard to over-emphasize in real-world applications. Long-term maintainability of large software projects is one of the greatest hidden costs in the industry, often providing the impetus for complete rewrites, and even greater wastes of time and resources. In the heat of solving a problem, it can be difficult to view the work clearly enough to think in terms of the patterns discussed here, but we must try; anything less is just endless patchwork which ultimately prevents us from truly practicing our professions. Finding bugs, adding features, enhancing reusability -- all of these things being done in a timely and efficient manner depend upon the engineer 1) clearly observing the underlying patterns in a given portion of code, and 2) making that code as composable as appropriate for the recognized patterns and as is warranted by the given problem. As always, there is a balance to strike here: one must learn to distinguish <em>necessary elegance</em> from over-engineering and premature optimization. These are, however, skills that one gains over time.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Richard Waters (1979) developed a program that automatically analyzes traditional Fortran programs, viewing them in terms of maps, filters, and accumulations. He found that fully 90 percent of the code in the Fortran Scientific Subroutine Package fits neatly into this paradigm. One of the reasons for the success of Lisp as a programming language is that lists provide a standard medium for expressing ordered collections so that they can be manipulated using higher-order operations. The programming language APL owes much of its power and appeal to a similar choice. In APL all data are represented as arrays, and there is a universal and convenient set of generic operators for all sorts of array operations.</p>
</div>
<h3><a class="header" href="#exercises-20" id="exercises-20">Exercises</a></h3>
<h4><a class="header" href="#exercise-233" id="exercise-233">Exercise 2.33</a></h4>
<p>Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations:</p>
<pre><code class="language-lisp">(defun map (p seq)
  (accumulate (lambda (x y) &lt;??&gt;) '() seq))

(defun append (seq1 seq2)
  (accumulate #'cons/2 &lt;??&gt; &lt;??&gt;))

(defun length (seq)
  (accumulate &lt;??&gt; 0 seq))
</code></pre>
<h4><a class="header" href="#exercise-234" id="exercise-234">Exercise 2.34</a></h4>
<p>Evaluating a polynomial in $$x$$ at a given value of $$x$$ can be formulated as an accumulation. We evaluate the polynomial</p>
<p>$$
\begin{align}
a_n x^n + a_{n - 1} x^{n -1} + \cdots + a_1 x + a_0
\end{align}
$$</p>
<p>using a well-known algorithm called <em>Horner's rule</em>, which structures the computation as</p>
<p>$$
\begin{align}
( \cdots (a_n x + a_{n -1})x + \cdots + a_1)x + a_0
\end{align}
$$</p>
<p>In other words, we start with $$a_n$$, multiply by $$x$$, add $$a_{n-1}$$, multiply by $$x$$, and so on, until we reach $$a_0$$.<sup class="footnote-reference"><a href="#1">1</a></sup> Fill in the following template to produce a procedure that evaluates a polynomial using Horner's rule. Assume that the coefficients of the polynomial are arranged in a sequence, from $$a_0$$ through $$a_n$$.</p>
<pre><code class="language-lisp">(defun horner-eval (x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) &lt;??&gt;)
              0
              coefficient-sequence))
</code></pre>
<p>For example, to compute $$1 + 3x + 5x^3 + x^5$$ at $$x = 2$$ you would evaluate</p>
<pre><code class="language-lisp">(horner-eval 2 (list 1 3 0 5 0 1))
</code></pre>
<h4><a class="header" href="#exercise-235" id="exercise-235">Exercise 2.35</a></h4>
<p>Redefine count-leaves from the section <a href="ch2/">Hierarchical Structures</a> as an accumulation:</p>
<pre><code class="language-lisp">(defun count-leaves (t)
  (accumulate &lt;??&gt; &lt;??&gt; (mapper &lt;??&gt; &lt;??&gt;)))
</code></pre>
<h4><a class="header" href="#exercise-236" id="exercise-236">Exercise 2.36</a></h4>
<p>The procedure <code>accumulate-n/3</code> is similar to <code>accumulate/3</code> except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements. It applies the designated accumulation procedure to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results. For instance, if s is a sequence containing four sequences, <code>((1 2 3) (4 5 6) (7 8 9) (10 11 12))</code>, then the value of <code>(accumulate-n + 0 s)</code> should be the sequence <code>(22 26 30)</code>. Fill in the missing expressions in the following definition of <code>accumulate-n/3</code>:</p>
<pre><code class="language-lisp">(defun accumulate-n
  ((_ _ (cons '() _))
   '())
  ((op init seqs)
   (cons (accumulate op init &lt;??&gt;)
         (accumulate-n op init &lt;??&gt;))))
</code></pre>
<h4><a class="header" href="#exercise-237" id="exercise-237">Exercise 2.37</a></h4>
<p>Suppose we represent vectors $$v = (v_i)$$ as sequences of numbers, and matrices $$m = (m_{ij})$$ as sequences of vectors (the rows of the matrix). For example, the matrix</p>
<p>$$
\begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4 \
4 &amp; 5 &amp; 6 &amp; 6 \
6 &amp; 7 &amp; 8 &amp; 9
\end{bmatrix}
$$</p>
<p>is represented as the sequence <code>((1 2 3 4) (4 5 6 6) (6 7 8 9))</code>. With this representation, we can use sequence operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:</p>
<ul>
<li><code>(dot-product v w)</code> - returns the sum $$\Sigma_i v_i w_i$$</li>
<li><code>(matrix-*-vector m v)</code> - returns the vector of $$t$$ where $$t_i = \Sigma_j m_{ij} v_j$$</li>
<li><code>(matrix-*-matrix m n)</code> - returns the matrix $$p$$ where $$p_{ij} = \Sigma_k m_{ik} n_{kj}$$</li>
<li><code>(transpose m)</code> - returns the matrix $$n$$, where $$n_{ij} = m_{ji}$$ </li>
</ul>
<p>We can define the dot product as <sup class="footnote-reference"><a href="#2">2</a></sup></p>
<pre><code class="language-lisp">(defun dot-product (v w)
  (accumulate #'+/2 0 (mapper-n #'* v w)))
</code></pre>
<p>where <code>mapper2/2</code> takes a function and a list of lists where the arity of the function is the same number as the number of inner lists. This is because the first element of each list is passed to the function, then the second element of each list is passed, and so on, returning a list of the results. For example:</p>
<pre><code class="language-lisp">&gt; (mapper-n #'+/3
            (list (list 1 2 3)
                  (list 40 50 60)
                  (list 700 800 900))
(741 852 963)
</code></pre>
<p>or</p>
<pre><code class="language-lisp">&gt; (mapper-n (lambda (x y) (+ x (* 2 y)))
            (list (list 1 2 3)
                  (list 4 5 6)))
(9 12 15)
</code></pre>
<p>Write <code>mapper-n/2</code> and then fill in the missing expressions in the following functions for computing the other matrix operations. (The function <code>accumulate-n/3</code> is defined in exercise 2.36.)</p>
<pre><code class="language-lisp">(defun matrix-*-vector (m v)
  (mapper2 &lt;??&gt; m))

(defun transpose (mat)
  (accumulate-n &lt;??&gt; &lt;??&gt; mat))

(defun matrix-*-matrix (m n)
  (let ((cols (transpose n)))
    (mapper2 &lt;??&gt; m)))
</code></pre>
<h4><a class="header" href="#exercise-238" id="exercise-238">Exercise 2.38</a></h4>
<p>The <code>accumulate/3</code> function is also known as <code>fold-right/3</code><sup class="footnote-reference"><a href="#2">2</a></sup>, because it combines the first element of the sequence with the result of combining all the elements to the right. There is also a <code>fold-left/3</code><sup class="footnote-reference"><a href="#3">3</a></sup>, which is similar to <code>fold-right/3</code>, except that it combines elements working in the opposite direction:</p>
<pre><code class="language-lisp">(defun fold-left
  ((_ result '())
   result)
  ((op result (cons head tail))
   (fold-left op
              (funcall op result head)
              tail)))
</code></pre>
<p>What are the values of</p>
<pre><code class="language-lisp">(fold-right #'//2 1 (list 1 2 3))
</code></pre>
<pre><code class="language-lisp">(fold-left #'//2 1 (list 1 2 3))
</code></pre>
<pre><code class="language-lisp">(fold-right #'list/2 '() (list 1 2 3))
</code></pre>
<pre><code class="language-lisp">(fold-left #'list/2 '() (list 1 2 3))
</code></pre>
<p>Give a property that <code>op</code> should satisfy to guarantee that <code>fold-right/3</code> and <code>fold-left/3</code> will produce the same values for any sequence.</p>
<h4><a class="header" href="#exercise-239" id="exercise-239">Exercise 2.39</a></h4>
<p>Complete the following definitions of reverse (exercise 2.18) in terms of <code>fold-right/3</code> and <code>fold-left/3</code> from exercise 2.38:</p>
<pre><code class="language-lisp">(defun reverse (sequence)
  (fold-right (lambda (x y) &lt;??&gt;) '() sequence))
  
(defun reverse (sequence)
  (fold-left (lambda (x y) &lt;??&gt;) '() sequence))
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>According to Knuth (1981), this rule was formulated by W. G. Horner early in the nineteenth century, but the method was actually used by Newton over a hundred years earlier. Horner's rule evaluates the polynomial using fewer additions and multiplications than does the straightforward method of first computing an $$x^n$$, then adding $$a_{n-1} x^{n-1}$$, and so on. In fact, it is possible to prove that any algorithm for evaluating arbitrary polynomials must use at least as many additions and multiplications as does Horner's rule, and thus Horner's rule is an optimal algorithm for polynomial evaluation. This was proved (for the number of additions) by A. M. Ostrowski in his 1954 paper &quot;On Two Problems in Abstract Algebra Connected with Horner's rule&quot; that essentially founded the modern study of optimal algorithms. (For an overview of Ostrowski's life and work, see <a href="https://www.cs.purdue.edu/homes/wxg/AMOengl.pdf">Walter Gautschi's paper</a>.) The analogous statement for multiplications was proved by V. Y. Pan in 1966. The book by Borodin and Munro (1975) provides an overview of these and other results about optimal algorithms.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This is available in the Erlang standard library as <code>lists:foldr/3</code>.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>This is available in the Erlang standard library as <code>lists:foldl/3</code>. Note that <code>foldl</code> is more commonly used, in general, than <code>foldr</code> and it has the added benefit of being tail recursive in Erlang/LFE.</p>
</div>
<h4><a class="header" href="#nested-mappings" id="nested-mappings">Nested mappings</a></h4>
<p>We can extend the sequence paradigm to include many computations that are commonly expressed using nested loops.<sup class="footnote-reference"><a href="#1">1</a></sup> Consider this problem: Given a positive integer $$n$$, find all ordered pairs of distinct positive integers $$i$$ and $$j$$, where $$1&lt; j&lt; i&lt; n$$, such that $$i + j$$ is prime. For example, if $$n$$ is 6, then the pairs are the following:</p>
<p>$$
\begin{array}{c|c}
i     &amp; 2 \ 3 \ 4 \ 4 \ 5 \ 6 \ ; 6 \
j     &amp; 1 \ 2 \ 1 \ 3 \ 2 \ 1 \ ; 5 \
\hline
i + j &amp; , , 3 \ 5 \ 5 \ 7 \ 7 \ 7 \ 11 \
\end{array}
$$</p>
<p>A natural way to organize this computation is to generate the sequence of all ordered pairs of positive integers less than or equal to $$n$$, filter to select those pairs whose sum is prime, and then, for each pair $$(i, j)$$ that passes through the filter, produce the triple $$(i,j,i + j)$$.</p>
<p>Here is a way to generate the sequence of pairs: For each integer $$i&lt; n$$, enumerate the integers $$j&lt;i$$, and for each such $$i$$ and $$j$$ generate the pair $$(i,j)$$. In terms of sequence operations, we map along the sequence <code>(enumerate-interval 1 n)</code>. For each <code>i</code> in this sequence, we map along the sequence <code>(enumerate-interval 1 (- i 1))</code>. For each <code>j</code> in this latter sequence, we generate the pair <code>(list i j)</code>. This gives us a sequence of pairs for each <code>i</code>. Combining all the sequences for all the <code>i</code> (by accumulating with append) produces the required sequence of pairs: <sup class="footnote-reference"><a href="#2">2</a></sup></p>
<pre><code class="language-lisp">(accumulate #'append/2
            '()
            (mapper (lambda (i)
                    (mapper (lambda (j) (list i j))
                            (enumerate-interval 1 (- i 1))))
                    (enumerate-interval 1 n)))
</code></pre>
<p>The combination of mapping and accumulating with append is so common in this sort of program that we will isolate it as a separate procedure<sup class="footnote-reference"><a href="#3">3</a></sup>:</p>
<pre><code class="language-lisp">(defun flatmap (func seq)
  (accumulate append '() (mapper func seq)))
</code></pre>
<p>Now filter this sequence of pairs to find those whose sum is prime. The filter predicate is called for each element of the sequence; its argument is a pair and it must extract the integers from the pair. Thus, the predicate to apply to each element in the sequence is</p>
<pre><code class="language-lisp">(defun prime-sum? (pair)
  (prime? (+ (car pair) (cadr pair))))
</code></pre>
<p>Finally, generate the sequence of results by mapping over the filtered pairs using the following procedure, which constructs a triple consisting of the two elements of the pair along with their sum:</p>
<pre><code class="language-lisp">(defun make-pair-sum (pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
</code></pre>
<p>Combining all these steps yields the complete procedure:</p>
<pre><code class="language-lisp">(defun prime-sum-pairs (n)
  (mapper #'make-pair-sum/1
          (filter #'prime-sum?/1
                  (flatmap
                  (lambda (i)
                    (map (lambda (j) (list i j))
                         (enumerate-interval 1 (- i 1))))
                  (enumerate-interval 1 n)))))
</code></pre>
<p>Nested mappings are also useful for sequences other than those that enumerate intervals. Suppose we wish to generate all the permutations of a set S; that is, all the ways of ordering the items in the set. For instance, the permutations of {1,2,3} are {1,2,3}, { 1,3,2}, {2,1,3}, { 2,3,1}, { 3,1,2}, and { 3,2,1}. Here is a plan for generating the permutations of $$S$$: For each item $$x$$ in $$S$$, recursively generate the sequence of permutations of $$S - x$$,<sup class="footnote-reference"><a href="#4">4</a></sup> and adjoin $$x$$ to the front of each one. This yields, for each $$x$$ in $$S$$, the sequence of permutations of $$S$$ that begin with $$x$$. Combining these sequences for all $$x$$ gives all the permutations of $$S$$: <sup class="footnote-reference"><a href="#5">5</a></sup></p>
<pre><code class="language-lisp">(defun permutations
  (('())                     ; empty set?
   (list '()))               ; sequence containing empty set
  ((s)
   (flatmap (lambda (x)
              (map (lambda (p) (cons x p))
                   (permutations (remove x s))))
            s)))
</code></pre>
<p>Notice how this strategy reduces the problem of generating permutations of $$S$$ to the problem of generating the permutations of sets with fewer elements than $$S$$. In the terminal case, we work our way down to the empty list, which represents a set of no elements. For this, we generate <code>(list '())</code>, which is a sequence with one item, namely the set with no elements. The remove procedure used in permutations returns all the items in a given sequence except for a given item. This can be expressed as a simple filter:</p>
<pre><code class="language-lisp">(defun remove (item sequence)
  (filter (lambda (x) (not (=:= x item)))
          sequence))
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This approach to nested mappings was shown to us by David Turner, whose languages KRC and Miranda provide elegant formalisms for dealing with these constructs. The examples in this section (see also exercise 2.42) are adapted from Turner 1981. In the section <a href="ch2/">Exploiting the Stream Paradigm</a>, we'll see how this approach generalizes to infinite sequences.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>We're representing a pair here as a list of two elements rather than as a Lisp pair. Thus, the &quot;pair&quot; <code>(i,j)</code> is represented as <code>(list i j)</code>, not <code>(cons i j)</code>.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>We are using this for pedagogical purposes; in real projects you would use <code>(funcall #'lists:append/1 nested-list)</code>.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>The set $$S - x$$ is the set of all elements of $$S$$, excluding $$x$$.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>Semicolons in LFE code are used to introduce comments. Everything from the semicolon to the end of the line is ignored by the interpreter. In this book we don't use many comments; we try to make our programs self-documenting by using descriptive names.</p>
</div>
<h3><a class="header" href="#exercises-21" id="exercises-21">Exercises</a></h3>
<h4><a class="header" href="#exercise-240" id="exercise-240">Exercise 2.40</a></h4>
<p>Define a function <code>unique-pairs</code> that, given an integer $$n$$, generates the sequence of pairs $$(i,j)$$ with $$1 \le j \lt i \le n$$. Use <code>unique-pairs</code> to simplify the definition of <code>prime-sum-pairs</code> given in the previous section.</p>
<h4><a class="header" href="#exercise-241" id="exercise-241">Exercise 2.41</a></h4>
<p>Write a function to find all ordered triples of distinct positive integers $$i$$, $$j$$, and $$k$$ less than or equal to a given integer $$n$$ that sum to a given integer $$s$$.</p>
<h4><a class="header" href="#exercise-242" id="exercise-242">Exercise 2.42</a></h4>
<p><a name="figure-2-8"></a>
<img src="ch2/images/ch2-Z-G-23.png" alt="A solution to the eight-queens puzzle" /></p>
<p><strong>Figure 2.8</strong>:  A solution to the eight-queens puzzle.</p>
<p>The &quot;eight-queens puzzle&quot; asks how to place eight queens on a chessboard so that no queen is in check from any other (i.e., no two queens are in the same row, column, or diagonal). One possible solution is shown in figure 2.8. One way to solve the puzzle is to work across the board, placing a queen in each column. Once we have placed $$k - 1$$ queens, we must place the $$k$$th queen in a position where it does not check any of the queens already on the board. We can formulate this approach recursively: Assume that we have already generated the sequence of all possible ways to place $$k - 1$$ queens in the first $$k - 1$$ columns of the board. For each of these ways, generate an extended set of positions by placing a queen in each row of the $$k$$th column. Now filter these, keeping only the positions for which the queen in the $$k$$th column is safe with respect to the other queens. This produces the sequence of all ways to place $$k$$ queens in the first $$k$$ columns. By continuing this process, we will produce not only one solution, but all solutions to the puzzle.</p>
<p>We implement this solution as a function <code>queens/1</code>, which returns a sequence of all solutions to the problem of placing $$n$$ queens on an $$n \times n$$ chessboard. <code>queen/1</code>s another function, <code>queen-cols/1</code>, that returns the sequence of all ways to place queens in the first $$k$$ columns of the board.</p>
<pre><code class="language-lisp">(defun queens (board-size)
  (queen-cols board-size))
  
(defun queen-cols (k)
  (if (== k 0)
      (empty-board)
      (lists:filter
        (lambda (positions) (safe? k positions))
        (flatmap
          (lambda (rest-of-queens)
            (lists:map (lambda (new-row)
                         (adjoin-position new-row k rest-of-queens))
                       (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
</code></pre>
<p>In this function <code>rest-of-queens</code> is a way to place $$k - 1$$ queens in the first $$k - 1$$ columns, and <code>new-row</code> is a proposed row in which to place the queen for the $$k$$th column. Complete the program by implementing the representation for sets of board positions, including the procedure <code>adjoin-position</code>, which adjoins a new row-column position to a set of positions, and <code>empty-board</code>, which represents an empty set of positions. You must also write the procedure <code>safe?/2</code>, which determines for a set of positions, whether the queen in the kth column is safe with respect to the others. (Note that we need only check whether the new queen is safe -- the other queens are already guaranteed safe with respect to each other.)</p>
<h4><a class="header" href="#exercise-243" id="exercise-243">Exercise 2.43</a></h4>
<p>Louis Reasoner is having a terrible time doing exercise 2.42. His <code>queens/1</code> function seems to work, but it runs extremely slowly. (Louis never does manage to wait long enough for it to solve even the 6× 6 case.) When Louis asks Eva Lu Ator for help, she points out that he has interchanged the order of the nested mappings in the <code>flatmap</code>, writing it as</p>
<pre><code class="language-lisp">(flatmap
 (lambda (new-row)
   (lists:map (lambda (rest-of-queens)
                (adjoin-position new-row k rest-of-queens))
              (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
</code></pre>
<p>Explain why this interchange makes the program run slowly. Estimate how long it will take Louis's program to solve the eight-queens puzzle, assuming that the program in exercise 2.42 solves the puzzle in time $$T$$.</p>
<h3><a class="header" href="#example-a-picture-language" id="example-a-picture-language">Example: A Picture Language</a></h3>
<p>This section presents a simple language for drawing pictures that illustrates the power of data abstraction and closure, and also exploits higher-order procedures in an essential way. The language is designed to make it easy to experiment with patterns such as the ones in figure 2.9, which are composed of repeated elements that are shifted and scaled.<sup class="footnote-reference"><a href="#1">1</a></sup> In this language, the data objects being combined are represented as procedures rather than as list structure. Just as <code>cons</code>, which satisfies the closure property, allowed us to easily build arbitrarily complicated list structure, the operations in this language, which also satisfy the closure property, allow us to easily build arbitrarily complicated patterns.</p>
<p><a name="figure-2-9"></a>
<img src="ch2/images/ch2-Z-G-24.png" alt="picture language example 1" />
<img src="ch2/images/ch2-Z-G-25.png" alt="picture language example 2" /></p>
<p><strong>Figure 2.9</strong>:  Designs generated with the picture language.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The picture language is based on the language Peter Henderson created to construct images like M.C. Escher's &quot;Square Limit&quot; woodcut (see Henderson 1982). The woodcut incorporates a repeated scaled pattern, similar to the arrangements drawn using the <code>square-limit</code> function in this section.</p>
</div>
<h4><a class="header" href="#the-picture-language" id="the-picture-language">The picture language</a></h4>
<p>When we began our study of programming in the section <a href="ch2/">The Elements of Programming</a>, we emphasized the importance of describing a language by focusing on the language's primitives, its means of combination, and its means of abstraction. We'll follow that framework here.</p>
<p>Part of the elegance of this picture language is that there is only one kind of element, called a painter. A painter draws an image that is shifted and scaled to fit within a designated parallelogram-shaped frame. For example, there's a primitive painter we'll call wave that makes a crude line drawing, as shown in figure 2.10. The actual shape of the drawing depends on the frame -- all four images in figure 2.10 are produced by the same wave painter, but with respect to four different frames. Painters can be more elaborate than this: The primitive painter called rogers paints a picture of MIT's founder, William Barton Rogers, as shown in figure 2.11. <sup class="footnote-reference"><a href="#1">1</a></sup> The four images in figure 2.11 are drawn with respect to the same four frames as the <code>wave</code> images in figure 2.10.</p>
<p>To combine images, we use various operations that construct new painters from given painters. For example, the beside operation takes two painters and produces a new, compound painter that draws the first painter's image in the left half of the frame and the second painter's image in the right half of the frame. Similarly, below takes two painters and produces a compound painter that draws the first painter's image below the second painter's image. Some operations transform a single painter to produce a new painter. For example, flip-vert takes a painter and produces a painter that draws its image upside-down, and flip-horiz produces a painter that draws the original painter's image left-to-right reversed.</p>
<p><a name="figure-2-10"></a>
<img src="ch2/images/ch2-Z-G-26.png" alt="Images produced by the wave painter, with respect to four different frames. The frames, shown with dotted lines, are not part of the images" /></p>
<p><strong>Figure 2.10</strong>:  Images produced by the wave painter, with respect to four different frames. The frames, shown with dotted lines, are not part of the images.</p>
<p><a name="figure-2-11"></a>
<img src="ch2/images/ch2-Z-G-30.png" alt="Images of William Barton Rogers, founder and first president of MIT, painted with respect to the same four frames as in figure 2.10 (original image reprinted with the permission of the MIT Museum)." /></p>
<p><strong>Figure 2.11</strong>:  Images of William Barton Rogers, founder and first president of MIT, painted with respect to the same four frames as in figure 2.10 (original image reprinted with the permission of the MIT Museum).</p>
<p>Figure 2.12 shows the drawing of a painter called <code>wave4</code> that is built up in two stages starting from <code>wave</code>:</p>
<p><a name="figure-2-12"></a></p>
<pre><code class="language-lisp">(defun wave2 (beside wave (flip-vert wave)))
(defun wave4 (below wave2 wave2))
</code></pre>
<p><img src="ch2/images/ch2-Z-G-35.png" alt="Creating a complex figure, starting from the wave painter of figure 2.10." /></p>
<pre><code class="language-lisp">(defun wave2 (beside wave (flip-vert wave)))
(defun wave4 (below wave2 wave2))
</code></pre>
<p><strong>Figure 2.12</strong>: Creating a complex figure, starting from the wave painter of figure 2.10.</p>
<p>In building up a complex image in this manner we are exploiting the fact that painters are closed under the language's means of combination. The beside or below of two painters is itself a painter; therefore, we can use it as an element in making more complex painters. As with building up list structure using cons, the closure of our data under the means of combination is crucial to the ability to create complex structures while using only a few operations.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>William Barton Rogers (1804-1882) was the founder and first president of MIT. A geologist and talented teacher, he taught at William and Mary College and at the University of Virginia. In 1859 he moved to Boston, where he had more time for research, worked on a plan for establishing a &quot;polytechnic institute,&quot; and served as Massachusetts's first State Inspector of Gas Meters. When MIT was established in 1861, Rogers was elected its first president. Rogers espoused an ideal of &quot;useful learning&quot; that was different from the university education of the time, with its overemphasis on the classics, which, as he wrote, &quot;stand in the way of the broader, higher and more practical instruction and discipline of the natural and social sciences.&quot; This education was likewise to be different from narrow trade-school education. In Rogers's words: &quot;The world-enforced distinction between the practical and the scientific worker is utterly futile, and the whole experience of modern times has demonstrated its utter worthlessness.&quot; Rogers served as president of MIT until 1870, when he resigned due to ill health. In 1878 the second president of MIT, John Runkle, resigned under the pressure of a financial crisis brought on by the Panic of 1873 and strain of fighting off attempts by Harvard to take over MIT. Rogers returned to hold the office of president until 1881. Rogers collapsed and died while addressing MIT's graduating class at the commencement exercises of 1882. Runkle quoted Rogers's last words in a memorial address delivered that same year: &quot;As I stand here today and see what the Institute is, ... I call to mind the beginnings of science. I remember one hundred and fifty years ago Stephen Hales published a pamphlet on the subject of illuminating gas, in which he stated that his researches had demonstrated that 128 grains of bituminous coal -- &quot; &quot;Bituminous coal,&quot; these were his last words on earth. Here he bent forward, as if consulting some notes on the table before him, then slowly regaining an erect position, threw up his hands, and was translated from the scene of his earthly labors and triumphs to &quot;the tomorrow of death,&quot; where the mysteries of life are solved, and the disembodied spirit finds unending satisfaction in contemplating the new and still unfathomable mysteries of the infinite future. In the words of Francis A. Walker (MIT's third president): &quot;All his life he had borne himself most faithfully and heroically, and he died as so good a knight would surely have wished, in harness, at his post, and in the very part and act of public duty.&quot;</p>
</div>
<h1><a class="header" href="#computing-with-register-machines" id="computing-with-register-machines">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-1" id="computing-with-register-machines-1">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-2" id="computing-with-register-machines-2">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-3" id="computing-with-register-machines-3">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-4" id="computing-with-register-machines-4">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-5" id="computing-with-register-machines-5">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-6" id="computing-with-register-machines-6">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-7" id="computing-with-register-machines-7">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-8" id="computing-with-register-machines-8">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-9" id="computing-with-register-machines-9">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-10" id="computing-with-register-machines-10">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-11" id="computing-with-register-machines-11">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-12" id="computing-with-register-machines-12">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-13" id="computing-with-register-machines-13">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-14" id="computing-with-register-machines-14">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-15" id="computing-with-register-machines-15">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-16" id="computing-with-register-machines-16">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-17" id="computing-with-register-machines-17">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-18" id="computing-with-register-machines-18">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-19" id="computing-with-register-machines-19">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-20" id="computing-with-register-machines-20">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-21" id="computing-with-register-machines-21">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-22" id="computing-with-register-machines-22">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-23" id="computing-with-register-machines-23">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-24" id="computing-with-register-machines-24">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-25" id="computing-with-register-machines-25">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-26" id="computing-with-register-machines-26">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-27" id="computing-with-register-machines-27">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-28" id="computing-with-register-machines-28">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-29" id="computing-with-register-machines-29">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-30" id="computing-with-register-machines-30">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-31" id="computing-with-register-machines-31">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-32" id="computing-with-register-machines-32">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-33" id="computing-with-register-machines-33">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-34" id="computing-with-register-machines-34">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-35" id="computing-with-register-machines-35">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-36" id="computing-with-register-machines-36">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-37" id="computing-with-register-machines-37">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-38" id="computing-with-register-machines-38">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-39" id="computing-with-register-machines-39">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-40" id="computing-with-register-machines-40">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-41" id="computing-with-register-machines-41">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-42" id="computing-with-register-machines-42">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-43" id="computing-with-register-machines-43">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-44" id="computing-with-register-machines-44">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-45" id="computing-with-register-machines-45">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-46" id="computing-with-register-machines-46">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-47" id="computing-with-register-machines-47">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-48" id="computing-with-register-machines-48">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-49" id="computing-with-register-machines-49">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-50" id="computing-with-register-machines-50">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-51" id="computing-with-register-machines-51">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-52" id="computing-with-register-machines-52">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-53" id="computing-with-register-machines-53">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-54" id="computing-with-register-machines-54">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-55" id="computing-with-register-machines-55">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-56" id="computing-with-register-machines-56">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-57" id="computing-with-register-machines-57">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-58" id="computing-with-register-machines-58">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-59" id="computing-with-register-machines-59">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-60" id="computing-with-register-machines-60">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-61" id="computing-with-register-machines-61">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-62" id="computing-with-register-machines-62">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-63" id="computing-with-register-machines-63">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-64" id="computing-with-register-machines-64">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-65" id="computing-with-register-machines-65">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-66" id="computing-with-register-machines-66">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-67" id="computing-with-register-machines-67">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-68" id="computing-with-register-machines-68">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-69" id="computing-with-register-machines-69">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-70" id="computing-with-register-machines-70">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-71" id="computing-with-register-machines-71">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-72" id="computing-with-register-machines-72">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-73" id="computing-with-register-machines-73">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-74" id="computing-with-register-machines-74">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-75" id="computing-with-register-machines-75">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-76" id="computing-with-register-machines-76">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-77" id="computing-with-register-machines-77">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-78" id="computing-with-register-machines-78">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-79" id="computing-with-register-machines-79">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-80" id="computing-with-register-machines-80">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-81" id="computing-with-register-machines-81">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-82" id="computing-with-register-machines-82">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-83" id="computing-with-register-machines-83">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-84" id="computing-with-register-machines-84">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-85" id="computing-with-register-machines-85">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-86" id="computing-with-register-machines-86">Computing with Register Machines</a></h1>
<h1><a class="header" href="#computing-with-register-machines-87" id="computing-with-register-machines-87">Computing with Register Machines</a></h1>
<h1><a class="header" href="#references" id="references">References</a></h1>
<h1><a class="header" href="#list-of-exercises" id="list-of-exercises">List of Exercises</a></h1>
<h1><a class="header" href="#versions" id="versions">Versions</a></h1>
<h2><a class="header" href="#current" id="current">Current</a></h2>
<p>The current version of the SICP is written against LFE 2.0-dev; as such, it has started tracking its own version in sync with LFE releases.</p>
<h2><a class="header" href="#previous" id="previous">Previous</a></h2>
<p>After the LFE 2.0 release, you will see a link to content created as part of that effort here. At which point the &quot;Current&quot; version will be incremented.</p>
<h1><a class="header" href="#feedback-and-docs-bugs" id="feedback-and-docs-bugs">Feedback and Docs Bugs</a></h1>
<p>If you would like to provide feedback about this book, we would welcome the
chance to improve the experience for everyone. Please
<a href="https://github.com/cnbbooks/lfe-sicp/issues/new">create a ticket</a> in the
Github issue tracker. Be sure to give a full description so that we can best
help you!</p>
<meta http-equiv="refresh" content="0; URL=http://docs.lfe.io/" />
<meta http-equiv="refresh" content="0; URL=https://github.com/rust-lang/mdbook/" />

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    

                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            

            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];

        // make sure we don't activate google analytics if the developer is
        // inspecting the book locally...
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-38274766-4', 'auto');
            ga('send', 'pageview');
        }
    </script>
    

    

    
    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    

    

    
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    
    
    <script type="text/javascript">
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>
    
    

</body>

</html>
